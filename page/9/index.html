<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="enjoy share">
<meta property="og:type" content="website">
<meta property="og:title" content="hhyvs111">
<meta property="og:url" content="http://yoursite.com/page/9/index.html">
<meta property="og:site_name" content="hhyvs111">
<meta property="og:description" content="enjoy share">
<meta property="article:author" content="tanwenbo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>hhyvs111</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hhyvs111</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Be a great man</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/14/linux-e5-91-bd-e4-bb-a4-e8-a1-8c-e4-b8-8eshell-e8-84-9a-e6-9c-ac-e7-bc-96-e7-a8-8b-e5-a4-a7-e5-85-a8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/14/linux-e5-91-bd-e4-bb-a4-e8-a1-8c-e4-b8-8eshell-e8-84-9a-e6-9c-ac-e7-bc-96-e7-a8-8b-e5-a4-a7-e5-85-a8/" class="post-title-link" itemprop="url">Linux命令行与shell脚本编程大全</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-14 07:06:28" itemprop="dateCreated datePublished" datetime="2018-05-14T07:06:28+08:00">2018-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux命令行与shell脚本编程大全"><a href="#Linux命令行与shell脚本编程大全" class="headerlink" title="Linux命令行与shell脚本编程大全"></a>Linux命令行与shell脚本编程大全</h1><p><code>《Linux命令行与shell脚本编程大全》``shell``posts</code></p>
<ul>
<li><a href="#linux命令行与shell脚本编程大全">Linux命令行与shell脚本编程大全</a><ul>
<li><a href="#1-初识linux-shell">1 初识Linux shell</a><ul>
<li><a href="#11-什么是linux">1.1 什么是Linux</a></li>
<li><a href="#12-gnu工具">1.2 GNU工具</a></li>
<li><a href="#13-shell">1.3 shell</a></li>
<li><a href="#14-linux发行版">1.4 Linux发行版</a></li>
</ul>
</li>
<li><a href="#2-走进shell">2 走进shell</a><ul>
<li><a href="#21-进入命令行">2.1 进入命令行</a></li>
<li><a href="#22-通过linux控制台终端访问cli">2.2 通过Linux控制台终端访问CLI</a></li>
</ul>
</li>
<li><a href="#3-基本的bash-shell命令">3 基本的bash shell命令</a><ul>
<li><a href="#31-启动shell">3.1 启动shell</a></li>
<li><a href="#32-shell提示符">3.2 shell提示符</a></li>
<li><a href="#33-bash-手册">3.3 bash 手册</a><ul>
<li><a href="#linux手册页的内容区域">Linux手册页的内容区域</a></li>
</ul>
</li>
<li><a href="#34-浏览文件系统">3.4 浏览文件系统</a><ul>
<li><a href="#常见linux目录结构">常见Linux目录结构</a></li>
</ul>
</li>
<li><a href="#35-遍历目录">3.5 遍历目录</a><ul>
<li><a href="#351-绝对文件路径">3.5.1 绝对文件路径</a></li>
<li><a href="#352-相对文件路径">3.5.2 相对文件路径</a></li>
</ul>
</li>
<li><a href="#36-文件和目录列表">3.6 文件和目录列表</a></li>
<li><a href="#37-处理文件">3.7 处理文件</a><ul>
<li><a href="#371-创建文件">3.7.1 创建文件</a></li>
<li><a href="#372-复制文件">3.7.2 复制文件</a></li>
<li><a href="#373-制表键自动补全">3.7.3 制表键自动补全</a></li>
<li><a href="#374-链接文件">3.7.4 链接文件</a></li>
<li><a href="#375-重命名文件">3.7.5 重命名文件</a></li>
<li><a href="#376-删除文件">3.7.6 删除文件</a></li>
</ul>
</li>
<li><a href="#38-处理目录">3.8 处理目录</a><ul>
<li><a href="#371-创建目录">3.7.1 创建目录</a></li>
<li><a href="#372-删除目录">3.7.2 删除目录</a></li>
</ul>
</li>
<li><a href="#39-查看文件内容">3.9 查看文件内容</a><ul>
<li><a href="#391-查看文件类型">3.9.1 查看文件类型</a></li>
<li><a href="#392-查看整个文件">3.9.2 查看整个文件</a></li>
<li><a href="#393-查看部分文件">3.9.3 查看部分文件</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-更多的bash-shell命令">4 更多的bash shell命令</a><ul>
<li><a href="#41-监测程序">4.1 监测程序</a><ul>
<li><a href="#411-探查进程">4.1.1 探查进程</a><ul>
<li><a href="#unix风格的ps命令参数">Unix风格的ps命令参数</a></li>
</ul>
</li>
<li><a href="#412-实时监测进程">4.1.2 实时监测进程</a></li>
<li><a href="#413-结束进程">4.1.3 结束进程</a></li>
</ul>
</li>
<li><a href="#42-检测磁盘空间">4.2 检测磁盘空间</a><ul>
<li><a href="#421-挂在存储媒体">4.2.1 挂在存储媒体</a></li>
<li><a href="#422-查看磁盘空间">4.2.2 查看磁盘空间</a></li>
</ul>
</li>
<li><a href="#43-处理数据文件">4.3 处理数据文件</a><ul>
<li><a href="#431-排序数据">4.3.1 排序数据</a></li>
<li><a href="#432-搜索数据">4.3.2 搜索数据</a></li>
<li><a href="#433-压缩数据">4.3.3 压缩数据</a></li>
<li><a href="#434-归档数据">4.3.4 归档数据</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-理解shell">5 理解shell</a><ul>
<li><a href="#51-shell的类型">5.1 shell的类型</a></li>
<li><a href="#52-shell的父子关系">5.2 shell的父子关系</a><ul>
<li><a href="#521-进程列表">5.2.1 进程列表</a></li>
<li><a href="#521-牛笔的子shell用法">5.2.1 牛笔的子shell用法</a><ul>
<li><a href="#1后台模式">1）后台模式</a></li>
<li><a href="#2进程列表置于后台">2）进程列表置于后台</a></li>
<li><a href="#3协程">3）协程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#53-理解shell的内建命令">5.3 理解shell的内建命令</a><ul>
<li><a href="#531-外部命令">5.3.1 外部命令</a></li>
<li><a href="#532-内建命令">5.3.2 内建命令</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-使用linux环境变量">6 使用Linux环境变量</a><ul>
<li><a href="#61-什么是环境变量">6.1 什么是环境变量</a><ul>
<li><a href="#611-全局环境变量">6.1.1 全局环境变量</a></li>
<li><a href="#612-局部环境变量">6.1.2 局部环境变量</a></li>
</ul>
</li>
<li><a href="#62-设置用户定义变量">6.2 设置用户定义变量</a><ul>
<li><a href="#621-设置局部用户定义变量">6.2.1 设置局部用户定义变量</a></li>
<li><a href="#622-设置全局环境变量">6.2.2 设置全局环境变量</a></li>
</ul>
</li>
<li><a href="#63-删除环境">6.3 删除环境</a></li>
<li><a href="#64-默认的shell环境变量">6.4 默认的shell环境变量</a></li>
<li><a href="#65-设置path环境变量">6.5 设置PATH环境变量</a></li>
<li><a href="#66-环境变量持久化">6.6 环境变量持久化</a></li>
</ul>
</li>
<li><a href="#7-理解linux文件权限">7 理解Linux文件权限</a><ul>
<li><a href="#71-linux的安全性">7.1 Linux的安全性</a><ul>
<li><a href="#711-etcpasswd文件">7.1.1 /etc/passwd文件</a></li>
<li><a href="#712-etcshadow文件">7.1.2 /etc/shadow文件</a></li>
<li><a href="#713-添加新用户">7.1.3 添加新用户</a></li>
<li><a href="#714-删除用户">7.1.4 删除用户</a></li>
<li><a href="#715-修改用户">7.1.5 修改用户</a></li>
</ul>
</li>
<li><a href="#72-使用linux组">7.2 使用Linux组</a><ul>
<li><a href="#721-etcgroup文件">7.2.1 /etc/group文件</a></li>
</ul>
</li>
<li><a href="#73-理解文件权限">7.3 理解文件权限</a><ul>
<li><a href="#731-使用文件权限符">7.3.1 使用文件权限符</a><ul>
<li><a href="#第一个字符">第一个字符：</a></li>
<li><a href="#3组三字符编码每一组定义了3种访问权限">3组三字符编码，每一组定义了3种访问权限：</a></li>
<li><a href="#每一组分别是">每一组分别是：</a></li>
</ul>
</li>
<li><a href="#732-默认文件权限">7.3.2 默认文件权限</a><ul>
<li><a href="#linux文件权限码">Linux文件权限码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#74-改变安全性设置">7.4 改变安全性设置</a><ul>
<li><a href="#741-改变权限">7.4.1 改变权限</a></li>
<li><a href="#742-改变所属关系">7.4.2 改变所属关系</a></li>
</ul>
</li>
<li><a href="#75-共享文件">7.5 共享文件</a></li>
</ul>
</li>
<li><a href="#8-管理文件系统">8 管理文件系统</a><ul>
<li><a href="#81-探索linux文件系统">8.1 探索Linux文件系统</a><ul>
<li><a href="#811-基本的linux文件系统">8.1.1 基本的Linux文件系统</a><ul>
<li><a href="#1ext文件系统">1）ext文件系统</a></li>
<li><a href="#2ext2文件系统">2）ext2文件系统</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#82-操作文件系统">8.2 操作文件系统</a><ul>
<li><a href="#821-创建分区">8.2.1 创建分区</a></li>
<li><a href="#822-创建文件系统">8.2.2 创建文件系统</a><ul>
<li><a href="#创建文件系统的命令行程序">创建文件系统的命令行程序</a></li>
</ul>
</li>
<li><a href="#823-文件系统的检查与修复">8.2.3 文件系统的检查与修复</a></li>
</ul>
</li>
<li><a href="#83-逻辑卷管理">8.3 逻辑卷管理</a><ul>
<li><a href="#831-逻辑卷管理布局">8.3.1 逻辑卷管理布局</a><ul>
<li><a href="#逻辑卷管理环境的基本布局">逻辑卷管理环境的基本布局：</a></li>
</ul>
</li>
<li><a href="#832-linux中的lvm">8.3.2 Linux中的LVM</a><ul>
<li><a href="#1快照">1）快照</a></li>
<li><a href="#2条带化">2）条带化</a></li>
<li><a href="#3镜像">3）镜像</a></li>
</ul>
</li>
<li><a href="#833-使用linux-lvm">8.3.3 使用Linux LVM</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#9-安装软件程序">9 安装软件程序</a><ul>
<li><a href="#91-包管理基础">9.1 包管理基础</a></li>
<li><a href="#92-基于debian的系统">9.2 基于Debian的系统</a><ul>
<li><a href="#921-用aptitude管理软件包">9.2.1 用aptitude管理软件包</a></li>
<li><a href="#922-用aptitude安装软件包">9.2.2 用aptitude安装软件包</a></li>
<li><a href="#923-用aptitude更新软件">9.2.3 用aptitude更新软件</a></li>
<li><a href="#924-用aptitude卸载软件">9.2.4 用aptitude卸载软件</a></li>
<li><a href="#93-apt-get和aptitude的区别">9.3 apt-get和aptitude的区别</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#10-使用编辑器">10 使用编辑器</a><ul>
<li><a href="#101-vim编辑器">10.1 vim编辑器</a><ul>
<li><a href="#1011-检查vim软件包">10.1.1 检查vim软件包</a></li>
<li><a href="#1012-vim基础">10.1.2 vim基础</a></li>
<li><a href="#1013-编辑数据">10.1.3 编辑数据</a></li>
<li><a href="#1014-复制和粘贴">10.1.4 复制和粘贴</a></li>
<li><a href="#1015-查找和替换">10.1.5 查找和替换</a><ul>
<li><a href="#1-查找">1） 查找</a></li>
<li><a href="#1替换">1）替换</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#11-构建基本脚本">11 构建基本脚本</a><ul>
<li><a href="#111-使用多个命令">11.1 使用多个命令</a></li>
<li><a href="#112-创建shell脚本文件">11.2 创建shell脚本文件</a><ul>
<li><a href="#1121-编写自己的脚本">11.2.1 编写自己的脚本</a><ul>
<li><a href="#1建一个文件夹存放脚本">1）建一个文件夹存放脚本</a></li>
<li><a href="#2将该文件添加到path里2和7选一个">2）将该文件添加到PATH里（2和7选一个）</a></li>
<li><a href="#3新建文件">3）新建文件</a></li>
<li><a href="#4将命令写入文件并保存">4）将命令写入文件并保存</a></li>
<li><a href="#5更改权限">5）更改权限</a></li>
<li><a href="#6运行脚本">6）运行脚本</a></li>
<li><a href="#7将脚本目录加入到环境变量">7）将脚本目录加入到环境变量</a></li>
<li><a href="#8在任意界面运行脚本">8）在任意界面运行脚本</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#113-显示消息">11.3 显示消息</a></li>
<li><a href="#114-使用变量">11.4 使用变量</a><ul>
<li><a href="#1141-使用环境变量">11.4.1 使用环境变量</a></li>
<li><a href="#1142-用户变量">11.4.2 用户变量</a></li>
<li><a href="#1143-命令替换">11.4.3 命令替换</a></li>
</ul>
</li>
<li><a href="#115-重定向输入和输出">11.5 重定向输入和输出</a><ul>
<li><a href="#1151-输出重定向">11.5.1 输出重定向</a></li>
<li><a href="#1152-输入重定向">11.5.2 输入重定向</a><ul>
<li><a href="#内联输入重定向符号">内联输入重定向符号</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#116-管道">11.6 管道</a></li>
<li><a href="#117-执行数学运算">11.7 执行数学运算</a><ul>
<li><a href="#1171-expr命令">11.7.1 expr命令</a></li>
<li><a href="#1172-使用方括号">11.7.2 使用方括号</a></li>
<li><a href="#1173-浮点解决方案">11.7.3 浮点解决方案</a><ul>
<li><a href="#在脚本里使用bc">在脚本里使用bc</a></li>
<li><a href="#使用内联输入重定向解决多个表达式的麻烦">使用内联输入重定向解决多个表达式的麻烦</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#118-退出脚本">11.8 退出脚本</a><ul>
<li><a href="#1181-查看退出状态码">11.8.1 查看退出状态码</a></li>
<li><a href="#1182-exit退出码">11.8.2 exit退出码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#12-使用结构化命令">12 使用结构化命令</a><ul>
<li><a href="#121-使用if-then语句">12.1 使用if-then语句</a></li>
<li><a href="#122-if-then-else语句">12.2 if-then-else语句</a></li>
<li><a href="#123-嵌套if">12.3 嵌套if</a></li>
<li><a href="#124-test命令">12.4 test命令</a></li>
<li><a href="#125-复合条件测试">12.5 复合条件测试</a></li>
<li><a href="#126-if-then的高级特性">12.6 if-then的高级特性</a><ul>
<li><a href="#1261-双括号">12.6.1 双括号</a></li>
<li><a href="#1262-使用方括号">12.6.2 使用方括号</a></li>
</ul>
</li>
<li><a href="#127-case命令">12.7 case命令</a></li>
</ul>
</li>
<li><a href="#13-更多结构化命令">13 更多结构化命令</a><ul>
<li><a href="#131-for命令">13.1 for命令</a><ul>
<li><a href="#1311-读取列表中的值">13.1.1 读取列表中的值</a></li>
<li><a href="#1312-读取列表中的复杂值">13.1.2 读取列表中的复杂值</a></li>
<li><a href="#1313-从变量读取列表">13.1.3 从变量读取列表</a></li>
<li><a href="#1314-从命令读取值">13.1.4 从命令读取值</a></li>
<li><a href="#1315-更改字符分隔符">13.1.5 更改字符分隔符</a></li>
<li><a href="#1316-用通配符读取目录">13.1.6 用通配符读取目录</a></li>
</ul>
</li>
<li><a href="#132-c语言风格的for命令">13.2 C语言风格的for命令</a><ul>
<li><a href="#1321-c语言的for命令">13.2.1 C语言的for命令</a></li>
<li><a href="#1322-使用多个变量">13.2.2 使用多个变量</a></li>
</ul>
</li>
<li><a href="#133-while命令">13.3 while命令</a><ul>
<li><a href="#1331-while的基本格式">13.3.1 while的基本格式</a></li>
<li><a href="#1332-使用多个测试命令">13.3.2 使用多个测试命令</a></li>
</ul>
</li>
<li><a href="#134-until-命令">13.4 until 命令</a></li>
<li><a href="#135-嵌套循环">13.5 嵌套循环</a></li>
<li><a href="#136-循环处理文件数据">13.6 循环处理文件数据</a></li>
<li><a href="#137-控制循环">13.7 控制循环</a><ul>
<li><a href="#1371-break命令">13.7.1 break命令</a><ul>
<li><a href="#1跳出单个循环">1）跳出单个循环</a></li>
<li><a href="#2跳出内部循环">2）跳出内部循环</a></li>
<li><a href="#3跳出外层循环">3）跳出外层循环</a></li>
</ul>
</li>
<li><a href="#1372-continue命令">13.7.2 continue命令</a></li>
</ul>
</li>
<li><a href="#138-处理循环的输出">13.8 处理循环的输出</a></li>
</ul>
</li>
<li><a href="#14-处理用户输入">14 处理用户输入</a><ul>
<li><a href="#141命令行参数">14.1命令行参数</a><ul>
<li><a href="#1411-读取参数">14.1.1 读取参数</a></li>
<li><a href="#1412-读取脚本名">14.1.2 读取脚本名</a></li>
<li><a href="#1413-测试参数">14.1.3 测试参数</a></li>
</ul>
</li>
<li><a href="#142-特殊参数变量">14.2 特殊参数变量</a><ul>
<li><a href="#1421-参数统计">14.2.1 参数统计</a></li>
<li><a href="#1422-抓取所有的数据">14.2.2 抓取所有的数据</a></li>
</ul>
</li>
<li><a href="#143-移动变量">14.3 移动变量</a></li>
<li><a href="#144-处理选项">14.4 处理选项</a><ul>
<li><a href="#1441-查找选项">14.4.1 查找选项</a></li>
<li><a href="#1442-使用getopt命令">14.4.2 使用getopt命令</a></li>
<li><a href="#1443-更高级的getopts命令">14.4.3 更高级的getopts命令</a></li>
</ul>
</li>
<li><a href="#145-选项标准化">14.5 选项标准化</a></li>
<li><a href="#146-获得用户输入">14.6 获得用户输入</a><ul>
<li><a href="#1461-基本的读取">14.6.1 基本的读取</a></li>
<li><a href="#1462-超时">14.6.2 超时</a></li>
<li><a href="#1463-隐藏方式读取">14.6.3 隐藏方式读取</a></li>
<li><a href="#1464-从文件中读取">14.6.4 从文件中读取</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#15-呈现数据">15 呈现数据</a><ul>
<li><a href="#151-理解输入和输出">15.1 理解输入和输出</a><ul>
<li><a href="#1511-标准文件描述符">15.1.1 标准文件描述符</a><ul>
<li><a href="#linux的标准文件描述符">Linux的标准文件描述符</a></li>
<li><a href="#1-stdin">1) STDIN</a></li>
<li><a href="#2-stdout">2) STDOUT</a></li>
<li><a href="#3stderr">3）STDERR</a></li>
</ul>
</li>
<li><a href="#1512-重定向错误">15.1.2 重定向错误</a></li>
<li><a href="#1513-重定向错误和数据">15.1.3 重定向错误和数据</a></li>
</ul>
</li>
<li><a href="#152-在脚本中重定向输出">15.2 在脚本中重定向输出</a><ul>
<li><a href="#1521-临时重定向">15.2.1 临时重定向</a></li>
<li><a href="#1522-永久重定向">15.2.2 永久重定向</a></li>
</ul>
</li>
<li><a href="#153-在脚本重定向输入">15.3 在脚本重定向输入</a></li>
<li><a href="#154-创建自己的重定向">15.4 创建自己的重定向</a></li>
<li><a href="#155-列出打开的文件描述符">15.5 列出打开的文件描述符</a></li>
<li><a href="#156-阻止命令输出">15.6 阻止命令输出</a></li>
<li><a href="#157-创建临时文件">15.7 创建临时文件</a><ul>
<li><a href="#1571-创建本地临时文件">15.7.1 创建本地临时文件</a></li>
<li><a href="#1572-在tmp目录创建临时文件">15.7.2 在/tmp目录创建临时文件</a></li>
<li><a href="#1573-创建临时目录">15.7.3 创建临时目录</a></li>
</ul>
</li>
<li><a href="#158-记录消息">15.8 记录消息</a></li>
</ul>
</li>
<li><a href="#16-控制脚本">16 控制脚本</a><ul>
<li><a href="#161-处理信号">16.1 处理信号</a><ul>
<li><a href="#1611-主要linux信号">16.1.1 主要Linux信号</a></li>
<li><a href="#1612-生成信号">16.1.2 生成信号</a><ul>
<li><a href="#1中断进程">1）中断进程</a></li>
<li><a href="#2-暂停进程">2） 暂停进程</a></li>
</ul>
</li>
<li><a href="#1613-捕获信号">16.1.3 捕获信号</a></li>
<li><a href="#1614-捕获脚本退出">16.1.4 捕获脚本退出</a></li>
<li><a href="#1615-修改或移除捕获">16.1.5 修改或移除捕获</a></li>
</ul>
</li>
<li><a href="#162-以后台模式运行脚本">16.2 以后台模式运行脚本</a></li>
<li><a href="#163-在非控制台下运行脚本">16.3 在非控制台下运行脚本</a></li>
<li><a href="#164-作业控制">16.4 作业控制</a><ul>
<li><a href="#1641-查看作业">16.4.1 查看作业</a></li>
<li><a href="#1642-重启停止的作业">16.4.2 重启停止的作业</a></li>
</ul>
</li>
<li><a href="#165-调整谦让度">16.5 调整谦让度</a><ul>
<li><a href="#1651-nice命令">16.5.1 nice命令</a></li>
<li><a href="#1652-renice命令">16.5.2 renice命令</a></li>
</ul>
</li>
<li><a href="#166-定时运行作业">16.6 定时运行作业</a><ul>
<li><a href="#1661-用at命令来计划执行作业">16.6.1 用at命令来计划执行作业</a></li>
<li><a href="#1662-安排需要定期执行的脚本">16.6.2 安排需要定期执行的脚本</a><ul>
<li><a href="#cron目录">cron目录</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#17-创建函数">17 创建函数</a><ul>
<li><a href="#171-基本函数">17.1 基本函数</a></li>
<li><a href="#172-返回值">17.2 返回值</a></li>
<li><a href="#173-在函数中使用变量">17.3 在函数中使用变量</a></li>
<li><a href="#174-数组变量和函数">17.4 数组变量和函数</a></li>
<li><a href="#175-函数递归">17.5 函数递归</a></li>
<li><a href="#176-创建库">17.6 创建库</a></li>
<li><a href="#177-在命令行上使用函数">17.7 在命令行上使用函数</a></li>
</ul>
</li>
<li><a href="#18-图形化桌面环境中的脚本编程">18 图形化桌面环境中的脚本编程</a></li>
<li><a href="#19-初识sed和gawk">19 初识sed和gawk</a><ul>
<li><a href="#191-sed编辑器">19.1 sed编辑器</a><ul>
<li><a href="#1911-插入数据">19.1.1 插入数据</a></li>
<li><a href="#1912-使用sed-处理文件">19.1.2 使用sed 处理文件</a></li>
</ul>
</li>
<li><a href="#192-gawk程序">19.2 gawk程序</a></li>
</ul>
</li>
<li><a href="#20-正则表达式">20 正则表达式</a><ul>
<li><a href="#201-正则表达式的类型">20.1 正则表达式的类型</a></li>
<li><a href="#202-bre模式">20.2 BRE模式</a><ul>
<li><a href="#2021-纯文本">20.2.1 纯文本</a></li>
<li><a href="#2022-特殊字符">20.2.2 特殊字符</a></li>
<li><a href="#2023-锚字符">20.2.3 锚字符</a><ul>
<li><a href="#1锁定在行首">1）锁定在行首</a></li>
<li><a href="#2锁定在行尾">2）锁定在行尾</a></li>
<li><a href="#3组合锚点">3）组合锚点</a></li>
</ul>
</li>
<li><a href="#2024-点号字符">20.2.4 点号字符</a></li>
<li><a href="#2025-字符组">20.2.5 字符组</a></li>
<li><a href="#2026-排除型字符组">20.2.6 排除型字符组</a></li>
<li><a href="#2027-区间">20.2.7 区间</a></li>
<li><a href="#2028-特殊的字符组">20.2.8 特殊的字符组</a></li>
<li><a href="#2029-星号">20.2.9 星号</a></li>
</ul>
</li>
<li><a href="#203-扩展正则表达式">20.3 扩展正则表达式</a><ul>
<li><a href="#2031-问号">20.3.1 问号</a></li>
<li><a href="#2032-加号">20.3.2 加号</a></li>
<li><a href="#2033-使用花括号">20.3.3 使用花括号</a></li>
<li><a href="#2034-管道符号">20.3.4 管道符号</a></li>
<li><a href="#2035-表达式分组">20.3.5 表达式分组</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#21-sed进阶">21 sed进阶</a><ul>
<li><a href="#211-多行命令">21.1 多行命令</a><ul>
<li><a href="#2111-next命令">21.1.1 next命令</a><ul>
<li><a href="#1单行的next命令">1）单行的next命令</a></li>
<li><a href="#2-合并文本行">2） 合并文本行</a></li>
</ul>
</li>
<li><a href="#2112-多行删除命令">21.1.2 多行删除命令</a></li>
<li><a href="#2113-多行打印命令">21.1.3 多行打印命令</a></li>
</ul>
</li>
<li><a href="#212-保持空间">21.2 保持空间</a></li>
<li><a href="#213-排除命令">21.3 排除命令</a></li>
<li><a href="#214-改变流">21.4 改变流</a><ul>
<li><a href="#2141-分支">21.4.1 分支</a></li>
<li><a href="#2142-测试">21.4.2 测试</a></li>
</ul>
</li>
<li><a href="#215-模式替代">21.5 模式替代</a><ul>
<li><a href="#2151-符号">21.5.1 &amp;符号</a></li>
<li><a href="#2152-替代单独的单词">21.5.2 替代单独的单词</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#22-gawk进阶">22 gawk进阶</a><ul>
<li><a href="#221-使用变量">22.1 使用变量</a><ul>
<li><a href="#2211-内建变量">22.1.1 内建变量</a></li>
<li><a href="#2212-自定义变量">22.1.2 自定义变量</a></li>
</ul>
</li>
<li><a href="#222-处理数组">22.2 处理数组</a><ul>
<li><a href="#2221-定义数组变量">22.2.1 定义数组变量</a></li>
<li><a href="#2222-遍历数组变量">22.2.2 遍历数组变量</a></li>
<li><a href="#2223-删除数组变量">22.2.3 删除数组变量</a></li>
</ul>
</li>
<li><a href="#223-使用模式">22.3 使用模式</a></li>
<li><a href="#224-结构化命令">22.4 结构化命令</a><ul>
<li><a href="#2241-if语句">22.4.1 if语句</a></li>
<li><a href="#2242-while语句">22.4.2 while语句</a></li>
<li><a href="#2243-do-while语句">22.4.3 do-while语句</a></li>
<li><a href="#2244-for语句">22.4.4 for语句</a></li>
</ul>
</li>
<li><a href="#225-格式化打印">22.5 格式化打印</a></li>
<li><a href="#226-内建函数">22.6 内建函数</a><ul>
<li><a href="#2261-数学函数">22.6.1 数学函数</a></li>
<li><a href="#2262-字符串函数">22.6.2 字符串函数</a></li>
<li><a href="#2263-时间函数">22.6.3 时间函数</a></li>
</ul>
</li>
<li><a href="#227-自定义函数">22.7 自定义函数</a></li>
</ul>
</li>
<li><a href="#23-总结">23 总结</a></li>
</ul>
</li>
</ul>
<blockquote>
<p>老师说只需要了解下基本命令用法和基本的shell脚本语法即可，那么快速过一遍</p>
</blockquote>
<h2 id="1-初识Linux-shell"><a href="#1-初识Linux-shell" class="headerlink" title="1 初识Linux shell"></a>1 初识Linux shell</h2><h3 id="1-1-什么是Linux"><a href="#1-1-什么是Linux" class="headerlink" title="1.1 什么是Linux"></a>1.1 什么是Linux</h3><p>Linux和Windows一样也是系统，是基于Unix开发的。</p>
<blockquote>
<p>一切皆文件</p>
</blockquote>
<p>Linux系统将硬件设备当成特殊的文件，称为设备文件。设备文件有3种分类：</p>
<ul>
<li>字符型设备文件</li>
<li>块设备文件</li>
<li>网络设备文件</li>
</ul>
<h3 id="1-2-GNU工具"><a href="#1-2-GNU工具" class="headerlink" title="1.2 GNU工具"></a>1.2 GNU工具</h3><p>GNU项目的主旨在于为Unix系统管理员设计出一套类似于Unix的环境。这个目标促使该项目 移植了很多常见的Unix系统命令行工具。</p>
<h3 id="1-3-shell"><a href="#1-3-shell" class="headerlink" title="1.3 shell"></a>1.3 shell</h3><p>GNU/Linux shell是一种特殊的交互式工具。它为用户提供了启动程序、管理文件系统中的文 件以及运行在Linux系统上的进程的途径。shell的核心是命令行提示符。命令行提示符是shell负责 交互的部分。它允许你输入文本命令，然后解释命令，并在内核中执行。</p>
<blockquote>
<p>通过shell命令行界面管理Linux系统，所以习惯了图形界面的Windows用户可能对其很难上手。而且没有了图形界面，对系统的开销也变小了，所以Linux十分适合用于服务器的操作系统。因为服务器并不需要花哨的界面，只需要能稳定运行就行。</p>
</blockquote>
<h3 id="1-4-Linux发行版"><a href="#1-4-Linux发行版" class="headerlink" title="1.4 Linux发行版"></a>1.4 Linux发行版</h3><p>有很多发行版，比如自己经常使用的Ubuntu。</p>
<h2 id="2-走进shell"><a href="#2-走进shell" class="headerlink" title="2 走进shell"></a>2 走进shell</h2><h3 id="2-1-进入命令行"><a href="#2-1-进入命令行" class="headerlink" title="2.1 进入命令行"></a>2.1 进入命令行</h3><p>在图形化桌面出现之前，与Unix系统进行交互的唯一方式就是借助由shell所提供的文本命令 行界面（command line interface，CLI）。CLI只能接受文本输入，也只能显示出文本和基本的图形输出。</p>
<blockquote>
<p>熟悉命令行后操作起来会很快</p>
</blockquote>
<p>shell也叫控制台终端，顾名思义<code>控制Linux</code></p>
<h3 id="2-2-通过Linux控制台终端访问CLI"><a href="#2-2-通过Linux控制台终端访问CLI" class="headerlink" title="2.2 通过Linux控制台终端访问CLI"></a>2.2 通过Linux控制台终端访问CLI</h3><p>具体的不再赘述，Linux虚拟控制台中是无法运行任何图形化程序的。</p>
<blockquote>
<p>记得以前在阿里云服务器跑QT写的服务器，总是出现“图形化”之类的错误，后来通过某命令行禁用图形输出才跑起来。</p>
</blockquote>
<h2 id="3-基本的bash-shell命令"><a href="#3-基本的bash-shell命令" class="headerlink" title="3 基本的bash shell命令"></a>3 基本的bash shell命令</h2><h3 id="3-1-启动shell"><a href="#3-1-启动shell" class="headerlink" title="3.1 启动shell"></a>3.1 启动shell</h3><p>当用户登录Linux系统后，bash shell会自动启动。</p>
<h3 id="3-2-shell提示符"><a href="#3-2-shell提示符" class="headerlink" title="3.2 shell提示符"></a>3.2 shell提示符</h3><p>默认bash shell提示符是美元符号（<code>$</code>），这个符号表明shell在等待用户输入。提示符中显示了当前用户ID名和系统名。</p>
<blockquote>
<p>超级管理员的提示符是<code>#</code></p>
</blockquote>
<h3 id="3-3-bash-手册"><a href="#3-3-bash-手册" class="headerlink" title="3.3 bash 手册"></a>3.3 bash 手册</h3><p>man命令用来访问存储在Linux系统上的手册页面。 man 后的数字也有特别指代，手册有对应的内容区域。每个内容区域都分配了一个数字。</p>
<h4 id="Linux手册页的内容区域"><a href="#Linux手册页的内容区域" class="headerlink" title="Linux手册页的内容区域"></a>Linux手册页的内容区域</h4><p>区域号</p>
<p>所涵盖的内容</p>
<p>1</p>
<p>可执行程序或shell命令</p>
<p>2</p>
<p>系统调用</p>
<p>3</p>
<p>库调用</p>
<p>4</p>
<p>特殊文件</p>
<p>5</p>
<p>文件格式与约定</p>
<p>6</p>
<p>游戏</p>
<p>7</p>
<p>概览、约定及杂项</p>
<p>8</p>
<p>超级用户和系统管理员命令</p>
<p>9</p>
<p>内核例程</p>
<p>这个命令很好用，比如当你编程的时候想要了解某个函数的作用，可以在终端直接：</p>
<pre><code>man 2 read
//查询系统调用里的read </code></pre><h3 id="3-4-浏览文件系统"><a href="#3-4-浏览文件系统" class="headerlink" title="3.4 浏览文件系统"></a>3.4 浏览文件系统</h3><p>文件系统是Linux里很重要的内容，因为Linux所有内容都以文件存储。 Linux里没有盘符的概念，所有内容以树形结构展现。</p>
<p><img src="https://tanwenbo.top/wp-content/uploads/2018/06/f8a8270008c3e268713a2cdf93fc12af.png" alt=""></p>
<h4 id="常见Linux目录结构"><a href="#常见Linux目录结构" class="headerlink" title="常见Linux目录结构"></a>常见Linux目录结构</h4><p>目录</p>
<p>用途</p>
<p>/</p>
<p>虚拟目录的根目录。通常不会在这里存储文件</p>
<p>/bin</p>
<p>二进制目录，存放许多用户级的GNU工具</p>
<p>/boot</p>
<p>启动目录，存放启动文件</p>
<p>/dev</p>
<p>设备目录，Linux在这里创建设备节点</p>
<p>/etc</p>
<p>系统配置文件目录</p>
<p>/home</p>
<p>主目录，Linux在这里创建用户目录</p>
<p>/lib</p>
<p>库目录，存放系统和应用程序的库文件</p>
<p>/media</p>
<p>媒体目录，可移动媒体设备的常用挂载点</p>
<p>/mnt</p>
<p>挂载目录，另一个可移动媒体设备的常用挂载点</p>
<p>/opt</p>
<p>可选目录，常用于存放第三方软件包和数据文件</p>
<p>/proc</p>
<p>进程目录，存放现有硬件及当前进程的相关信息</p>
<p>/root</p>
<p>root用户的主目录</p>
<p>/sbin</p>
<p>系统二进制目录，存放许多GNU管理员级工具</p>
<p>/run</p>
<p>运行目录，存放系统运作时的运行时数据</p>
<p>/srv</p>
<p>服务目录，存放本地服务的相关文件</p>
<p>/sys</p>
<p>系统目录，存放系统硬件信息的相关文件</p>
<p>/tmp</p>
<p>临时目录，可以在该目录中创建和删除临时工作文件</p>
<p>/usr</p>
<p>用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里</p>
<p>/var</p>
<p>可变目录，用以存放经常变化的文件，比如日志文件</p>
<h3 id="3-5-遍历目录"><a href="#3-5-遍历目录" class="headerlink" title="3.5 遍历目录"></a>3.5 遍历目录</h3><p>遍历目录基本来说是大家最熟悉的Linux命令行，<code>cd</code>。用好了可以如行云流水般行走于各个文件夹，熟悉该命令相当重要。</p>
<h4 id="3-5-1-绝对文件路径"><a href="#3-5-1-绝对文件路径" class="headerlink" title="3.5.1 绝对文件路径"></a>3.5.1 绝对文件路径</h4><p>绝对文件路径定义了在虚拟目录结构中该目录的确切位置，以虚拟目录的<strong>根目录</strong>开始，相当于目录的<strong>全名</strong>，可以使用如下绝对文件路径：</p>
<pre><code>cd /usr/bin </code></pre><h4 id="3-5-2-相对文件路径"><a href="#3-5-2-相对文件路径" class="headerlink" title="3.5.2 相对文件路径"></a>3.5.2 相对文件路径</h4><p>没有<code>/</code>开头的文件路径就是相对文件路径。需要注意当前目录，指令：<code>pwd</code> 有两个特殊字符可用于相对文件路径中：</p>
<ul>
<li>单点符（<code>.</code>），表示当前目录；</li>
<li>双点符（<code>..</code>），表示当前目录的父目录。</li>
</ul>
<p>比如：</p>
<pre><code>cd ..
//返回上层目录 </code></pre><h3 id="3-6-文件和目录列表"><a href="#3-6-文件和目录列表" class="headerlink" title="3.6 文件和目录列表"></a>3.6 文件和目录列表</h3><p>想要知道系统中有哪些文件，可以使用列表命令（<code>ls</code>）。 <strong>命令结构：</strong> ls（选项）（参数）</p>
<p>比如：</p>
<pre><code>ls - l
//显示当前目录文件详细信息，包括权限、作者和创建时间等 </code></pre><h3 id="3-7-处理文件"><a href="#3-7-处理文件" class="headerlink" title="3.7 处理文件"></a>3.7 处理文件</h3><h4 id="3-7-1-创建文件"><a href="#3-7-1-创建文件" class="headerlink" title="3.7.1 创建文件"></a>3.7.1 创建文件</h4><p><code>touch</code>命令创建空文件，比如：</p>
<pre><code>touch test_one </code></pre><h4 id="3-7-2-复制文件"><a href="#3-7-2-复制文件" class="headerlink" title="3.7.2 复制文件"></a>3.7.2 复制文件</h4><p><code>cp</code>命令复制文件，需要两个参数——源对象和目标对象：</p>
<pre><code>cp source destination </code></pre><h4 id="3-7-3-制表键自动补全"><a href="#3-7-3-制表键自动补全" class="headerlink" title="3.7.3 制表键自动补全"></a>3.7.3 制表键自动补全</h4><p>使用键盘的<code>Tab</code>键对命令自动补齐，前提是当前目录没有出现类似的文件或目录。</p>
<h4 id="3-7-4-链接文件"><a href="#3-7-4-链接文件" class="headerlink" title="3.7.4 链接文件"></a>3.7.4 链接文件</h4><p>链接文件是Linux文件系统的一个优势。如需要在系统上维护同一文件的两份或多份副本，除了保存多份单独的物理文件副本之外，还可以采用保存一份物理文件副本和多个虚拟副本的方法。这种虚拟的副本就称为链接。链接是目录中指向文件真实位置的占位符。 <strong>在Linux中有两种不同类型的文件链接：</strong></p>
<ul>
<li><p><strong>符号链接(软链接)</strong></p>
<p>软链接文件有类似于Windows的快捷方式，符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</p>
<p>   ln -s data_file sl_datafile<br>   //表明sl_datafile指向了data_file</p>
</li>
</ul>
<ul>
<li><p><strong>硬链接</strong> 硬连接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。<strong>从根本上而言，他们是同一个文件，删除原文件对链接文件无影响。</strong></p>
<p> ln code_file hl_code_file<br> //不需要加参数，ln默认为硬链接 </p>
</li>
</ul>
<h4 id="3-7-5-重命名文件"><a href="#3-7-5-重命名文件" class="headerlink" title="3.7.5 重命名文件"></a>3.7.5 重命名文件</h4><p>在Linux中，重命名文件称为移动（moving）。mv命令可以将文件和目录移动到另一个位置 或重新命名。</p>
<p><strong>移动文件：</strong> mv 文件 目录</p>
<p><strong>重命名：</strong> mv 文件 文件名</p>
<h4 id="3-7-6-删除文件"><a href="#3-7-6-删除文件" class="headerlink" title="3.7.6 删除文件"></a>3.7.6 删除文件</h4><p>bash shell 中删除文件的命令是rm。</p>
<pre><code>rm file</code></pre><blockquote>
<p>sudo rm-rf /* ，从删库到跑路（斜眼）</p>
</blockquote>
<h3 id="3-8-处理目录"><a href="#3-8-处理目录" class="headerlink" title="3.8 处理目录"></a>3.8 处理目录</h3><h4 id="3-7-1-创建目录"><a href="#3-7-1-创建目录" class="headerlink" title="3.7.1 创建目录"></a>3.7.1 创建目录</h4><p>使用<code>mkdir</code>命令创建目录。</p>
<pre><code>mkdir new_dir </code></pre><h4 id="3-7-2-删除目录"><a href="#3-7-2-删除目录" class="headerlink" title="3.7.2 删除目录"></a>3.7.2 删除目录</h4><p>使用<code>rmdir</code>命令删除目录，一般只能删除空目录。</p>
<pre><code>rmdir dir </code></pre><h3 id="3-9-查看文件内容"><a href="#3-9-查看文件内容" class="headerlink" title="3.9 查看文件内容"></a>3.9 查看文件内容</h3><h4 id="3-9-1-查看文件类型"><a href="#3-9-1-查看文件类型" class="headerlink" title="3.9.1 查看文件类型"></a>3.9.1 查看文件类型</h4><p>使用<code>file</code>命令查看文件类型。</p>
<pre><code>file my_file
//输出：myfile:ASCII text </code></pre><h4 id="3-9-2-查看整个文件"><a href="#3-9-2-查看整个文件" class="headerlink" title="3.9.2 查看整个文件"></a>3.9.2 查看整个文件</h4><p>Linux有3个命令可以完成这个任务。</p>
<ul>
<li><p><strong>cat命令</strong></p>
<p>显示文本所有数据。但是会一直跳动，知道文件末尾，所以查看较长的文件比较麻烦。</p>
</li>
<li><p><strong>more命令</strong></p>
<p>填补了cat命令的缺点，具有分页功能。</p>
</li>
<li><p><strong>less命令</strong></p>
<p>more命令的加强版，提供翻页，跳转，查找等命令。</p>
</li>
</ul>
<h4 id="3-9-3-查看部分文件"><a href="#3-9-3-查看部分文件" class="headerlink" title="3.9.3 查看部分文件"></a>3.9.3 查看部分文件</h4><p>通常你要查看的数据要么在文本文件的开头，要么在文本文件的末尾。如果你的需要的内容在文件末尾，你用cat或more加载完整个文件之后才能看到。Linux提供以下命令解决这个问题：</p>
<ul>
<li><p><strong>tail命令</strong></p>
<p>tail命令会显示文件最后几行的内容。默认情况会显示文件的末尾10行。</p>
</li>
<li><p><strong>head命令</strong></p>
<p>顾名思义，会显示文件开头那些行的内容。</p>
</li>
</ul>
<h2 id="4-更多的bash-shell命令"><a href="#4-更多的bash-shell命令" class="headerlink" title="4 更多的bash shell命令"></a>4 更多的bash shell命令</h2><h3 id="4-1-监测程序"><a href="#4-1-监测程序" class="headerlink" title="4.1 监测程序"></a>4.1 监测程序</h3><h4 id="4-1-1-探查进程"><a href="#4-1-1-探查进程" class="headerlink" title="4.1.1 探查进程"></a>4.1.1 探查进程</h4><p>当程序运行在系统上，我们称之为进程（process）。需要显示这些数据，使用<code>ps</code>命令。 默认的<code>ps</code>命令只会显示运行在<strong>当前控制台下的属于当前用户的进程</strong>。 虽然有三种风格的参数，但是目前只需要熟悉Unix风格的就行。记几个常用的就行。</p>
<h5 id="Unix风格的ps命令参数"><a href="#Unix风格的ps命令参数" class="headerlink" title="Unix风格的ps命令参数"></a>Unix风格的ps命令参数</h5><p>目录</p>
<p>用途</p>
<p>-A</p>
<p>显示所有进程</p>
<p>-N</p>
<p>显示与指定参数不符的所有进程</p>
<p>-a</p>
<p>显示除控制进程（session leader①）和无终端进程外的所有进程</p>
<p>-d</p>
<p>显示除控制进程外的所有进程</p>
<p>-e</p>
<p>显示所有进程</p>
<p>-M</p>
<p>显示进程的安全信息</p>
<p>-c</p>
<p>显示进程的额外调度器信息</p>
<p>-f</p>
<p>显示完整格式的输出</p>
<p>-j</p>
<p>显示任务信息</p>
<p>-l</p>
<p>显示长列表</p>
<p>命令也可以组合使用，如：</p>
<pre><code>ps -ef </code></pre><h4 id="4-1-2-实时监测进程"><a href="#4-1-2-实时监测进程" class="headerlink" title="4.1.2 实时监测进程"></a>4.1.2 实时监测进程</h4><p>使用<code>top</code>命令实时监测进程，跟Windows任务管理器一样。</p>
<h4 id="4-1-3-结束进程"><a href="#4-1-3-结束进程" class="headerlink" title="4.1.3 结束进程"></a>4.1.3 结束进程</h4><p>杀死进程是十分重要的命令，不能乱用。Linux里有两个命令可以杀死进程</p>
<ul>
<li><p><code>kill</code> 通过进程ID（<code>PID</code>）给进程发送信号。比如：</p>
<p>kill 3940<br>//3940为将要结束进程的PID</p>
</li>
</ul>
<ul>
<li><p><code>killall</code> 可以通过进程名而不是PID来结束进程，也支持通配符。</p>
<p>killall http*<br>//结束了所有以http开头的进程，比如httpd </p>
</li>
</ul>
<h3 id="4-2-检测磁盘空间"><a href="#4-2-检测磁盘空间" class="headerlink" title="4.2 检测磁盘空间"></a>4.2 检测磁盘空间</h3><blockquote>
<p>个人使用该命令不多，可能空间足够大，都不关心是否够用了</p>
</blockquote>
<h4 id="4-2-1-挂在存储媒体"><a href="#4-2-1-挂在存储媒体" class="headerlink" title="4.2.1 挂在存储媒体"></a>4.2.1 挂在存储媒体</h4><p>Linux文件系统将所有的磁盘都并入一个虚拟目录下。在使用新的存储媒体之前，需要把它放到虚拟目录下。</p>
<ul>
<li><code>mount</code> 显示当前系统挂载的设备列表。</li>
<li><code>umount</code> 从Linux系统上移除一个可移动设备时，不能直接从系统上移除，而应该先卸载。</li>
</ul>
<blockquote>
<p>就像使用Windows系统一样，拔U盘的时候不能直接拔，要先点“安全移除设备”。</p>
</blockquote>
<h4 id="4-2-2-查看磁盘空间"><a href="#4-2-2-查看磁盘空间" class="headerlink" title="4.2.2 查看磁盘空间"></a>4.2.2 查看磁盘空间</h4><ul>
<li><p><code>df</code></p>
<p>命令</p>
<p>查看某个设备还有多少磁盘空间。加 <code>-h</code>参数，它会把输出的磁盘空间按照用户易读的形式显示。</p>
</li>
<li><p><code>du</code></p>
<p>命令</p>
<p>du命令可以显示某个特定目录（默认情况下是当前目录）的磁盘使用情况。这一方法可用来快速判断系统上某个目录下是不是有超大文件。</p>
</li>
</ul>
<h3 id="4-3-处理数据文件"><a href="#4-3-处理数据文件" class="headerlink" title="4.3 处理数据文件"></a>4.3 处理数据文件</h3><h4 id="4-3-1-排序数据"><a href="#4-3-1-排序数据" class="headerlink" title="4.3.1 排序数据"></a>4.3.1 排序数据</h4><p>使用<code>sort</code>命令对文本中的数据排序，<strong>要注意其并不会改变文件里的数据，只是排序输出</strong>。</p>
<pre><code>sort  -n file
//文本里的数据识别为数字，并按值排序 </code></pre><h4 id="4-3-2-搜索数据"><a href="#4-3-2-搜索数据" class="headerlink" title="4.3.2 搜索数据"></a>4.3.2 搜索数据</h4><p>使用<code>grep</code>命令查找数据，这个命令用到的比例很高。</p>
<pre><code>grep 1 file1
//在file1里找three，是模糊查询，所有包含1的字符串都会显示</code></pre><p><img src="https://tanwenbo.top/wp-content/uploads/2018/06/84c52f7ba0ecd37edb43515263731b61.png" alt=""></p>
<p><strong>更多命令参数请看书82页。</strong></p>
<h4 id="4-3-3-压缩数据"><a href="#4-3-3-压缩数据" class="headerlink" title="4.3.3 压缩数据"></a>4.3.3 压缩数据</h4><p>这个命令很重要，一般使用GNU压缩工具。</p>
<ul>
<li><code>gzip</code> 压缩文件；支持通配符；</li>
<li>,<code>zcat</code> 查看压缩过的文本文件的内容；Ubuntu中没有<code>gzcat</code>命令，使用<code>zcat</code>代替了；而且如果压缩后使用<code>cat</code>是看不到文件内容的。</li>
<li><code>gunzip</code> 用来解压文件。</li>
</ul>
<h4 id="4-3-4-归档数据"><a href="#4-3-4-归档数据" class="headerlink" title="4.3.4 归档数据"></a>4.3.4 归档数据</h4><p>zip只能压缩文件而不能像Windows一样压缩文件夹，Linux提供<code>tar</code>命令来打包文件的。 <strong>下面是tar命令的格式：</strong></p>
<pre><code>tar function [options] object1 object2 ...</code></pre><p><strong>常用命令：</strong></p>
<ul>
<li><code>tar -cvf test.tar test/ test2/</code> 创建名为test.tar的归档文件，含有test和test2目录；</li>
<li><code>tar -tf test.tar</code> 列出tar文件test.tar的内容，但是不提取文件；</li>
<li><code>tar -xvf test.tar</code> 从tar文件test.tar中提取内容。</li>
</ul>
<p>可以看到参数都很乱，什么xvf，tf，因为功能和选项可以拼在一起用。具体可以看书84页。</p>
<h2 id="5-理解shell"><a href="#5-理解shell" class="headerlink" title="5 理解shell"></a>5 理解shell</h2><blockquote>
<p>这章讲的有点迷糊，其实对实际应用不大，但是还是可以了解一下。 主要讲的如何创建子shell以及父shell与子shell之间的关系。</p>
</blockquote>
<h3 id="5-1-shell的类型"><a href="#5-1-shell的类型" class="headerlink" title="5.1 shell的类型"></a>5.1 shell的类型</h3><p>系统启动什么样的shell程序取决于你个人的用户ID配置。一般都是使用的<code>GNU bash shell</code>作为自己默认的shell程序。</p>
<h3 id="5-2-shell的父子关系"><a href="#5-2-shell的父子关系" class="headerlink" title="5.2 shell的父子关系"></a>5.2 shell的父子关系</h3><blockquote>
<p>有点类似fork创建子线程，不注意就一层套一层。</p>
</blockquote>
<p>在命令行输入<code>bash</code>会在当前的shell创建一个子shell，但是注意只有部分父进程的环境被复制到子shell环境中。和fork不一样，fork是赋值父进程所有环境。</p>
<blockquote>
<p>所以bash之后，上下键查看使用过的命令与父进程的shell不一样。</p>
</blockquote>
<p><img src="https://tanwenbo.top/wp-content/uploads/2018/06/5ed3e94b34c7fb52367fd82a93eef0fa.png" alt=""></p>
<p>输入<code>exit</code>可以退出子<code>shell</code>，但是如果使用的远程<code>SSH</code>，最后一个<code>shell</code>退出后就断开链接了。</p>
<h4 id="5-2-1-进程列表"><a href="#5-2-1-进程列表" class="headerlink" title="5.2.1 进程列表"></a>5.2.1 进程列表</h4><p>可以像编程里一样，使用分号<code>;</code>同时执行一系列命令。如：</p>
<pre><code>$ pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls</code></pre><p>上面的例子，命令依次执行，不存在任何问题。不过这并不是进程列表。命令列表想要成为进程列表，这些命令必须包含在括号里。</p>
<pre><code>$ (pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls)</code></pre><p><strong>因为加了括号会生成一个子shell来执行对应的命令。</strong></p>
<blockquote>
<p>看似好像用了多个子shell处理任务，但是然并卵。它并非真正的多进程处理，因为终端始终控制着子shell的I/O。</p>
</blockquote>
<h4 id="5-2-1-牛笔的子shell用法"><a href="#5-2-1-牛笔的子shell用法" class="headerlink" title="5.2.1 牛笔的子shell用法"></a>5.2.1 牛笔的子shell用法</h4><h5 id="1）后台模式"><a href="#1）后台模式" class="headerlink" title="1）后台模式"></a>1）后台模式</h5><p>在命令末尾加上字符<code>&amp;</code>，可以让命令在后台运行。</p>
<blockquote>
<p>之前写的QT服务器需要后台运行，一开始还以为要一直开着shell，后来发现可以用这个方法让其后台一直常驻。</p>
</blockquote>
<pre><code>sleep 3000&amp;
//在后台睡眠3000秒</code></pre><p>使用<code>jobs</code>查看后台进程。</p>
<h5 id="2）进程列表置于后台"><a href="#2）进程列表置于后台" class="headerlink" title="2）进程列表置于后台"></a>2）进程列表置于后台</h5><p>一样在进程列表后面加个<code>&amp;</code>，好处是既可以在子shell进行繁重的处理工作，又不会让子shell的I/O受制于终端。<strong>这个功能用来后台解压文件，压缩文件十分好用。</strong></p>
<h5 id="3）协程"><a href="#3）协程" class="headerlink" title="3）协程"></a>3）协程</h5><p>使用coproc命令，其有两个功能：</p>
<ul>
<li><p>在后台生成一个子shell；</p>
</li>
<li><p>并在这个子shell中执行命令。</p>
<p>coproc sleep 10</p>
</li>
</ul>
<p>可以将其与进程列表结合，使用方便。</p>
<h3 id="5-3-理解shell的内建命令"><a href="#5-3-理解shell的内建命令" class="headerlink" title="5.3 理解shell的内建命令"></a>5.3 理解shell的内建命令</h3><h4 id="5-3-1-外部命令"><a href="#5-3-1-外部命令" class="headerlink" title="5.3.1 外部命令"></a>5.3.1 外部命令</h4><p>文件系统命令，存在与bash shell之外的程序。比如<code>ps</code>。外部命令通常位于/bin、/usr/bin、/sbin或/usr/sbin中。</p>
<h4 id="5-3-2-内建命令"><a href="#5-3-2-内建命令" class="headerlink" title="5.3.2 内建命令"></a>5.3.2 内建命令</h4><p>不同于外部命令，内建命令不需要子进程来执行。它们已经和shell编译编译成了一体，作为shell工具的组成部分存在。<code>cd</code>和<code>exit</code>都内建于bash shell。</p>
<blockquote>
<p>有些命令有多种实现，比如<code>echo</code>和<code>pwd</code>既有内建命令也有外部命令。</p>
</blockquote>
<ul>
<li><p><code>type</code></p>
<p>查看命令是否是内建，只有两种答案。</p>
<ul>
<li>xx is a shell builtin</li>
<li>xx is /bin/echo</li>
</ul>
</li>
<li><p><code>history</code> 查看最近使用过的命令（这个不错，不用之前一个个翻了），显示1000个。<strong>可以修改</strong></p>
</li>
<li><p><code>!!</code> 可以重用上一条命令，有点类似于<code>!cc</code>。</p>
</li>
<li><p><code>alias</code> 可以将命令设置一个别名，这个功能很好用，可以设置你熟悉的命令，减少输入量。</p>
<p>alias li=’ls -li’ </p>
</li>
</ul>
<h2 id="6-使用Linux环境变量"><a href="#6-使用Linux环境变量" class="headerlink" title="6 使用Linux环境变量"></a>6 使用Linux环境变量</h2><h3 id="6-1-什么是环境变量"><a href="#6-1-什么是环境变量" class="headerlink" title="6.1 什么是环境变量"></a>6.1 什么是环境变量</h3><blockquote>
<p>配置环境变量一直是Windows用户头疼之处，新手可能为此折腾大半天。那么Linux也需要配置，但是比Windows简单很多。</p>
</blockquote>
<p>环境变量允许你在内存中存储数据，以便程序或shell中运行的脚本能够轻松访问到他们。</p>
<h4 id="6-1-1-全局环境变量"><a href="#6-1-1-全局环境变量" class="headerlink" title="6.1.1 全局环境变量"></a>6.1.1 全局环境变量</h4><p><strong>全局环境变量对于shell会话和所有生成的子shell都是可见的。局部变量则只对创建它们的shell可见。</strong></p>
<ul>
<li><code>printenv</code> 查看全局环境变量。</li>
</ul>
<h4 id="6-1-2-局部环境变量"><a href="#6-1-2-局部环境变量" class="headerlink" title="6.1.2 局部环境变量"></a>6.1.2 局部环境变量</h4><p>只能在定义它们的进程中可见。</p>
<ul>
<li><code>set</code> 会显示某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义的变量。</li>
</ul>
<h3 id="6-2-设置用户定义变量"><a href="#6-2-设置用户定义变量" class="headerlink" title="6.2 设置用户定义变量"></a>6.2 设置用户定义变量</h3><h4 id="6-2-1-设置局部用户定义变量"><a href="#6-2-1-设置局部用户定义变量" class="headerlink" title="6.2.1 设置局部用户定义变量"></a>6.2.1 设置局部用户定义变量</h4><p>要注意，要在echo后直接用赋值，不能有别的操作。</p>
<pre><code>echo $my_variable

my_variable=hello</code></pre><blockquote>
<p><strong>所有的环境变量名均使用大写字母</strong>，这是bash shell的标准惯例。<strong>如果是你自己创建的局部变量或是shell脚本，请使用小写字母。</strong>变量名区分大小写。在涉及用户定义的局部变量时坚持使用小写字母，这能够避免重新定义系统环境变量可能带来的灾难。</p>
</blockquote>
<h4 id="6-2-2-设置全局环境变量"><a href="#6-2-2-设置全局环境变量" class="headerlink" title="6.2.2 设置全局环境变量"></a>6.2.2 设置全局环境变量</h4><p>需要先创建一个局部环境变量，然后再把它导出到全局环境中。</p>
<pre><code>echo $my_variable

my_variable=hello
export my_variable </code></pre><h3 id="6-3-删除环境"><a href="#6-3-删除环境" class="headerlink" title="6.3 删除环境"></a>6.3 删除环境</h3><pre><code>unset my_variable</code></pre><blockquote>
<p>在涉及环境变量名时，什么时候该使用$，什么时候不该使用$，实在让人摸不着头脑。记住一点就行了：<strong>如果要用到变量，使用<code>$</code></strong>；<strong>如果要操作变量，不使用<code>$</code></strong>。这条规则的一个例外就是使用printenv显示某个变量的值。</p>
</blockquote>
<h3 id="6-4-默认的shell环境变量"><a href="#6-4-默认的shell环境变量" class="headerlink" title="6.4 默认的shell环境变量"></a>6.4 默认的shell环境变量</h3><p>看书110页。</p>
<h3 id="6-5-设置PATH环境变量"><a href="#6-5-设置PATH环境变量" class="headerlink" title="6.5 设置PATH环境变量"></a>6.5 设置PATH环境变量</h3><blockquote>
<p>有点像Windows里的PATH环境变量，都是系统必须使用的。 和Win一样，也是在PATH后面加你输入的环境变量，不同的是加冒号<code>:</code>。</p>
</blockquote>
<pre><code>PATH=$PATH:/home/christine/Scripts </code></pre><h3 id="6-6-环境变量持久化"><a href="#6-6-环境变量持久化" class="headerlink" title="6.6 环境变量持久化"></a>6.6 环境变量持久化</h3><p>环境变量存放在/etc/profie文件不好，因为如果升级系统这个文件也跟着升级了。最好的方法是放在在<code>$HOME/.bashrc</code>里。</p>
<h2 id="7-理解Linux文件权限"><a href="#7-理解Linux文件权限" class="headerlink" title="7 理解Linux文件权限"></a>7 理解Linux文件权限</h2><blockquote>
<p>Linux系统也不是完全的安全。</p>
</blockquote>
<h3 id="7-1-Linux的安全性"><a href="#7-1-Linux的安全性" class="headerlink" title="7.1 Linux的安全性"></a>7.1 Linux的安全性</h3><p>用户权限是通过创建用户时分配的用户ID（User ID，通常缩写为UID）来跟踪的。UID是数值，每个用户都有唯一的UID，但在登录系统时用的不是UID，而是登录名。</p>
<h4 id="7-1-1-etc-passwd文件"><a href="#7-1-1-etc-passwd文件" class="headerlink" title="7.1.1 /etc/passwd文件"></a>7.1.1 /etc/passwd文件</h4><p>显示和用户有关的信息。</p>
<h4 id="7-1-2-etc-shadow文件"><a href="#7-1-2-etc-shadow文件" class="headerlink" title="7.1.2 /etc/shadow文件"></a>7.1.2 /etc/shadow文件</h4><p>显示用户加密的密码，只有root才能访问。</p>
<h4 id="7-1-3-添加新用户"><a href="#7-1-3-添加新用户" class="headerlink" title="7.1.3 添加新用户"></a>7.1.3 添加新用户</h4><ul>
<li><code>useradd</code> 可以一次性创建新用户账户及设置用户HOME目录结构。可以通过<code>/usr/sbin/useradd -D</code>查看用户默认设置。</li>
</ul>
<h4 id="7-1-4-删除用户"><a href="#7-1-4-删除用户" class="headerlink" title="7.1.4 删除用户"></a>7.1.4 删除用户</h4><ul>
<li><code>userdel</code> 只会删除/etc/passwd文件中的用户信息，而不会删除系统中属于该账户的任何文件。</li>
</ul>
<h4 id="7-1-5-修改用户"><a href="#7-1-5-修改用户" class="headerlink" title="7.1.5 修改用户"></a>7.1.5 修改用户</h4><p>命令</p>
<p>描述</p>
<p>usermod</p>
<p>修改用户账户的字段，还可以指定主要组以及附加组的所属关系</p>
<p>passwd</p>
<p>修改已有用户的密码</p>
<p>chpasswd</p>
<p>从文件中读取登录名密码对，并更新密码</p>
<p>chage</p>
<p>修改密码的过期日期</p>
<p>chfn</p>
<p>修改用户账户的备注信息</p>
<p>chsh</p>
<p>修改用户账户的默认登录shell</p>
<p>具体的可以参考书130页</p>
<h3 id="7-2-使用Linux组"><a href="#7-2-使用Linux组" class="headerlink" title="7.2 使用Linux组"></a>7.2 使用Linux组</h3><p>组权限允许多个用户对系统中的对象（比如文件、目录或设备等）共享一组共用的权限。</p>
<h4 id="7-2-1-etc-group文件"><a href="#7-2-1-etc-group文件" class="headerlink" title="7.2.1 /etc/group文件"></a>7.2.1 /etc/group文件</h4><p>/etc/group文件包含系统上用到的每个组的信息。</p>
<blockquote>
<p>其他的和用户的操作大致一样。</p>
</blockquote>
<h3 id="7-3-理解文件权限"><a href="#7-3-理解文件权限" class="headerlink" title="7.3 理解文件权限"></a>7.3 理解文件权限</h3><blockquote>
<p>这个很重要，面试的时候经常问道</p>
</blockquote>
<h4 id="7-3-1-使用文件权限符"><a href="#7-3-1-使用文件权限符" class="headerlink" title="7.3.1 使用文件权限符"></a>7.3.1 使用文件权限符</h4><p>这是一个文件的ls信息</p>
<pre><code>-rw-rw-r-- 1 rich rich 50 2010-09-13 07:49 file1.gz </code></pre><h5 id="第一个字符："><a href="#第一个字符：" class="headerlink" title="第一个字符："></a>第一个字符：</h5><ul>
<li><code>-</code>代表文件</li>
<li><code>d</code>代表目录</li>
<li><code>l</code>代表链接</li>
<li><code>c</code>代表字符型设备</li>
<li><code>b</code>代表块设备</li>
<li><code>n</code>代表网络设备</li>
</ul>
<h5 id="3组三字符编码，每一组定义了3种访问权限："><a href="#3组三字符编码，每一组定义了3种访问权限：" class="headerlink" title="3组三字符编码，每一组定义了3种访问权限："></a>3组三字符编码，每一组定义了3种访问权限：</h5><ul>
<li><code>r</code>代表对象是可读的，数值<code>4</code></li>
<li><code>w</code>代表对象是可写的，数值<code>2</code></li>
<li><code>x</code>代表对象是可执行的，数值<code>1</code></li>
</ul>
<h5 id="每一组分别是："><a href="#每一组分别是：" class="headerlink" title="每一组分别是："></a>每一组分别是：</h5><ul>
<li>对象的属主</li>
<li>对象的属组</li>
<li>系统其他用户</li>
</ul>
<p><img src="https://tanwenbo.top/wp-content/uploads/2018/06/d79e5448951be03663c4885d0aeb4454.png" alt=""> 上图的数字权限为：<code>775</code>。</p>
<h4 id="7-3-2-默认文件权限"><a href="#7-3-2-默认文件权限" class="headerlink" title="7.3.2 默认文件权限"></a>7.3.2 默认文件权限</h4><ul>
<li><p><code>umask</code> 设置所创建文件和目录的权限，但是显示的只是<strong>掩码</strong>，真实权限为：<strong>777-掩码</strong>。</p>
<p>umask 026<br>//新建的文件或文件夹的权限为777-026 = 751 </p>
</li>
</ul>
<h5 id="Linux文件权限码"><a href="#Linux文件权限码" class="headerlink" title="Linux文件权限码"></a>Linux文件权限码</h5><p>777是怎么计算的？其实是二进制转换成八进制了。</p>
<p>权限</p>
<p>二进制值</p>
<p>八进制值</p>
<p>描述</p>
<p>—</p>
<p>000</p>
<p>0</p>
<p>没有任何权限</p>
<p>–x</p>
<p>001</p>
<p>1</p>
<p>只有执行权限</p>
<p>-w-</p>
<p>010</p>
<p>2</p>
<p>只有写入权限</p>
<p>-wx</p>
<p>011</p>
<p>3</p>
<p>有写入和执行权限</p>
<p>r–</p>
<p>100</p>
<p>4</p>
<p>只有读取权限</p>
<p>r-x</p>
<p>101</p>
<p>5</p>
<p>有读取和执行权限</p>
<p>rw-</p>
<p>110</p>
<p>6</p>
<p>有读取和写入权限</p>
<p>rwx</p>
<p>111</p>
<p>7</p>
<p>有全部权限</p>
<h3 id="7-4-改变安全性设置"><a href="#7-4-改变安全性设置" class="headerlink" title="7.4 改变安全性设置"></a>7.4 改变安全性设置</h3><h4 id="7-4-1-改变权限"><a href="#7-4-1-改变权限" class="headerlink" title="7.4.1 改变权限"></a>7.4.1 改变权限</h4><ul>
<li><p><code>chmod options mode file</code> 改变文件和目录的安全性设置，命令格式如下：</p>
<p>chmod 760 newfile</p>
</li>
</ul>
<ul>
<li><code>chmod [ugoa…][+-=][rwxXstugo…] newfile</code> 第一组字符定义了权限作用的对象：<ul>
<li><code>u</code>代表用户</li>
<li><code>g</code>代表组</li>
<li><code>o</code>代表其他</li>
<li><code>a</code>代表上述所有 后面跟着的符号表示你是想在现有权限基础上增加权限（<code>+</code>），还是在现有权限基础 上移除权限（<code>-</code>），或是将权限设置成后面的值（<code>=</code>）。 最后第三个符号代表作用到设置上的权限，不止rwx。额外的有：</li>
<li><code>X</code>：如果对象是目录或者它已有执行权限，赋予执行权限。</li>
<li><code>s</code>：运行时重新设置UID或GID。</li>
<li><code>t</code>：保留文件或目录。</li>
<li><code>u</code>：将权限设置为跟属主一样。</li>
<li><code>g</code>：将权限设置为跟属组一样。</li>
<li><code>o</code>：将权限设置为跟其他用户一样。</li>
</ul>
</li>
</ul>
<h4 id="7-4-2-改变所属关系"><a href="#7-4-2-改变所属关系" class="headerlink" title="7.4.2 改变所属关系"></a>7.4.2 改变所属关系</h4><ul>
<li><p><code>chown</code> 改变文件的<strong>属主</strong>。</p>
<p>chown dan newfile<br>// newfile文件的拥有者变为dan</p>
</li>
</ul>
<ul>
<li><p><code>chgrp</code> 改变文件的默认<strong>属组</strong>。</p>
<p>chgrp shared newfile<br>//newfile属组为shared </p>
</li>
</ul>
<h3 id="7-5-共享文件"><a href="#7-5-共享文件" class="headerlink" title="7.5 共享文件"></a>7.5 共享文件</h3><p>共享文件的方法是创建组。Linux为每个文件和目录存储了3个额外的信息位：</p>
<ul>
<li><p><strong>设置用户ID（SUID）</strong>：当文件被用户使用时，程序会以文件属主的权限运行。</p>
</li>
<li><p><strong>设置组ID（SGID）</strong>：对文件来说，程序会以文件属组的权限运行；对目录来说，目录中</p>
<p>创建的新文件会以目录的默认属组作为默认属组。</p>
</li>
<li><p><strong>粘着位</strong>：进程结束后文件还驻留（粘着）在内存中。</p>
</li>
</ul>
<h2 id="8-管理文件系统"><a href="#8-管理文件系统" class="headerlink" title="8 管理文件系统"></a>8 管理文件系统</h2><h3 id="8-1-探索Linux文件系统"><a href="#8-1-探索Linux文件系统" class="headerlink" title="8.1 探索Linux文件系统"></a>8.1 探索Linux文件系统</h3><h4 id="8-1-1-基本的Linux文件系统"><a href="#8-1-1-基本的Linux文件系统" class="headerlink" title="8.1.1 基本的Linux文件系统"></a>8.1.1 基本的Linux文件系统</h4><h5 id="1）ext文件系统"><a href="#1）ext文件系统" class="headerlink" title="1）ext文件系统"></a>1）ext文件系统</h5><p>Linux操作系统中引入的最早的文件系统叫作扩展文件系统（extended filesystem，简记为ext）。它为Linux提供了一个基本的类Unix文件系统：使用虚拟目录来操作硬件设备，在物理设备上按定长的块来存储数据。ext文件系统采用名为索引节点的系统来存放虚拟目录中所存储文件的信息。</p>
<h5 id="2）ext2文件系统"><a href="#2）ext2文件系统" class="headerlink" title="2）ext2文件系统"></a>2）ext2文件系统</h5><p>ext2文件系统是ext文件系统基本功能的一个扩展，但保持了同样的结构。ext2文件系统扩展了索引节点表的格式来保存系统上每个文件的更多信息。</p>
<blockquote>
<p>文件系统有点繁杂，暂时可不用了解。</p>
</blockquote>
<h3 id="8-2-操作文件系统"><a href="#8-2-操作文件系统" class="headerlink" title="8.2 操作文件系统"></a>8.2 操作文件系统</h3><h4 id="8-2-1-创建分区"><a href="#8-2-1-创建分区" class="headerlink" title="8.2.1 创建分区"></a>8.2.1 创建分区</h4><ul>
<li><p><code>fdisk</code> 使用fdisk工具来帮助管理安装在系统上的任何存储设备上的分区。</p>
<p>sudo fdisk /dev/vda1</p>
</li>
</ul>
<p>如果你不知道你的磁盘情况，可以用<code>df -h</code>命令查看磁盘情况。比如我的服务器的磁盘情况：</p>
<pre><code>root@ServerA:~# df -h
Filesystem      Size  Used Avail Use% Mounted on
udev            479M     0  479M   0% /dev
tmpfs           100M  2.8M   97M   3% /run
/dev/vda1        40G   12G   27G  30% /
tmpfs           497M     0  497M   0% /dev/shm
tmpfs           5.0M  4.0K  5.0M   1% /run/lock
tmpfs           497M     0  497M   0% /sys/fs/cgroup
tmpfs           100M     0  100M   0% /run/user/0 </code></pre><h4 id="8-2-2-创建文件系统"><a href="#8-2-2-创建文件系统" class="headerlink" title="8.2.2 创建文件系统"></a>8.2.2 创建文件系统</h4><p>有很多创建工具，但是将数据存储到分区之前，你必须用某种文件系统对其进行格式化。</p>
<h5 id="创建文件系统的命令行程序"><a href="#创建文件系统的命令行程序" class="headerlink" title="创建文件系统的命令行程序"></a>创建文件系统的命令行程序</h5><p>工具</p>
<p>用途</p>
<p>mkefs</p>
<p>创建一个ext文件系统</p>
<p>mke2fs</p>
<p>创建一个ext2文件系统</p>
<p>mkfs.ext3</p>
<p>创建一个ext3文件系统</p>
<p>用法和上面的一样，<code>sudo mkefs 盘符</code>。</p>
<h4 id="8-2-3-文件系统的检查与修复"><a href="#8-2-3-文件系统的检查与修复" class="headerlink" title="8.2.3 文件系统的检查与修复"></a>8.2.3 文件系统的检查与修复</h4><p><code>fsck</code>命令能够检查和修复大部分类型的Linux文件系统。命令格式是：</p>
<pre><code>fsck options filesystem </code></pre><h3 id="8-3-逻辑卷管理"><a href="#8-3-逻辑卷管理" class="headerlink" title="8.3 逻辑卷管理"></a>8.3 逻辑卷管理</h3><p>如果用标准分区在硬盘上创建了文件系统，为已有文件系统添加额外的空间多少是一种痛苦的体验。你只能在同一个物理硬盘的可用空间范围内调整分区大小。如果硬盘上没有地方了，你就必须弄一个更大的硬盘，然后手动将已有的文件系统移动到新的硬盘上。</p>
<h4 id="8-3-1-逻辑卷管理布局"><a href="#8-3-1-逻辑卷管理布局" class="headerlink" title="8.3.1 逻辑卷管理布局"></a>8.3.1 逻辑卷管理布局</h4><p>在逻辑卷管理的世界里，硬盘称作<strong>物理卷</strong>（physical volume，PV）。每个物理卷都会映射到硬盘上特定的物理分区。</p>
<p><strong>简单说，逻辑卷就是将卷组视为一个物理硬盘，但是这个卷组可能是由多个物理硬盘上的多个物理分区组成的。</strong></p>
<h5 id="逻辑卷管理环境的基本布局："><a href="#逻辑卷管理环境的基本布局：" class="headerlink" title="逻辑卷管理环境的基本布局："></a>逻辑卷管理环境的基本布局：</h5><p><img src="https://tanwenbo.top/wp-content/uploads/2018/06/b0f00743914b1ceac010dc99bc915370.png" alt=""></p>
<h4 id="8-3-2-Linux中的LVM"><a href="#8-3-2-Linux中的LVM" class="headerlink" title="8.3.2 Linux中的LVM"></a>8.3.2 Linux中的LVM</h4><p>Linux逻辑卷管理器（logical volume manager，LVM）软件包。它可以让你在无需重建整个文件系统的情况下，轻松地管理磁盘空间。</p>
<h5 id="1）快照"><a href="#1）快照" class="headerlink" title="1）快照"></a>1）快照</h5><blockquote>
<p>原来这就是阿里云快照的原理。</p>
</blockquote>
<p>最初的Linux LVM允许你在逻辑卷在线的状态下将其复制到另一个设备。这个功能叫作快照。快照允许你在复制的同时，保证运行关键任务的Web服务器或数据库服务器继续工作。</p>
<blockquote>
<p>快照就是一个备份，然后可以用它来回滚磁盘。</p>
</blockquote>
<h5 id="2）条带化"><a href="#2）条带化" class="headerlink" title="2）条带化"></a>2）条带化</h5><p>条带化有助于提高硬盘的性能，因为Linux可以将一个文件的多个数据块同时写入多个硬盘，而无需等待单个硬盘移动读写磁头到多个不同位置。</p>
<h5 id="3）镜像"><a href="#3）镜像" class="headerlink" title="3）镜像"></a>3）镜像</h5><p>LVM快照功能提供了一些安慰，你可以随时创建逻辑卷的备份副本，但对有些环境来说可能还不够。对于涉及大量数据变动的系统，比如数据库服务器，自上次快照之后可能要存储成百上千条记录。</p>
<p>这个问题的一个解决办法就是<strong>LVM镜像</strong>。镜像是一个实时更新的逻辑卷的完整副本。当你创建镜像逻辑卷时，LVM会将原始逻辑卷同步到镜像副本中。根据原始逻辑卷的大小，这可能需要一些时间才能完成。</p>
<blockquote>
<p>阿里云镜像可以提供给别人，可能是内网的原因。</p>
</blockquote>
<h4 id="8-3-3-使用Linux-LVM"><a href="#8-3-3-使用Linux-LVM" class="headerlink" title="8.3.3 使用Linux LVM"></a>8.3.3 使用Linux LVM</h4><blockquote>
<p>使用的机会很少，暂时不讨论。</p>
</blockquote>
<h2 id="9-安装软件程序"><a href="#9-安装软件程序" class="headerlink" title="9 安装软件程序"></a>9 安装软件程序</h2><h3 id="9-1-包管理基础"><a href="#9-1-包管理基础" class="headerlink" title="9.1 包管理基础"></a>9.1 包管理基础</h3><p>各种主流Linux发行版都采用了某种形式的包管理系统来控制软件和库的安装，<strong>包管理系统</strong>（package management system，PMS）。</p>
<blockquote>
<p>书中给的是<code>Debian</code>和<code>Red Hat</code>，但是自己用的是<code>Ubuntu</code>（不过也是Debian系列的），所以这章就记一下Debian的就好。</p>
</blockquote>
<h3 id="9-2-基于Debian的系统"><a href="#9-2-基于Debian的系统" class="headerlink" title="9.2 基于Debian的系统"></a>9.2 基于Debian的系统</h3><p><code>dpkg</code>命令是基于Debian系PMS工具的核心。包含在这个PMS中的其他工具有：</p>
<ul>
<li>apt-get</li>
<li>apt-cache</li>
<li>aptitude</li>
</ul>
<p>到目前为止，最常用的命令行工具是<strong>aptitude</strong>，这是有原因的。<strong>aptitude</strong>工具本质上是apt工具 和dpkg的前端。dpkg是软件包管理系统工具，而<strong>aptitude</strong>则是完整的软件包管理系统。</p>
<blockquote>
<p>阿里云服务器没有安装aptitude，要自行安装。</p>
</blockquote>
<pre><code>apt install aptitude </code></pre><h4 id="9-2-1-用aptitude管理软件包"><a href="#9-2-1-用aptitude管理软件包" class="headerlink" title="9.2.1 用aptitude管理软件包"></a>9.2.1 用aptitude管理软件包</h4><p>直接输入aptitude进行管理界面。</p>
<p><img src="https://tanwenbo.top/wp-content/uploads/2018/06/9abbc52455df0471a41caea66d9b4a52.png" alt=""></p>
<ul>
<li><p><code>aptitude show 包名</code> 可以显示软件包的情况，比如：</p>
<p>aptitude show mysql-clinet </p>
</li>
</ul>
<h4 id="9-2-2-用aptitude安装软件包"><a href="#9-2-2-用aptitude安装软件包" class="headerlink" title="9.2.2 用aptitude安装软件包"></a>9.2.2 用aptitude安装软件包</h4><p>先查找：</p>
<ul>
<li><code>aptitude search 包名</code> 支持通配符，就是会显示所有包含该包名的软件包。</li>
<li><code>aptitude install 包名</code> <strong>可以自动解析必要的包依赖关系，并安装了需要的额外的库和软件包。</strong></li>
</ul>
<h4 id="9-2-3-用aptitude更新软件"><a href="#9-2-3-用aptitude更新软件" class="headerlink" title="9.2.3 用aptitude更新软件"></a>9.2.3 用aptitude更新软件</h4><ul>
<li><code>aptitude safe-upgrade</code> 将所有已安装的包更新到软件仓库中的最新版本，有利于系统稳定。</li>
</ul>
<blockquote>
<p>这个命令牛笔啊，比Windows里一个个更新好多了。apt-get也有。注意<code>apt-get update</code>是<strong>更新可用包的列表，而不是更新包。</strong></p>
</blockquote>
<ul>
<li><p><code>aptitude full-upgrade</code></p>
</li>
<li><p><code>aptitude dist-upgrade</code> 这些选项执行相同的任务，将所有软件包升级到最新版本，不会检查包与包之间的依赖关系。建议使用<code>safe-upgrade</code>。</p>
</li>
</ul>
<h4 id="9-2-4-用aptitude卸载软件"><a href="#9-2-4-用aptitude卸载软件" class="headerlink" title="9.2.4 用aptitude卸载软件"></a>9.2.4 用aptitude卸载软件</h4><p>和apt-get一样，用purge。</p>
<ul>
<li><code>sudo aptitude purge wine</code> 删除软件包和相关的数据和配置文件。</li>
<li><code>sudo aptitude remove wine</code> 只删除软件包而不删除数据和配置文件。</li>
</ul>
<h4 id="9-3-apt-get和aptitude的区别"><a href="#9-3-apt-get和aptitude的区别" class="headerlink" title="9.3 apt-get和aptitude的区别"></a>9.3 apt-get和aptitude的区别</h4><blockquote>
<p>这一节自己加的，需要理解二者的区别。因为之前一直用的apt-get，aptitude反而用的较少。</p>
</blockquote>
<ol>
<li><p>有的问题apt-get解决不了，必须aptitude解决。有的问题aptitude解决不了，必须apt-get解决。</p>
</li>
<li><p>aptitude解决更好的地方：install, remove, reinstall（apt-get无此功能）, show（apt-get无此功能）, search（apt-get无此功能）, hold（apt-get无此功能）, unhold（apt-get无此功能）</p>
</li>
<li><p>apt-get解决更好的地方：source（aptitude无此功能）, build-dep （低版本的aptitude没有build-dep功能）</p>
</li>
<li><p>apt-get 跟 aptitude 没什么区别的地方：update, upgrade (apt-get upgrade=aptitude safe-upgrade, apt-get dist-upgrade=aptitude full-upgrgade)</p>
</li>
</ol>
<h2 id="10-使用编辑器"><a href="#10-使用编辑器" class="headerlink" title="10 使用编辑器"></a>10 使用编辑器</h2><blockquote>
<p>就是Linux里的IDE，熟悉了之后很强大！</p>
</blockquote>
<h3 id="10-1-vim编辑器"><a href="#10-1-vim编辑器" class="headerlink" title="10.1 vim编辑器"></a>10.1 vim编辑器</h3><p>基于vi的升级版，它使用控制台图形模式来模拟文本编辑窗口，允许查看文件中的行、在文件中移动、插入、编辑和替换文本。</p>
<h4 id="10-1-1-检查vim软件包"><a href="#10-1-1-检查vim软件包" class="headerlink" title="10.1.1 检查vim软件包"></a>10.1.1 检查vim软件包</h4><p>安装就不说了，vim包Ubuntu里已经安装好了。没有安装的话可以使用以下命令：</p>
<pre><code>sudo apt-get install vim </code></pre><h4 id="10-1-2-vim基础"><a href="#10-1-2-vim基础" class="headerlink" title="10.1.2 vim基础"></a>10.1.2 vim基础</h4><blockquote>
<p>主要是掌握一下命令模式下各种命令，之前用的差不多了，熟悉一下就好。</p>
</blockquote>
<p>以下都是基于普通模式下，按<code>esc</code>进入普通模式 移动光标：</p>
<ul>
<li><code>h</code>：左移一个字符。</li>
<li><code>j</code>：下移一行（文本中的下一行）。</li>
<li><code>k</code>：上移一行（文本中的上一行）。</li>
<li><code>l</code>：右移一个字符。</li>
</ul>
<p>高速移动：</p>
<ul>
<li><code>PageDown</code>（或Ctrl+F）：下翻一屏。</li>
<li><code>PageUp</code>（或Ctrl+B）：上翻一屏。</li>
<li><code>G</code>：移到缓冲区的最后一行。</li>
<li><code>num G</code>：移动到缓冲区中的第num行。</li>
<li><code>gg</code>：移到缓冲区的第一行。</li>
</ul>
<p>保存退出（<strong>需要按冒号<code>:</code></strong>）：</p>
<ul>
<li><code>q</code>：如果未修改缓冲区数据，退出。</li>
<li><code>q!</code>：取消所有对缓冲区数据的修改并退出。</li>
<li><code>w filename</code>：将文件保存到另一个文件中。</li>
<li><code>wq</code>：将缓冲区数据保存到文件中并退出。</li>
</ul>
<blockquote>
<p>一般wq命令用的多。</p>
</blockquote>
<h4 id="10-1-3-编辑数据"><a href="#10-1-3-编辑数据" class="headerlink" title="10.1.3 编辑数据"></a>10.1.3 编辑数据</h4><p>在普通模式下（注意区分大小写）：</p>
<ul>
<li><code>x</code> 删除当前光标所在位置的字符</li>
<li><code>dd</code> 删除当前光标所在行（<strong>剪切</strong>）</li>
<li><code>5dd</code> 删除当前光标所在<code>下面5行</code></li>
<li><code>dw</code> 删除当前光标所在位置的单词</li>
<li><code>d$</code> 删除当前光标所在位置至行尾的内容</li>
<li><code>J</code>删除当前光标所在行行尾的换行符（拼接行）</li>
<li><code>u</code> 撤销前一编辑命令</li>
<li><code>a</code> 在当前光标后追加数据</li>
<li><code>A</code> 在当前光标所在行行尾追加数据</li>
<li><code>r char</code> 用char替换当前光标所在位置的单个字符</li>
<li><code>R text</code> 用text覆盖当前光标所在位置的数据，直到按下ESC键</li>
</ul>
<h4 id="10-1-4-复制和粘贴"><a href="#10-1-4-复制和粘贴" class="headerlink" title="10.1.4 复制和粘贴"></a>10.1.4 复制和粘贴</h4><p>不同于dd，复制的命令是<code>yy</code>（代表yank）。</p>
<ul>
<li><code>yy</code> 复制光标所在行</li>
<li><code>5yy</code> 复制光标所在行下面5行</li>
<li><code>yw</code> 复制一个单词</li>
<li><code>y$</code> 复制到行尾</li>
<li><code>p</code> 粘贴赋值的内容</li>
</ul>
<h4 id="10-1-5-查找和替换"><a href="#10-1-5-查找和替换" class="headerlink" title="10.1.5 查找和替换"></a>10.1.5 查找和替换</h4><h5 id="1）-查找"><a href="#1）-查找" class="headerlink" title="1） 查找"></a>1） 查找</h5><p>在普通模式下按<code>:</code>进入命令模式，<code>/内容</code> 查找。光标会移动到相同的地方，按<code>n</code>查找下一处。</p>
<h5 id="1）替换"><a href="#1）替换" class="headerlink" title="1）替换"></a>1）替换</h5><blockquote>
<p>这个命令学习了，以前都是手动替换尴尬。</p>
</blockquote>
<p>替换命令允许你快速用另一个单词来替换文本中的某个单词。必须进入命令行模式才能使用 替换命令。替换命令的格式是：<code>:s/old/new/</code></p>
<ul>
<li><code>:s/old/new/g</code> 一行命令替换所有old（只会替换光标所在行）。</li>
<li><code>:n,ms/old/new/g</code> 替换行号n和m之间所有old。</li>
<li><code>:%s/old/new/g</code> 替换整个文件中的所有old。</li>
<li><code>:%s/old/new/gc</code> 替换整个文件中的所有old，但在每次出现时提示。</li>
</ul>
<blockquote>
<p>其他的编辑器就不介绍了。</p>
</blockquote>
<h2 id="11-构建基本脚本"><a href="#11-构建基本脚本" class="headerlink" title="11 构建基本脚本"></a>11 构建基本脚本</h2><h3 id="11-1-使用多个命令"><a href="#11-1-使用多个命令" class="headerlink" title="11.1 使用多个命令"></a>11.1 使用多个命令</h3><p>前面有提到，加个分号可以同时处理多个命令，多次进行。</p>
<pre><code>date; who</code></pre><p>可以将这些命令组合成一个简单的文本文件，这样就不需要在命令行中手动输入了。</p>
<h3 id="11-2-创建shell脚本文件"><a href="#11-2-创建shell脚本文件" class="headerlink" title="11.2 创建shell脚本文件"></a>11.2 创建shell脚本文件</h3><p>要创建脚本需要新建一个文件，然后将命令输入到文件中。 在创建shell脚本文件时，必须在文件的第一行指定要使用的shell。其格式为：</p>
<pre><code>#!/bin/bash</code></pre><p>然后在后面添加命令即可。</p>
<pre><code>#!/bin/bash
# This script displays the date and who&apos;s logged on
date
who
#可以直接换行也可以用分号。</code></pre><blockquote>
<p>hell不会解释以#开头的行（除了以#!开头的第一行）。</p>
</blockquote>
<p>直接在命令行输入文件名就可以运行脚本，但是要注意：</p>
<ul>
<li><p>脚本目录要在PATH环境变量中；</p>
<ul>
<li>或在提示符中用绝对或相对文件路径来引用shell脚本文件；</li>
</ul>
</li>
<li><p>解决权限问题，要给当前用户所属文件加入<code>x</code>（执行）权限。</p>
</li>
</ul>
<h4 id="11-2-1-编写自己的脚本"><a href="#11-2-1-编写自己的脚本" class="headerlink" title="11.2.1 编写自己的脚本"></a>11.2.1 编写自己的脚本</h4><blockquote>
<p>比如我经常需要重启apache2，有时候命令行记不住，总是要去百度或者用上下键翻来翻去。那么可以编写脚本解决这个问题！</p>
</blockquote>
<h5 id="1）建一个文件夹存放脚本"><a href="#1）建一个文件夹存放脚本" class="headerlink" title="1）建一个文件夹存放脚本"></a>1）建一个文件夹存放脚本</h5><p>root@ServerA:~# mkdir script </p>
<h5 id="2）将该文件添加到PATH里（2和7选一个）"><a href="#2）将该文件添加到PATH里（2和7选一个）" class="headerlink" title="2）将该文件添加到PATH里（2和7选一个）"></a>2）将该文件添加到PATH里（2和7选一个）</h5><p>root@ServerA:~# PATH=$PATH:/root/script </p>
<h5 id="3）新建文件"><a href="#3）新建文件" class="headerlink" title="3）新建文件"></a>3）新建文件</h5><p>root@ServerA:<del># cd script<br>    root@ServerA:</del>/script# vim apR </p>
<h5 id="4）将命令写入文件并保存"><a href="#4）将命令写入文件并保存" class="headerlink" title="4）将命令写入文件并保存"></a>4）将命令写入文件并保存</h5><p> 1 #!/bin/bash<br>     2 # This script can restart the apache2 server<br>     3 sudo /etc/init.d/apache2 restart </p>
<h5 id="5）更改权限"><a href="#5）更改权限" class="headerlink" title="5）更改权限"></a>5）更改权限</h5><p>root@ServerA:~/script# chmod u+x apR</p>
<p>也可以更改这个文件夹的权限</p>
<pre><code>root@ServerA:~/script# chmod -R 755 /root/script
//—R 递归更改权限 </code></pre><h5 id="6）运行脚本"><a href="#6）运行脚本" class="headerlink" title="6）运行脚本"></a>6）运行脚本</h5><pre><code>root@ServerA:~/script# ./apR
[ ok ] Restarting apache2 (via systemctl): apache2.service.</code></pre><blockquote>
<p>但是有个弊端，只能在script目录下运行脚本，那么需要解决这个问题</p>
</blockquote>
<h5 id="7）将脚本目录加入到环境变量"><a href="#7）将脚本目录加入到环境变量" class="headerlink" title="7）将脚本目录加入到环境变量"></a>7）将脚本目录加入到环境变量</h5><p>root@ServerA:~# vim $HOME/.bashrc</p>
<p>放在 /etc/profile随着系统更新会失效，6.6节有提到。 在里面加入：</p>
<pre><code>export PATH=&quot;$PATH&quot;:/root/script/</code></pre><p><strong>保存，重启系统才能生效。</strong>或者 <code>source</code></p>
<pre><code>root@ServerA:~# reboot
root@ServerA:~# source /etc/profile </code></pre><h5 id="8）在任意界面运行脚本"><a href="#8）在任意界面运行脚本" class="headerlink" title="8）在任意界面运行脚本"></a>8）在任意界面运行脚本</h5><pre><code>root@ServerA:~# apR
[ ok ] Restarting apache2 (via systemctl): apache2.service.</code></pre><p>还不用加<code>./</code>就能运行，很是方便。</p>
<blockquote>
<p>注意如果脚本里写了cd，那么脚本运行的时候会创建一个子shell然后子shell里cd到了目录。运行的时候加个<code>.</code> 即可在当前shell生效。</p>
</blockquote>
<h3 id="11-3-显示消息"><a href="#11-3-显示消息" class="headerlink" title="11.3 显示消息"></a>11.3 显示消息</h3><p>在脚本里用<code>echo</code>显示消息。</p>
<pre><code>echo hello i am a shell</code></pre><p>但是要注意单词不要有单引号（比如 <strong>Let`s</strong>），如果有的话就将整个句子用双引号括起来。</p>
<p>这个命令可以让echo接着命令输出，而不是另起一行。</p>
<pre><code>echo -n haha </code></pre><h3 id="11-4-使用变量"><a href="#11-4-使用变量" class="headerlink" title="11.4 使用变量"></a>11.4 使用变量</h3><blockquote>
<p>shell也是一种编程，也可以使用变量</p>
</blockquote>
<h4 id="11-4-1-使用环境变量"><a href="#11-4-1-使用环境变量" class="headerlink" title="11.4.1 使用环境变量"></a>11.4.1 使用环境变量</h4><p>在脚本中，你可以在环境变量名称之前加上美元符（<code>$</code>）来使用这些环境变量。</p>
<pre><code>#!/bin/bash
# display user information from the system.
echo &quot;User info for userid: $USER&quot;
echo UID: $UID
echo HOME: $HOME</code></pre><p>如果你要用到美元符（<code>$</code>）那么要在前面加上转义字符反斜线<code>\</code>。</p>
<h4 id="11-4-2-用户变量"><a href="#11-4-2-用户变量" class="headerlink" title="11.4.2 用户变量"></a>11.4.2 用户变量</h4><p>除了环境变量，shell脚本还允许在脚本中定义和使用自己的变量。定义变量允许临时存储数据并在整个脚本中使用，从而使shell脚本看起来更像一个真正的计算机程序。<strong>区分大小写</strong></p>
<p>用户变量也可以通过美元符引用。要注意赋值的时候<strong>左值没有美元符，右值需要有美元符。</strong></p>
<pre><code>$ cat test4
#!/bin/bash
# assigning a variable value to another variable
value1=10
value2=$value1
echo The resulting value is $value2
$ </code></pre><h4 id="11-4-3-命令替换"><a href="#11-4-3-命令替换" class="headerlink" title="11.4.3 命令替换"></a>11.4.3 命令替换</h4><p><strong>shell脚本中最有用的特性之一就是可以从命令输出中提取信息，并将其赋给变量。</strong></p>
<p>两种方法可以将命令输出赋给变量：</p>
<ul>
<li>反引号字符（<code>`</code>）</li>
<li><code>$( )</code>格式</li>
</ul>
<p>shell会运行命令替换符号中的命令，并将其输出赋给变量testing。注意，赋值等号和命令 替换字符之间没有空格。这里有个使用普通的shell命令输出创建变量的例子。</p>
<pre><code>$ cat test5
#!/bin/bash
testing=$(date)
echo &quot;The date and time are: &quot; $testing
$</code></pre><p>这个功能很强大，值得学习！</p>
<h3 id="11-5-重定向输入和输出"><a href="#11-5-重定向输入和输出" class="headerlink" title="11.5 重定向输入和输出"></a>11.5 重定向输入和输出</h3><p>有些时候你想要保存某个命令的输出而不仅仅只是让它显示在显示器上。</p>
<h4 id="11-5-1-输出重定向"><a href="#11-5-1-输出重定向" class="headerlink" title="11.5.1 输出重定向"></a>11.5.1 输出重定向</h4><p>最基本的重定向将命令的输出发送到一个文件中。bash shell用大于号（<code>&gt;</code>）来完成这项功能：</p>
<pre><code>command &gt; outputfile</code></pre><p>要注意，如果输出重定向到同一个文件名，那么<code>&gt;</code>会覆盖原来的内容，而<code>&gt;&gt;</code>会在原来的基础上追加。</p>
<h4 id="11-5-2-输入重定向"><a href="#11-5-2-输入重定向" class="headerlink" title="11.5.2 输入重定向"></a>11.5.2 输入重定向</h4><p>输入重定向和输出重定向正好相反。<strong>输入重定向将文件的内容重定向到命令</strong>，而非将命令的输出重定向到文件。 输入重定向符号是小于号（<code>&lt;</code>）：</p>
<pre><code>command &lt; inputfile</code></pre><blockquote>
<p>一个简单的记忆方法就是：在命令行上，命令总是在左侧，而重定向符号“指向”数据流动的方向。小于号说明数据正在从输入文件流向命令。</p>
</blockquote>
<h5 id="内联输入重定向符号"><a href="#内联输入重定向符号" class="headerlink" title="内联输入重定向符号"></a>内联输入重定向符号</h5><p>使用<code>&lt;&lt;</code>,必须指定文本标记来划分输入数据的开始和结尾。任何字符串都可以作为文本标记，但在数据的开始和结尾文本标记必须一直。</p>
<pre><code>$ wc &lt;&lt; EOF
&gt; test string 1
&gt; test string 2
&gt; test string 3
&gt; EOF </code></pre><h3 id="11-6-管道"><a href="#11-6-管道" class="headerlink" title="11.6 管道"></a>11.6 管道</h3><p>将一个命令的输出作为另一个命令的输入，这时候可以用到管道来处理。管道被放在命令之间，将一个命令的输出重定向到另一个命令中：</p>
<pre><code>command1 | command2</code></pre><p>这两个命令会同时运行，而不是依次进行。会在系统内部将它们连接起来，在第一个命令产生输出的同时，输出会被立即送给第二个命令。数据传输不会用到任何中间文件或缓冲区。</p>
<p>也可以将输出结果重定向到文件</p>
<pre><code>$ rpm -qa | sort &gt; rpm.list
$ more rpm.list
abrt-1.1.14-1.fc14.i686
abrt-addon-ccpp-1.1.14-1.fc14.i686
abrt-addon-kerneloops-1.1.14-1.fc14.i686
..... </code></pre><h3 id="11-7-执行数学运算"><a href="#11-7-执行数学运算" class="headerlink" title="11.7 执行数学运算"></a>11.7 执行数学运算</h3><h4 id="11-7-1-expr命令"><a href="#11-7-1-expr命令" class="headerlink" title="11.7.1 expr命令"></a>11.7.1 expr命令</h4><p>处理表达式，也可以用来判断。</p>
<p>操 作 符</p>
<p>描 述</p>
<p>ARG1 | ARG2</p>
<p>如果ARG1既不是null也不是零值，返回ARG1；否则返回ARG2</p>
<p>ARG1 &amp; ARG2</p>
<p>如果没有参数是null或零值，返回ARG1；否则返回0</p>
<p>ARG1 &lt; ARG2</p>
<p>如果ARG1小于ARG2，返回1；否则返回0</p>
<p>ARG1 &lt;= ARG2</p>
<p>如果ARG1小于或等于ARG2，返回1；否则返回0</p>
<p>ARG1 = ARG2</p>
<p>如果ARG1等于ARG2，返回1；否则返回0</p>
<p>ARG1 != ARG2</p>
<p>如果ARG1不等于ARG2，返回1；否则返回0</p>
<p>ARG1 &gt;= ARG2</p>
<p>如果ARG1大于或等于ARG2，返回1；否则返回0</p>
<p>ARG1 &gt; ARG2</p>
<p>如果ARG1大于ARG2，返回1；否则返回0</p>
<p>ARG1 + ARG2</p>
<p>返回ARG1和ARG2的算术运算和</p>
<p>ARG1 - ARG2</p>
<p>返回ARG1和ARG2的算术运算差</p>
<p>ARG1 * ARG2</p>
<p>返回ARG1和ARG2的算术乘积</p>
<p>ARG1 / ARG2</p>
<p>返回ARG1被ARG2除的算术商</p>
<p>ARG1 % ARG2</p>
<p>返回ARG1被ARG2除的算术余数</p>
<p>STRING : REGEXP</p>
<p>如果REGEXP匹配到了STRING中的某个模式，返回该模式匹配</p>
<p>match STRING REGEXP</p>
<p>如果REGEXP匹配到了STRING中的某个模式，返回该模式匹配</p>
<p>substr STRING POS LENGTH</p>
<p>返回起始位置为POS（从1开始计数）、长度为LENGTH个字符的子字符串</p>
<p>index STRING CHARS</p>
<p>返回在STRING中找到CHARS字符串的位置；否则，返回0</p>
<p>length STRING</p>
<p>返回字符串STRING的数值长度</p>
<p>TOKEN</p>
<p>将TOKEN解释成字符串，即使是个关键字</p>
<p>(EXPRESSION)</p>
<p>返回EXPRESSION的值</p>
<h4 id="11-7-2-使用方括号"><a href="#11-7-2-使用方括号" class="headerlink" title="11.7.2 使用方括号"></a>11.7.2 使用方括号</h4><p>在bash中，在将一个数学运算结果赋给某个变量时，可以用美元符和方括号（$[ operation ]）将数学表达式围起来。</p>
<pre><code>$ var1=$[1 + 5]
$ echo $var1
6
$ var2=$[$var1 * 2]
$ echo $var2
12
$ </code></pre><h4 id="11-7-3-浮点解决方案"><a href="#11-7-3-浮点解决方案" class="headerlink" title="11.7.3 浮点解决方案"></a>11.7.3 浮点解决方案</h4><p>使用内建的bash计算器，叫做<code>bc</code>，可以用来计算浮点数。 bash计算器能够识别：</p>
<ul>
<li>数字（整数和浮点数）</li>
<li>变量（简单变量和数组）</li>
<li>注释（以#或C语言中的/* */开始的行）</li>
<li>表达式</li>
<li>编程语句（例如if-then语句）</li>
<li>函数</li>
</ul>
<h5 id="在脚本里使用bc"><a href="#在脚本里使用bc" class="headerlink" title="在脚本里使用bc"></a>在脚本里使用bc</h5><p>可以用命令替换运行bc命令，并将输出赋给一个变量。基本格式如下：</p>
<pre><code>variable=$(echo &quot;options; expression&quot; | bc)</code></pre><p>第一部分options允许你设置变量。如果你需要不止一个变量，可以用分号将其分开。expression参数定义了通过bc执行的数学表达式。这里有个在脚本中这么做的例子。</p>
<pre><code>$ cat test9
#!/bin/bash
var1=$(echo &quot;scale=4; 3.44 / 5&quot; | bc)
echo The answer is $var1
$</code></pre><p>这个<code>scale</code>是指定小数后几位。</p>
<h5 id="使用内联输入重定向解决多个表达式的麻烦"><a href="#使用内联输入重定向解决多个表达式的麻烦" class="headerlink" title="使用内联输入重定向解决多个表达式的麻烦"></a>使用内联输入重定向解决多个表达式的麻烦</h5><p>它允许你直接在命令行中重定向数据。在shell脚本中，你可以将输出赋给一个变量。</p>
<pre><code>$ cat test12
#!/bin/bash
var1=10.46
var2=43.67
var3=33.2
var4=71
var5=$(bc &lt;&lt; EOF
scale = 4
a1 = ( $var1 * $var2)
b1 = ($var3 * $var4)
a1 + b1
EOF
) </code></pre><h3 id="11-8-退出脚本"><a href="#11-8-退出脚本" class="headerlink" title="11.8 退出脚本"></a>11.8 退出脚本</h3><blockquote>
<p>和c语言的return 0一样，shell也有状态返回码</p>
</blockquote>
<p>一个成功结束的命令的退出状态码是0。如果一个命令结束时有错误，退出状态码就是一个正数值。</p>
<pre><code>$ asdfg
-bash: asdfg: command not found
$ echo $?
127
$ </code></pre><h4 id="11-8-1-查看退出状态码"><a href="#11-8-1-查看退出状态码" class="headerlink" title="11.8.1 查看退出状态码"></a>11.8.1 查看退出状态码</h4><p>状 态 码</p>
<p>描 述</p>
<p>0</p>
<p>命令成功结束</p>
<p>1</p>
<p>一般性未知错误</p>
<p>2</p>
<p>不适合的shell命令</p>
<p>126</p>
<p>命令不可执行</p>
<p>127</p>
<p>没找到命令</p>
<p>128</p>
<p>无效的退出参数</p>
<p>128+x</p>
<p>与Linux信号x相关的严重错误</p>
<p>130</p>
<p>通过Ctrl+C终止的命令</p>
<p>255</p>
<p>正常范围之外的退出状态码</p>
<h4 id="11-8-2-exit退出码"><a href="#11-8-2-exit退出码" class="headerlink" title="11.8.2 exit退出码"></a>11.8.2 exit退出码</h4><p>可以定义自己的退出码，在脚本最后一行加入：</p>
<pre><code>exit 5
#或者你自己想要的数字，最大255 </code></pre><h2 id="12-使用结构化命令"><a href="#12-使用结构化命令" class="headerlink" title="12 使用结构化命令"></a>12 使用结构化命令</h2><p>结构化命令，根据条件使脚本跳过某些命令。</p>
<h3 id="12-1-使用if-then语句"><a href="#12-1-使用if-then语句" class="headerlink" title="12.1 使用if-then语句"></a>12.1 使用if-then语句</h3><blockquote>
<p>和之前的if-else有点区别，要转换过来</p>
</blockquote>
<p>if-then语句有如下格式：</p>
<pre><code>if command
then
    commands
fi</code></pre><p>bash shell的if语句会运行<code>if</code>后面的那个命令。如果该命令的<code>退出状态码</code>（参见第11章）是<code>0</code> （该命令成功运行），位于<code>then</code>部分的命令就会被执行。</p>
<p>如果命令是错的，返回的不是0，但是界面还是会显示命令出错的信息。</p>
<p>then后面的<code>commands</code>说明可以放多条语句，主要是fi的位置。</p>
<h3 id="12-2-if-then-else语句"><a href="#12-2-if-then-else语句" class="headerlink" title="12.2 if-then-else语句"></a>12.2 if-then-else语句</h3><blockquote>
<p>我还以为没有else语句，不过要注意都没有分号。</p>
</blockquote>
<p>if-then-else语句在语句中提供了另外一组命令。</p>
<pre><code>if command
then
    commands
else
    commands
fi</code></pre><p>当if语句中的命令返回退出状态码<code>0</code>时，<code>then</code>部分中的命令会被执行，这跟普通的if-then语句一样。当<code>if</code>语句中的命令返回<code>非零</code>退出状态码时，bash shell会执行<code>else</code>部分中的命令。</p>
<h3 id="12-3-嵌套if"><a href="#12-3-嵌套if" class="headerlink" title="12.3 嵌套if"></a>12.3 嵌套if</h3><p>多重条件判断，类似于<code>else if</code>，在脚本里用<code>elif</code>代替。</p>
<pre><code>if command1
then
    commands
elif command2
then
    more commands
else
    commands
fi</code></pre><blockquote>
<p>记住，在elif语句中，紧跟其后的<code>else</code>语句属于<code>elif</code>代码块。它们并不属于之前的<code>if-then</code>代码块。</p>
</blockquote>
<h3 id="12-4-test命令"><a href="#12-4-test命令" class="headerlink" title="12.4 test命令"></a>12.4 test命令</h3><p>本来if只能测试命令状态码，现在可以使用<code>test</code>测试状态码之外的条件，比如变量名之类的。</p>
<pre><code>if test condition
then
    commands
fi</code></pre><p>bash shell提供了另一种条件测试方法，无需在if-then语句中声明test命令。</p>
<pre><code>if [ condition ]
then
    commands
fi</code></pre><blockquote>
<p>要注意，第一个方括号之后和第二个方括号之前必须加上一个空格。</p>
</blockquote>
<p>test命令可以判断三类条件：</p>
<ul>
<li>数值比较</li>
<li>字符串比较</li>
<li>文件比较</li>
</ul>
<p>具体比较不再介绍，可看书240页。</p>
<h3 id="12-5-复合条件测试"><a href="#12-5-复合条件测试" class="headerlink" title="12.5 复合条件测试"></a>12.5 复合条件测试</h3><p>if-then语句允许你使用布尔逻辑来组合测试。有两种布尔运算符可用：</p>
<ul>
<li><strong>[ condition1 ] &amp;&amp; [ condition2 ]</strong></li>
<li><strong>[ condition1 ] || [ condition2 ]</strong></li>
</ul>
<h3 id="12-6-if-then的高级特性"><a href="#12-6-if-then的高级特性" class="headerlink" title="12.6 if-then的高级特性"></a>12.6 if-then的高级特性</h3><p>bash shell提供了亮相可在if-then语句中使用的高级特性：</p>
<ul>
<li>用于数学表达式的双括号</li>
<li>用于高级字符串处理功能的双方括号</li>
</ul>
<h4 id="12-6-1-双括号"><a href="#12-6-1-双括号" class="headerlink" title="12.6.1 双括号"></a>12.6.1 双括号</h4><p>主要是用来计算数学表达式，如val++、++val和<strong>（幂运算）。双括号命令的格式如下： **(( expression ))</strong></p>
<pre><code>$ cat test23.sh
#!/bin/bash
# using double parenthesis
#
val1=10
#
if (( $val1 ** 2 &gt; 90 ))
then
    (( val2 = $val1 ** 2 ))
    echo &quot;The square of $val1 is $val2&quot;
fi
$
$ ./test23.sh
The square of 10 is 100
$</code></pre><p>可以用在if里，也可以用在普通命令里。注意：在这里不用像之前的中括号一样需要转义。</p>
<h4 id="12-6-2-使用方括号"><a href="#12-6-2-使用方括号" class="headerlink" title="12.6.2 使用方括号"></a>12.6.2 使用方括号</h4><p>双方括号命令提供了针对字符串比较的高级特性。双方括号命令的格式如下： <strong>[[ expression ]]</strong></p>
<p>可以比较或者判断，最重要的是可以模式匹配，如通配符<code>*</code>。</p>
<h3 id="12-7-case命令"><a href="#12-7-case命令" class="headerlink" title="12.7 case命令"></a>12.7 case命令</h3><p>和之前的编程一样，case检查一个变量多个值的情况。</p>
<pre><code>case variable in
pattern1 | pattern2) commands1;;
pattern3) commands2;;
*) default commands;;
esac</code></pre><p>注意那个<code>|</code>就是或标志，pattern1和pattern2都对应commands1。 <code>*</code>类似default。</p>
<h2 id="13-更多结构化命令"><a href="#13-更多结构化命令" class="headerlink" title="13 更多结构化命令"></a>13 更多结构化命令</h2><h3 id="13-1-for命令"><a href="#13-1-for命令" class="headerlink" title="13.1 for命令"></a>13.1 for命令</h3><p>bash shell提供了for命令，允许你创建一个遍历一系列值的循环。每次迭代都使用其中一个 值来执行已定义好的一组命令。下面是bash shell中for命令的基本格式。</p>
<pre><code>for var in list
do
    commands
done</code></pre><blockquote>
<p>有点像某个古老的语言</p>
</blockquote>
<p>这个list 是自己定义的，就是数组。</p>
<h4 id="13-1-1-读取列表中的值"><a href="#13-1-1-读取列表中的值" class="headerlink" title="13.1.1 读取列表中的值"></a>13.1.1 读取列表中的值</h4><pre><code>$ cat test1
#!/bin/bash
# basic for command
for test in Alabama Alaska Arizona Arkansas California Colorado
do
    echo The next state is $test
done</code></pre><p>可以看到in 后面一堆的值。循环完后test的值为列表中最后一个值。</p>
<h4 id="13-1-2-读取列表中的复杂值"><a href="#13-1-2-读取列表中的复杂值" class="headerlink" title="13.1.2 读取列表中的复杂值"></a>13.1.2 读取列表中的复杂值</h4><p>比如有单引号<code>`</code>，和之前第一样，用转义字符或者双引号括起来，有空格的也用双引号。</p>
<h4 id="13-1-3-从变量读取列表"><a href="#13-1-3-从变量读取列表" class="headerlink" title="13.1.3 从变量读取列表"></a>13.1.3 从变量读取列表</h4><p>就像数组一样，但是不用定义长度好像。</p>
<pre><code>$ cat test4
#!/bin/bash
# using a variable to hold the list
list=&quot;Alabama Alaska Arizona Arkansas Colorado&quot;
list=$list&quot; Connecticut&quot;
for state in $list
do
    echo &quot;Have you ever visited $state?&quot;
done
$ ./test4
Have you ever visited Alabama?</code></pre><p><code>list=$list&quot; Connecticut&quot;</code>，拼接一个值。 但是我想，如果list只是一个字符串呢？还有如果变量里有空格怎么处理。</p>
<h4 id="13-1-4-从命令读取值"><a href="#13-1-4-从命令读取值" class="headerlink" title="13.1.4 从命令读取值"></a>13.1.4 从命令读取值</h4><pre><code>$ cat test5
#!/bin/bash
# reading values from a file
file=&quot;states&quot;
for state in $(cat $file)
do
    echo &quot;Visit beautiful $state&quot;
done</code></pre><p>注意美元符号，引用都要加美元符号。</p>
<h4 id="13-1-5-更改字符分隔符"><a href="#13-1-5-更改字符分隔符" class="headerlink" title="13.1.5 更改字符分隔符"></a>13.1.5 更改字符分隔符</h4><p>默认情况下，bash shell会将下列字符当作字段分隔符：</p>
<ul>
<li>空格</li>
<li>制表符</li>
<li>换行符</li>
</ul>
<p>使用IFS环境变量的值来忽略某些值。比如</p>
<pre><code>IFS=$&apos;\n&apos;</code></pre><p>那么shell会忽略空格和制表符，只识别换行符，这个时候就可以使用有<code>空格</code>的变量了。</p>
<p>如果要指定多个IFS字符，只要将它们在赋值行串起来就行。</p>
<pre><code>IFS=$&apos;\n&apos;:;&quot;</code></pre><p>这个赋值会将换行符、冒号、分号和双引号作为字段分隔符。如何使用IFS字符解析数据没 有任何限制。</p>
<h4 id="13-1-6-用通配符读取目录"><a href="#13-1-6-用通配符读取目录" class="headerlink" title="13.1.6 用通配符读取目录"></a>13.1.6 用通配符读取目录</h4><p>遍历的时候可以使用通配符，进行此操作时，必须在文件名或路径名中使用通配符。</p>
<pre><code>$ cat test6
#!/bin/bash
for file in /home/rich/test/*
do
if [ -d &quot;$file&quot; ]
then
    echo &quot;$file is a directory&quot;
elif [ -f &quot;$file&quot; ]
then
    echo &quot;$file is a file&quot;
fi
done
$ ./test6 </code></pre><h3 id="13-2-C语言风格的for命令"><a href="#13-2-C语言风格的for命令" class="headerlink" title="13.2 C语言风格的for命令"></a>13.2 C语言风格的for命令</h3><blockquote>
<p>一开始看到还很惊奇啊，我说如果要处理循环该怎么弄，不知道支不支持for val in 1..n，类似于sql存储过程的语法。</p>
</blockquote>
<h4 id="13-2-1-C语言的for命令"><a href="#13-2-1-C语言的for命令" class="headerlink" title="13.2.1 C语言的for命令"></a>13.2.1 C语言的for命令</h4><p>以下是bash中C语言风格的for循环的基本格式。 <strong>for (( variable assignment ; condition ; iteration process ))</strong> 其实就是多了个括号。</p>
<h4 id="13-2-2-使用多个变量"><a href="#13-2-2-使用多个变量" class="headerlink" title="13.2.2 使用多个变量"></a>13.2.2 使用多个变量</h4><p>和C语言一样，用逗号隔开变量。</p>
<pre><code>for (( a=1, b=10; a &lt;= 10; a++, b-- ))
do
    echo &quot;$a - $b&quot;
done </code></pre><h3 id="13-3-while命令"><a href="#13-3-while命令" class="headerlink" title="13.3 while命令"></a>13.3 while命令</h3><blockquote>
<p>好像shell里没有break语句啊。（有。。。）</p>
</blockquote>
<h4 id="13-3-1-while的基本格式"><a href="#13-3-1-while的基本格式" class="headerlink" title="13.3.1 while的基本格式"></a>13.3.1 while的基本格式</h4><p>while命令的格式是：</p>
<pre><code>while test command
do
    other commands
done</code></pre><p>while命令的关键在于所指定的test command的退出状态码必须随着循环中运行的命令而改变。如果退出状态码不发生变化， while循环就将一直不停地进行下去。</p>
<h4 id="13-3-2-使用多个测试命令"><a href="#13-3-2-使用多个测试命令" class="headerlink" title="13.3.2 使用多个测试命令"></a>13.3.2 使用多个测试命令</h4><p>while命令允许你在while语句行定义多个测试命令。只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环。</p>
<h3 id="13-4-until-命令"><a href="#13-4-until-命令" class="headerlink" title="13.4 until 命令"></a>13.4 until 命令</h3><p>和while完全相反，一样理解就好。当条件为真则结束循环。</p>
<pre><code>until test commands
do
    other commands
done </code></pre><h3 id="13-5-嵌套循环"><a href="#13-5-嵌套循环" class="headerlink" title="13.5 嵌套循环"></a>13.5 嵌套循环</h3><p>学过编程的都会，就不做笔记了。</p>
<h3 id="13-6-循环处理文件数据"><a href="#13-6-循环处理文件数据" class="headerlink" title="13.6 循环处理文件数据"></a>13.6 循环处理文件数据</h3><p>通常必须遍历存储在文件中的数据。这要求结合已经讲过的两种技术：</p>
<ul>
<li>使用嵌套循环</li>
<li>修改IFS环境变量</li>
</ul>
<p>使用的精髓在于如何区分不同位置的IFS。</p>
<h3 id="13-7-控制循环"><a href="#13-7-控制循环" class="headerlink" title="13.7 控制循环"></a>13.7 控制循环</h3><p>和许多编程语言一样，也有<code>break</code>和<code>continue</code>。</p>
<h4 id="13-7-1-break命令"><a href="#13-7-1-break命令" class="headerlink" title="13.7.1 break命令"></a>13.7.1 break命令</h4><p>可以退出任意循环，但是比C语言强大之处是可以<strong>跳出外层循环</strong>。</p>
<h5 id="1）跳出单个循环"><a href="#1）跳出单个循环" class="headerlink" title="1）跳出单个循环"></a>1）跳出单个循环</h5><p>常规的break。</p>
<h5 id="2）跳出内部循环"><a href="#2）跳出内部循环" class="headerlink" title="2）跳出内部循环"></a>2）跳出内部循环</h5><p>一样的常规操作。</p>
<h5 id="3）跳出外层循环"><a href="#3）跳出外层循环" class="headerlink" title="3）跳出外层循环"></a>3）跳出外层循环</h5><p>有时你在内部循环，但需要停止外部循环。break命令接受单个命令行参数值： <strong>break n</strong> 其中n指定了要跳出的循环层级。默认情况下，<strong>n为1</strong>，表明跳出的是当前的循环。如果你将<strong>n设为2</strong>，break命令就会停止下一级的外部循环。<strong>n的上限取决于你循环的层次数。</strong></p>
<h4 id="13-7-2-continue命令"><a href="#13-7-2-continue命令" class="headerlink" title="13.7.2 continue命令"></a>13.7.2 continue命令</h4><p>一样，跳过continue命令下的命令，直接进行下一次循环。</p>
<p>和break命令一样，continue命令也允许通过命令行参数指定要继续执行哪一级循环： <strong>continue n</strong></p>
<h3 id="13-8-处理循环的输出"><a href="#13-8-处理循环的输出" class="headerlink" title="13.8 处理循环的输出"></a>13.8 处理循环的输出</h3><p>最后，在shell脚本中，你可以对循环的输出使用<strong>管道</strong>或进行<strong>重定向</strong>。这可以通过在done命令之后添加一个处理命令来实现。</p>
<pre><code>for file in /home/rich/*
do
if [ -d &quot;$file&quot; ]
then
    echo &quot;$file is a directory&quot;
elif
    echo &quot;$file is a file&quot;
fi
done &gt; output.txt </code></pre><h2 id="14-处理用户输入"><a href="#14-处理用户输入" class="headerlink" title="14 处理用户输入"></a>14 处理用户输入</h2><h3 id="14-1命令行参数"><a href="#14-1命令行参数" class="headerlink" title="14.1命令行参数"></a>14.1命令行参数</h3><p>向shell脚本传递参数的最基本方法是使用命令行参数。和那个int main(int avg,char ** avgr)一样，在exe后面加入参数即可传入。</p>
<pre><code>$ ./addem 10 30 </code></pre><h4 id="14-1-1-读取参数"><a href="#14-1-1-读取参数" class="headerlink" title="14.1.1 读取参数"></a>14.1.1 读取参数</h4><p>位置参数变量是标准的数字：<code>$0</code>是程序名，<code>$1</code>是第一个参数，<code>$2</code>是第二个参数，依次类推，直到第九个参数<code>$9</code>。所以在脚本里使用该参数名即可。</p>
<h4 id="14-1-2-读取脚本名"><a href="#14-1-2-读取脚本名" class="headerlink" title="14.1.2 读取脚本名"></a>14.1.2 读取脚本名</h4><p>就是<code>$0</code>，其实没啥用。</p>
<h4 id="14-1-3-测试参数"><a href="#14-1-3-测试参数" class="headerlink" title="14.1.3 测试参数"></a>14.1.3 测试参数</h4><p>和之前学过的编码规范一样，shell编程也需要注意规范。参要检查参数的有效性，否则当参数为空时会报错。</p>
<pre><code>$ cat test7.sh
#!/bin/bash
# testing parameters before use
#
if [ -n &quot;$1&quot; ]
then
    echo Hello $1, glad to meet you.
else
    echo &quot;Sorry, you did not identify yourself. &quot;
fi </code></pre><h3 id="14-2-特殊参数变量"><a href="#14-2-特殊参数变量" class="headerlink" title="14.2 特殊参数变量"></a>14.2 特殊参数变量</h3><h4 id="14-2-1-参数统计"><a href="#14-2-1-参数统计" class="headerlink" title="14.2.1 参数统计"></a>14.2.1 参数统计</h4><p>特殊变了<code>$#</code>含有脚本运行时携带的命令行参数的个数。可以在脚本中任何地方使用这个特殊变量，就和普通变量一样。</p>
<h4 id="14-2-2-抓取所有的数据"><a href="#14-2-2-抓取所有的数据" class="headerlink" title="14.2.2 抓取所有的数据"></a>14.2.2 抓取所有的数据</h4><p><code>$*</code>和<code>$@</code>变量可以用来轻松访问所有的参数。这两个变量都能够在单个变量中存储所有的命令行参数。</p>
<ul>
<li><code>$*</code>，将参数视为一个整体；</li>
<li><code>$@</code>，参数视为多个独立的单词。</li>
</ul>
<h3 id="14-3-移动变量"><a href="#14-3-移动变量" class="headerlink" title="14.3 移动变量"></a>14.3 移动变量</h3><p>通过shift命令移动参数的相对的位置，<code>$2</code>会变为<code>$1</code>。在你不知道参数的个数的时候，这个命令是个很好的方法。</p>
<h3 id="14-4-处理选项"><a href="#14-4-处理选项" class="headerlink" title="14.4 处理选项"></a>14.4 处理选项</h3><p>你会发现很多命令都有很多选项，比如<code>ls -l -a</code>一大堆的选项，记都记不住。</p>
<h4 id="14-4-1-查找选项"><a href="#14-4-1-查找选项" class="headerlink" title="14.4.1 查找选项"></a>14.4.1 查找选项</h4><p>用case处理选项，其实用if elif也可以吧，发现就是简单的匹配。</p>
<pre><code>while [ -n &quot;$1&quot; ]
do
case &quot;$1&quot; in
    -a) echo &quot;Found the -a option&quot; ;;
    -b) echo &quot;Found the -b option&quot; ;;
    -c) echo &quot;Found the -c option&quot; ;;
    *) echo &quot;$1 is not an option&quot; ;;
esac
shift
done </code></pre><h4 id="14-4-2-使用getopt命令"><a href="#14-4-2-使用getopt命令" class="headerlink" title="14.4.2 使用getopt命令"></a>14.4.2 使用getopt命令</h4><p>用于处理多个选项参数，比如<code>ls -la</code>。这个时候就要用<code>getopt</code>了，<strong>这个时候知道为什命令参数都是一个字母了。</strong></p>
<pre><code>$ getopt ab:cd -a -b test1 -cd test2 test3
-a -b test1 -c -d -- test2 test3
$</code></pre><p><strong>在脚本里使用：</strong></p>
<pre><code>set -- $(getopt -q ab:cd &quot;$@&quot;) </code></pre><h4 id="14-4-3-更高级的getopts命令"><a href="#14-4-3-更高级的getopts命令" class="headerlink" title="14.4.3 更高级的getopts命令"></a>14.4.3 更高级的getopts命令</h4><p>echo<br>    while getopts :ab:c opt<br>    do<br>    case “$opt” in<br>        a) echo “Found the -a option” ;;<br>        b) echo “Found the -b option, with value $OPTARG”;;<br>        c) echo “Found the -c option” ;;<br>        *) echo “Unknown option: $opt”;;<br>    esac<br>    done </p>
<h3 id="14-5-选项标准化"><a href="#14-5-选项标准化" class="headerlink" title="14.5 选项标准化"></a>14.5 选项标准化</h3><p>其实没啥用，具体选项还是自己定义，不过可以尽量与其他命令差不多。</p>
<h3 id="14-6-获得用户输入"><a href="#14-6-获得用户输入" class="headerlink" title="14.6 获得用户输入"></a>14.6 获得用户输入</h3><blockquote>
<p>终于到了喜闻乐见的输入环节，感觉已经和C语言之类的没什么区别了。</p>
</blockquote>
<h4 id="14-6-1-基本的读取"><a href="#14-6-1-基本的读取" class="headerlink" title="14.6.1 基本的读取"></a>14.6.1 基本的读取</h4><p>read命令从标准输入（键盘）或另一个文件描述符中接受输入。在收到输入后，read命令会将数据放进一个变量。下面是read命令的最简单用法。</p>
<pre><code>$ cat test21.sh
#!/bin/bash
# testing the read command
#
echo -n &quot;Enter your name: &quot;
read name
echo &quot;Hello $name, welcome to my program. &quot;
#
$
$ ./test21.sh
Enter your name: Rich Blum
Hello Rich Blum, welcome to my program.
$ </code></pre><h4 id="14-6-2-超时"><a href="#14-6-2-超时" class="headerlink" title="14.6.2 超时"></a>14.6.2 超时</h4><p>设置read读取超时，超过一定时间没有输入也要执行接下来的命令。当计时器过期后，read命令会返回一个非零退出状态码，用<code>if</code>来判断。</p>
<h4 id="14-6-3-隐藏方式读取"><a href="#14-6-3-隐藏方式读取" class="headerlink" title="14.6.3 隐藏方式读取"></a>14.6.3 隐藏方式读取</h4><blockquote>
<p>这不就是mysql登录的时候设置的么，密码没有显示在控制台。有时候都不知道自己是否在输入。</p>
</blockquote>
<pre><code>read -s -p &quot;Enter your password: &quot; pass </code></pre><h4 id="14-6-4-从文件中读取"><a href="#14-6-4-从文件中读取" class="headerlink" title="14.6.4 从文件中读取"></a>14.6.4 从文件中读取</h4><p>也可以用read命令从文件读，每次调用read命令，它都会从文件中读取一行文本。当文件中再没有内容时，read命令会退出并返回非零退出状态码。</p>
<p><strong>对文件使用cat命令，将结果通过管道直接传给含有read命令的while命令。</strong></p>
<pre><code>cat test | while read line
do
    echo &quot;Line $count: $line&quot;
count=$[ $count + 1] </code></pre><h2 id="15-呈现数据"><a href="#15-呈现数据" class="headerlink" title="15 呈现数据"></a>15 呈现数据</h2><blockquote>
<p>这一章主要讲如何将脚本的输出到Linux系统的不同位置。</p>
</blockquote>
<h3 id="15-1-理解输入和输出"><a href="#15-1-理解输入和输出" class="headerlink" title="15.1 理解输入和输出"></a>15.1 理解输入和输出</h3><p>用标准的Linux输入和输出系统来将脚本输出导向特定位置。</p>
<h4 id="15-1-1-标准文件描述符"><a href="#15-1-1-标准文件描述符" class="headerlink" title="15.1.1 标准文件描述符"></a>15.1.1 标准文件描述符</h4><p>前面提到Linux将一切对象当作文件来处理。Linux用文件描述符来标识每个文件对象。</p>
<h5 id="Linux的标准文件描述符"><a href="#Linux的标准文件描述符" class="headerlink" title="Linux的标准文件描述符"></a>Linux的标准文件描述符</h5><p>文件描述符</p>
<p>缩写</p>
<p>描述</p>
<p>0</p>
<p>STDIN</p>
<p>标准输入</p>
<p>1</p>
<p>STDOUT</p>
<p>标准输出</p>
<p>2</p>
<p>STDERR</p>
<p>标准错误</p>
<h5 id="1-STDIN"><a href="#1-STDIN" class="headerlink" title="1) STDIN"></a>1) STDIN</h5><p>标准输入，可以将文件里的内容输入到命令，比如：</p>
<pre><code>cat  &lt; testfile </code></pre><h5 id="2-STDOUT"><a href="#2-STDOUT" class="headerlink" title="2) STDOUT"></a>2) STDOUT</h5><p>标准输出，可以使用<code>&gt;</code>和<code>&gt;&gt;</code>（追加模式），前面有提到的输出重定向，比如：</p>
<pre><code>ls -l &gt; test </code></pre><h5 id="3）STDERR"><a href="#3）STDERR" class="headerlink" title="3）STDERR"></a>3）STDERR</h5><p>shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置。</p>
<h4 id="15-1-2-重定向错误"><a href="#15-1-2-重定向错误" class="headerlink" title="15.1.2 重定向错误"></a>15.1.2 重定向错误</h4><p>将文件描述符值放在重定向符号前。</p>
<pre><code>$ ls -al badfile 2&gt; test4
$ cat test4
ls: cannot access badfile: No such file or directory
$</code></pre><p>这个时候错误信息都会保存在输出文件中。</p>
<h4 id="15-1-3-重定向错误和数据"><a href="#15-1-3-重定向错误和数据" class="headerlink" title="15.1.3 重定向错误和数据"></a>15.1.3 重定向错误和数据</h4><p>数据则在符号前加1。</p>
<pre><code>$ ls -al test test2 test3 badtest 2&gt; test6 1&gt; test7
$ cat test6
ls: cannot access test: No such file or directory
ls: cannot access badtest: No such file or directory
$ cat test7
-rw-rw-r-- 1 rich rich 158 2014-10-16 11:32 test2
-rw-rw-r-- 1 rich rich 0 2014-10-16 11:33 test3
$</code></pre><p><strong>可以用这种方法将脚本的正常输出和脚本生成的错误消息分离开来，这样就可以轻松识别出错误信息。</strong></p>
<h3 id="15-2-在脚本中重定向输出"><a href="#15-2-在脚本中重定向输出" class="headerlink" title="15.2 在脚本中重定向输出"></a>15.2 在脚本中重定向输出</h3><p>这个功能有点用，可以将错误信息输出到文件，而正确信息则显示在屏幕。</p>
<h4 id="15-2-1-临时重定向"><a href="#15-2-1-临时重定向" class="headerlink" title="15.2.1 临时重定向"></a>15.2.1 临时重定向</h4><p>就像15.1.2节讲的一样，把命令放在脚本里就好。</p>
<h4 id="15-2-2-永久重定向"><a href="#15-2-2-永久重定向" class="headerlink" title="15.2.2 永久重定向"></a>15.2.2 永久重定向</h4><p>如果每个echo都加符号未免太繁琐了。使用<code>exec</code>命令设定执行期间重定向某个特定文件描述符</p>
<pre><code>exec 2&gt;testerror
    echo &quot;This is the start of the script&quot;
    echo &quot;now redirecting all output to another location&quot;
exec 1&gt;testout
    echo &quot;This output should go to the testout file&quot;
    echo &quot;but this should go to the testerror file&quot; &gt;&amp;2</code></pre><p>就等于模式切换吧，切换1和2。</p>
<h3 id="15-3-在脚本重定向输入"><a href="#15-3-在脚本重定向输入" class="headerlink" title="15.3 在脚本重定向输入"></a>15.3 在脚本重定向输入</h3><p>可以在脚本里获得文件的数据。</p>
<pre><code>exec 0&lt; testfile
count=1
while read line
do
    echo &quot;Line #$count: $line&quot;
    count=$[ $count + 1 ]
done </code></pre><h3 id="15-4-创建自己的重定向"><a href="#15-4-创建自己的重定向" class="headerlink" title="15.4 创建自己的重定向"></a>15.4 创建自己的重定向</h3><p>这个了解一下，就是可以从其他6个从3~8的文件描述符作为输入或者输出重定向。</p>
<h3 id="15-5-列出打开的文件描述符"><a href="#15-5-列出打开的文件描述符" class="headerlink" title="15.5 列出打开的文件描述符"></a>15.5 列出打开的文件描述符</h3><p><code>losf</code>会列出整个Linux系统打开的所有文件描述符。</p>
<h3 id="15-6-阻止命令输出"><a href="#15-6-阻止命令输出" class="headerlink" title="15.6 阻止命令输出"></a>15.6 阻止命令输出</h3><p>有时候脚本在后台运行，但是可能会出现错误消息，这个时候shell会将错误信息显示到主shell。避免这个问题就是将<code>STDERR</code>重定向到一个叫做null文件的特殊文件。</p>
<p>在Linux系统上null文件的标准位置是<code>/dev/null</code>。你重定向到该位置的任何数据都会被丢掉，不会显示。</p>
<pre><code>$ ls -al &gt; /dev/null
$ cat /dev/null
$ </code></pre><h3 id="15-7-创建临时文件"><a href="#15-7-创建临时文件" class="headerlink" title="15.7 创建临时文件"></a>15.7 创建临时文件</h3><p>Linux有特殊的目录<code>/tmp</code>，专供临时文件使用。</p>
<h4 id="15-7-1-创建本地临时文件"><a href="#15-7-1-创建本地临时文件" class="headerlink" title="15.7.1 创建本地临时文件"></a>15.7.1 创建本地临时文件</h4><pre><code>$ mktemp testing.XXXXXX
$ ls -al testing*
-rw------- 1 rich rich 0 Oct 17 21:30 testing.UfIi13
$</code></pre><p>这个XXXXXX会用6个字符码替换这6个X，从而保证文件名在目录中是唯一的。</p>
<h4 id="15-7-2-在-tmp目录创建临时文件"><a href="#15-7-2-在-tmp目录创建临时文件" class="headerlink" title="15.7.2 在/tmp目录创建临时文件"></a>15.7.2 在/tmp目录创建临时文件</h4><p>使用<code>mktemp -t</code>可以在`/tmp目录中创建一个唯一的临时文件。</p>
<h4 id="15-7-3-创建临时目录"><a href="#15-7-3-创建临时目录" class="headerlink" title="15.7.3 创建临时目录"></a>15.7.3 创建临时目录</h4><p>使用<code>mktemp -d</code>创建临时目录</p>
<h3 id="15-8-记录消息"><a href="#15-8-记录消息" class="headerlink" title="15.8 记录消息"></a>15.8 记录消息</h3><p>既想要将消息重定向到文件，也想显示在屏幕上，那么使用<code>tee</code>命令。</p>
<p>由于tee会重定向来自<code>STDIN</code>的数据，你可以用它配合管道命令来重定向命令输出。</p>
<pre><code>$ date | tee testfile
Sun Oct 19 18:56:21 EDT 2014
$ cat testfile
Sun Oct 19 18:56:21 EDT 2014
$ </code></pre><h2 id="16-控制脚本"><a href="#16-控制脚本" class="headerlink" title="16 控制脚本"></a>16 控制脚本</h2><h3 id="16-1-处理信号"><a href="#16-1-处理信号" class="headerlink" title="16.1 处理信号"></a>16.1 处理信号</h3><p>Linux利用信号与运行在系统中的进程进行通信。Linux里有64种信号，32种实时信号，32种非实时信号。在控制台输入<code>kill -l</code>可以查看所有信号以及其对应的数字。</p>
<p><img src="https://tanwenbo.top/wp-content/uploads/2018/06/0833d69721db408d097d401a16eafc94.png" alt=""></p>
<h4 id="16-1-1-主要Linux信号"><a href="#16-1-1-主要Linux信号" class="headerlink" title="16.1.1 主要Linux信号"></a>16.1.1 主要Linux信号</h4><p>信 号</p>
<p>值</p>
<p>描 述</p>
<p>1</p>
<p>SIGHUP</p>
<p>挂起进程</p>
<p>2</p>
<p>SIGINT</p>
<p>终止进程</p>
<p>3</p>
<p>SIGQUIT</p>
<p>停止进程</p>
<p>9</p>
<p>SIGKILL</p>
<p>无条件终止进程</p>
<p>15</p>
<p>SIGTERM</p>
<p>尽可能终止进程</p>
<p>17</p>
<p>SIGSTOP</p>
<p>无条件停止进程，但不是终止进程</p>
<p>18</p>
<p>SIGTSTP</p>
<p>停止或暂停进程，但不终止进程</p>
<p>19</p>
<p>SIGCONT</p>
<p>继续运行停止的进程</p>
<p><code>SIGINT</code>和<code>SIGHUP</code>会终止shell脚本。</p>
<h4 id="16-1-2-生成信号"><a href="#16-1-2-生成信号" class="headerlink" title="16.1.2 生成信号"></a>16.1.2 生成信号</h4><h5 id="1）中断进程"><a href="#1）中断进程" class="headerlink" title="1）中断进程"></a>1）中断进程</h5><p><code>Ctrl + C</code>组合键会生成<code>SIGINT</code>信号，并将其发送给当前在shell中运行的所有进程。<strong>终止进程</strong>。</p>
<h5 id="2）-暂停进程"><a href="#2）-暂停进程" class="headerlink" title="2） 暂停进程"></a>2） 暂停进程</h5><p>不是挂起是暂停，<code>Ctrl + Z</code>组合键发送<code>SIGTSTP</code>信号。<strong>停止shell中运行的任何进程</strong>，要注意与<strong>终止</strong>的区别。停止进程会让程序继续保留在内存中，并能从上次停止的位置继续运行。</p>
<h4 id="16-1-3-捕获信号"><a href="#16-1-3-捕获信号" class="headerlink" title="16.1.3 捕获信号"></a>16.1.3 捕获信号</h4><p>信号捕获出现时捕获它们并执行其他命令。<code>trap</code>命令允许你来指定<code>shell</code>脚本要监看并从shell中拦截的Linux信号。 trap命令的格式是： <strong>trap commands signals</strong></p>
<h4 id="16-1-4-捕获脚本退出"><a href="#16-1-4-捕获脚本退出" class="headerlink" title="16.1.4 捕获脚本退出"></a>16.1.4 捕获脚本退出</h4><p>就是捕获EXIT信号。</p>
<h4 id="16-1-5-修改或移除捕获"><a href="#16-1-5-修改或移除捕获" class="headerlink" title="16.1.5 修改或移除捕获"></a>16.1.5 修改或移除捕获</h4><p>要想在脚本中的不同位置进行不同的捕获处理，只需重新使用带有新选项的trap命令。</p>
<h3 id="16-2-以后台模式运行脚本"><a href="#16-2-以后台模式运行脚本" class="headerlink" title="16.2 以后台模式运行脚本"></a>16.2 以后台模式运行脚本</h3><p>以后台模式运行shell脚本非常简单。只要在命令后加个<code>&amp;</code>符就行了。</p>
<p>注意，当后台进程运行时，它仍然会使用终端显示器来显示<code>STDOUT</code>和<code>STDERR</code>消息。</p>
<p>但是要注意如果退出终端会话那么脚本也会随之退出。</p>
<h3 id="16-3-在非控制台下运行脚本"><a href="#16-3-在非控制台下运行脚本" class="headerlink" title="16.3 在非控制台下运行脚本"></a>16.3 在非控制台下运行脚本</h3><p><code>nohup</code>命令运行了另外一个命令来阻断所有发送给该进程的SIGHUP信号。这会在退出终端会 话时阻止进程退出。一般和<code>&amp;</code>一起用。</p>
<p>用途：不挂断地运行命令。</p>
<p>语法：<strong>nohup Command &amp;</strong></p>
<h3 id="16-4-作业控制"><a href="#16-4-作业控制" class="headerlink" title="16.4 作业控制"></a>16.4 作业控制</h3><h4 id="16-4-1-查看作业"><a href="#16-4-1-查看作业" class="headerlink" title="16.4.1 查看作业"></a>16.4.1 查看作业</h4><p><code>jobs</code>查看当前shell正在处理的作业。</p>
<h4 id="16-4-2-重启停止的作业"><a href="#16-4-2-重启停止的作业" class="headerlink" title="16.4.2 重启停止的作业"></a>16.4.2 重启停止的作业</h4><p><code>bg</code>命令重启停止的作业，加上作业号可以指定，用jobs查看作业号。</p>
<h3 id="16-5-调整谦让度"><a href="#16-5-调整谦让度" class="headerlink" title="16.5 调整谦让度"></a>16.5 调整谦让度</h3><p>改变脚本运行的优先级。</p>
<h4 id="16-5-1-nice命令"><a href="#16-5-1-nice命令" class="headerlink" title="16.5.1 nice命令"></a>16.5.1 nice命令</h4><p><code>nice</code>命令允许你设置命令<strong>启动时</strong>的调度优先级。</p>
<pre><code>nice -n 10 ./test4.sh </code></pre><h4 id="16-5-2-renice命令"><a href="#16-5-2-renice命令" class="headerlink" title="16.5.2 renice命令"></a>16.5.2 renice命令</h4><p>改变<strong>已经运行</strong>命令的优先级。</p>
<pre><code>renice -n 10 -p 5055
#5055 是进程PID </code></pre><h3 id="16-6-定时运行作业"><a href="#16-6-定时运行作业" class="headerlink" title="16.6 定时运行作业"></a>16.6 定时运行作业</h3><h4 id="16-6-1-用at命令来计划执行作业"><a href="#16-6-1-用at命令来计划执行作业" class="headerlink" title="16.6.1 用at命令来计划执行作业"></a>16.6.1 用at命令来计划执行作业</h4><p>at命令格式：</p>
<pre><code>at [-f filename] time</code></pre><p>主要是如何指定时间，这个时间格式的问题。</p>
<ul>
<li>标准的小时和分钟格式，比如10:15。</li>
<li>AM/PM指示符，比如10:15 PM。</li>
<li>特定可命名时间，比如now、noon、midnight或者teatime（4 PM）。</li>
<li>除了指定运行作业的时间，也可以通过不同的日期格式指定特定的日期。</li>
<li>标准日期格式，比如MMDDYY、MM/DD/YY或DD.MM.YY。</li>
<li>文本日期，比如Jul 4或Dec 25，加不加年份均可。</li>
</ul>
<h4 id="16-6-2-安排需要定期执行的脚本"><a href="#16-6-2-安排需要定期执行的脚本" class="headerlink" title="16.6.2 安排需要定期执行的脚本"></a>16.6.2 安排需要定期执行的脚本</h4><p>定时执行，比如定时重启一下服务器。 <code>cron</code>时间表采用一种特别的格式来指定作业何时运行。其格式如下： <strong>min hour dayofmonth month dayofweek command</strong></p>
<h5 id="cron目录"><a href="#cron目录" class="headerlink" title="cron目录"></a>cron目录</h5><p>有4个基本目录：hourly、daily、monthly和weekly。可以将脚本放进去，系统会自动根据目录运行。</p>
<h2 id="17-创建函数"><a href="#17-创建函数" class="headerlink" title="17 创建函数"></a>17 创建函数</h2><blockquote>
<p>简要一点了。</p>
</blockquote>
<h3 id="17-1-基本函数"><a href="#17-1-基本函数" class="headerlink" title="17.1 基本函数"></a>17.1 基本函数</h3><blockquote>
<p>和很多见过的都一样，function开头。然后用中括号括起来</p>
</blockquote>
<pre><code>function name {
commands
}
#两种
name() {
commands
} </code></pre><h3 id="17-2-返回值"><a href="#17-2-返回值" class="headerlink" title="17.2 返回值"></a>17.2 返回值</h3><p>函数也相当于是脚本，结束时会返回一个退出状态码。用<code>$?</code>确定函数的退出状态码。</p>
<p>可以用<code>return</code>返回固定的状态码。</p>
<ul>
<li>函数一结束就取返回值；</li>
<li>退出状态码必须是0~255。</li>
</ul>
<p>函数也可以将值返回给变量</p>
<pre><code>function dbl {
read -p &quot;Enter a value: &quot; value
echo $[ $value * 2 ]
}
result=$(dbl) </code></pre><h3 id="17-3-在函数中使用变量"><a href="#17-3-在函数中使用变量" class="headerlink" title="17.3 在函数中使用变量"></a>17.3 在函数中使用变量</h3><p>函数里也可以使用<code>$#</code>来判断参数的个数，<code>$1</code>为第一个参数，以此类推。</p>
<p>调用的时候在函数名后面加参数即可。</p>
<pre><code>function addem {
if [ $# -eq 0 ] || [ $# -gt 2 ]
then
    echo -1
elif [ $# -eq 1 ]
then
    echo $[ $1 + $1 ]
else
    echo $[ $1 + $2 ]
fi

value=$(addem 10 15)</code></pre><p>local在函数体里声明局部变量。</p>
<pre><code>local temp=$[ $value + 5 ] </code></pre><h3 id="17-4-数组变量和函数"><a href="#17-4-数组变量和函数" class="headerlink" title="17.4 数组变量和函数"></a>17.4 数组变量和函数</h3><p>要在函数里定义一个数组，不能直接使用传进来的数组名，会出错。</p>
<pre><code>function testit {
local newarray
newarray=(;&apos;echo &quot;$@&quot;&apos;)
echo &quot;The new array value is: ${newarray[*]}&quot;
}
myarray=(1 2 3 4 5)
echo &quot;The original array is ${myarray[*]}&quot;
testit ${myarray[*]}</code></pre><p>要注意是<code>$@</code>和<code>newarray[*]</code></p>
<h3 id="17-5-函数递归"><a href="#17-5-函数递归" class="headerlink" title="17.5 函数递归"></a>17.5 函数递归</h3><p>在脚本里使用递归，要注意终止递归的条件。</p>
<pre><code>function factorial {
if [ $1 -eq 1 ]
then
    echo 1
else
    local temp=$[ $1 - 1 ]
    local result=&apos;factorial $temp&apos;
    echo $[ $result * $1 ]
fi
} </code></pre><h3 id="17-6-创建库"><a href="#17-6-创建库" class="headerlink" title="17.6 创建库"></a>17.6 创建库</h3><p>脚本也可以使用库函数，写了一个脚本叫myfuncs，调用的时候加个点。</p>
<pre><code>$ cat test14
#!/bin/bash
# using functions defined in a library file
. ./myfuncs
# 调用库文件
value1=10
value2=5
result1=$(addem $value1 $value2)
result2=$(multem $value1 $value2)
result3=$(divem $value1 $value2) </code></pre><h3 id="17-7-在命令行上使用函数"><a href="#17-7-在命令行上使用函数" class="headerlink" title="17.7 在命令行上使用函数"></a>17.7 在命令行上使用函数</h3><p>将函数定义在.bashrc中可以在任意情况使用所定义的函数。</p>
<h2 id="18-图形化桌面环境中的脚本编程"><a href="#18-图形化桌面环境中的脚本编程" class="headerlink" title="18 图形化桌面环境中的脚本编程"></a>18 图形化桌面环境中的脚本编程</h2><blockquote>
<p>这个掠过</p>
</blockquote>
<h2 id="19-初识sed和gawk"><a href="#19-初识sed和gawk" class="headerlink" title="19 初识sed和gawk"></a>19 初识sed和gawk</h2><h3 id="19-1-sed编辑器"><a href="#19-1-sed编辑器" class="headerlink" title="19.1 sed编辑器"></a>19.1 sed编辑器</h3><p>sed编辑器被称作流编辑器（stream editor），和普通的交互式文本编辑器恰好相反。sed编辑器可以根据命令来处理数据流中的数据，这些命令要么从命令行中输入，要么存储在一个命令文本文件中。sed编辑器会执行下列操作。</p>
<blockquote>
<p>简单来说就是可以<strong>快速改变文本输出内容</strong></p>
</blockquote>
<p><strong>sed编辑器并不会修改文本文件的数据</strong>。它只会将修改后的数据发送到<strong>STDOUT</strong>。如果你查看原来的文本文件，它仍然保留着原始数据。</p>
<pre><code>sed &apos;s/dog/cat/&apos; data1.txt </code></pre><h4 id="19-1-1-插入数据"><a href="#19-1-1-插入数据" class="headerlink" title="19.1.1 插入数据"></a>19.1.1 插入数据</h4><ul>
<li>插入（insert）命令（i）会在指定行前增加一个新行；</li>
<li>附加（append）命令（a）会在指定行后增加一个新行。</li>
</ul>
<p>下面的例子是将一个新行插入到数据流第三行前。</p>
<pre><code>$ sed &apos;3i\
&gt; This is an inserted line.&apos; data6.txt </code></pre><h4 id="19-1-2-使用sed-处理文件"><a href="#19-1-2-使用sed-处理文件" class="headerlink" title="19.1.2 使用sed 处理文件"></a>19.1.2 使用sed 处理文件</h4><p>将data6.txt的前两行写入到 test.txt</p>
<pre><code>$ sed &apos;1,2w test.txt&apos; data6.txt
This is line number 1.
This is line number 2.
This is line number 3.
This is line number 4. </code></pre><h3 id="19-2-gawk程序"><a href="#19-2-gawk程序" class="headerlink" title="19.2 gawk程序"></a>19.2 gawk程序</h3><blockquote>
<p>这个了解一下</p>
</blockquote>
<p>在gawk编程语言中，你可以做下面的事情：</p>
<ul>
<li>定义变量来保存数据；</li>
<li>使用算术和字符串操作符来处理数据；</li>
<li>使用结构化编程概念（比如if-then语句和循环）来为数据处理增加处理逻辑；</li>
<li>通过提取数据文件中的数据元素，将其重新排列或格式化，生成格式化报告。</li>
</ul>
<h2 id="20-正则表达式"><a href="#20-正则表达式" class="headerlink" title="20 正则表达式"></a>20 正则表达式</h2><blockquote>
<p>就不再解释什么是正则表达式了，直接用。</p>
</blockquote>
<h3 id="20-1-正则表达式的类型"><a href="#20-1-正则表达式的类型" class="headerlink" title="20.1 正则表达式的类型"></a>20.1 正则表达式的类型</h3><p>在Linux中，有两种流行的正则表达式引擎：</p>
<ul>
<li>POSIX基础正则表达式（basic regular expression，BRE）引擎</li>
<li>POSIX扩展正则表达式（extended regular expression，ERE）引擎</li>
</ul>
<h3 id="20-2-BRE模式"><a href="#20-2-BRE模式" class="headerlink" title="20.2 BRE模式"></a>20.2 BRE模式</h3><h4 id="20-2-1-纯文本"><a href="#20-2-1-纯文本" class="headerlink" title="20.2.1 纯文本"></a>20.2.1 纯文本</h4><p>区分大小写，注意<code>p</code>是打印。</p>
<pre><code>$ echo &quot;This is a test&quot; | sed -n &apos;/test/p&apos;
This is a test
$ echo &quot;This is a test&quot; | sed -n &apos;/trial/p&apos;
$ </code></pre><h4 id="20-2-2-特殊字符"><a href="#20-2-2-特殊字符" class="headerlink" title="20.2.2 特殊字符"></a>20.2.2 特殊字符</h4><p>正则表达式识别的特殊字符包括： <code>.*[]^${}\+?|()</code></p>
<p><strong>使用的时候必须在前面加上转义字符，<code>\</code>。</strong></p>
<h4 id="20-2-3-锚字符"><a href="#20-2-3-锚字符" class="headerlink" title="20.2.3 锚字符"></a>20.2.3 锚字符</h4><p>mao字符。</p>
<h5 id="1）锁定在行首"><a href="#1）锁定在行首" class="headerlink" title="1）锁定在行首"></a>1）锁定在行首</h5><p>脱字符（<code>^</code>）定义从数据流中文本行的行首开始的模式。就是只能匹配行首的位置</p>
<h5 id="2）锁定在行尾"><a href="#2）锁定在行尾" class="headerlink" title="2）锁定在行尾"></a>2）锁定在行尾</h5><p>特殊字符美元符（<code>$</code>）定义了行尾锚点。</p>
<h5 id="3）组合锚点"><a href="#3）组合锚点" class="headerlink" title="3）组合锚点"></a>3）组合锚点</h5><p>只找单独一行特定文本。</p>
<pre><code>$ sed -n &apos;/^this is a test$/p&apos; data4
this is a test </code></pre><h4 id="20-2-4-点号字符"><a href="#20-2-4-点号字符" class="headerlink" title="20.2.4 点号字符"></a>20.2.4 点号字符</h4><p>只匹配能用别的字符替换这个<code>.</code>的。</p>
<pre><code>$ sed -n &apos;/.at/p&apos; data6
The cat is sleeping.
That is a very nice hat.
This test is at line four.
$ </code></pre><h4 id="20-2-5-字符组"><a href="#20-2-5-字符组" class="headerlink" title="20.2.5 字符组"></a>20.2.5 字符组</h4><p>可以和字符组中的任一字符组成组合。</p>
<pre><code>$ sed -n &apos;/[ch]at/p&apos; data6
The cat is sleeping.
That is a very nice hat.
$ </code></pre><h4 id="20-2-6-排除型字符组"><a href="#20-2-6-排除型字符组" class="headerlink" title="20.2.6 排除型字符组"></a>20.2.6 排除型字符组</h4><p>在字符组开头加个<code>^</code>。</p>
<pre><code>$ sed -n &apos;/[^ch]at/p&apos; data6
This test is at line four.
$ </code></pre><h4 id="20-2-7-区间"><a href="#20-2-7-区间" class="headerlink" title="20.2.7 区间"></a>20.2.7 区间</h4><p>只匹配区间内的字符</p>
<pre><code>$ sed -n &apos;/^[0-9][0-9][0-9][0-9][0-9]$/p&apos; data8
60633
46201
45902
$</code></pre><p>同样的方法也适用于字母。</p>
<pre><code>$ sed -n &apos;/[c-h]at/p&apos; data6</code></pre><p>还可以在单个字符组指定多个不连续的区间。</p>
<pre><code>$ sed -n &apos;/[a-ch-m]at/p&apos; data6 </code></pre><h4 id="20-2-8-特殊的字符组"><a href="#20-2-8-特殊的字符组" class="headerlink" title="20.2.8 特殊的字符组"></a>20.2.8 特殊的字符组</h4><p>匹配特定类型的字符</p>
<p>组</p>
<p>描述</p>
<p>[[:alpha:]]</p>
<p>匹配任意字母字符，不管是大写还是小写</p>
<p>[[:alnum:]]</p>
<p>匹配任意字母数字字符0<del>9、A</del>Z或a~z</p>
<p>[[:blank:]]</p>
<p>匹配空格或制表符</p>
<p>[[:digit:]]</p>
<p>匹配0~9之间的数字</p>
<p>[[:lower:]]</p>
<p>匹配小写字母字符a~z</p>
<p>[[:print:]]</p>
<p>匹配任意可打印字符</p>
<p>[[:punct:]]</p>
<p>匹配标点符号</p>
<p>[[:space:]]</p>
<p>匹配任意空白字符：空格、制表符、NL、FF、VT和CR</p>
<p>[[:upper:]]</p>
<p>匹配任意大写字母字符A~Z</p>
<h4 id="20-2-9-星号"><a href="#20-2-9-星号" class="headerlink" title="20.2.9 星号"></a>20.2.9 星号</h4><p>字符后面加个<code>*</code>，表示这个e可以0次或者出现多次。</p>
<pre><code>$ echo &quot;ik&quot; | sed -n &apos;/ie*k/p&apos;
ik
$ echo &quot;iek&quot; | sed -n &apos;/ie*k/p&apos;
iek </code></pre><h3 id="20-3-扩展正则表达式"><a href="#20-3-扩展正则表达式" class="headerlink" title="20.3 扩展正则表达式"></a>20.3 扩展正则表达式</h3><p>主要是gawk程序使用。</p>
<h4 id="20-3-1-问号"><a href="#20-3-1-问号" class="headerlink" title="20.3.1 问号"></a>20.3.1 问号</h4><p>问号类似于星号，不过有点细微的不同。问号表明前面的字符可以出现0次或1次，但只限于此。它不会匹配多次出现的字符。</p>
<pre><code>$ echo &quot;bt&quot; | gawk &apos;/be?t/{print $0}&apos;
bt
$ echo &quot;bet&quot; | gawk &apos;/be?t/{print $0}&apos;
bet </code></pre><h4 id="20-3-2-加号"><a href="#20-3-2-加号" class="headerlink" title="20.3.2 加号"></a>20.3.2 加号</h4><p>类似于星号但必须至少出现1次。如果该字符没有出现，那么模式就不会匹配。</p>
<pre><code>$ echo &quot;beeet&quot; | gawk &apos;/be+t/{print $0}&apos;
beeet
$ echo &quot;beet&quot; | gawk &apos;/be+t/{print $0}&apos;
beet </code></pre><h4 id="20-3-3-使用花括号"><a href="#20-3-3-使用花括号" class="headerlink" title="20.3.3 使用花括号"></a>20.3.3 使用花括号</h4><p>ERE中的花括号允许你为可重复的正则表达式指定一个上限，两种格式来指定区间。</p>
<ul>
<li><p>m：正则表达式准确出现m次。</p>
</li>
<li><p>m, n：正则表达式至少出现m次，至多n次。</p>
<p>$ echo “bt” | gawk –re-interval ‘/be{1}t/{print $0}’<br>$<br>$ echo “bet” | gawk –re-interval ‘/be{1}t/{print $0}’<br>bet </p>
</li>
</ul>
<h4 id="20-3-4-管道符号"><a href="#20-3-4-管道符号" class="headerlink" title="20.3.4 管道符号"></a>20.3.4 管道符号</h4><p>管道符号允许你在检查数据流时，用逻辑OR方式指定正则表达式引擎要用的两个或多个模 式。</p>
<pre><code>$ echo &quot;The cat is asleep&quot; | gawk &apos;/cat|dog/{print $0}&apos;</code></pre><p>正则表达式和管道符号之间不能有空格，否则它们也会被认为是正则表达式模式的一部分。</p>
<h4 id="20-3-5-表达式分组"><a href="#20-3-5-表达式分组" class="headerlink" title="20.3.5 表达式分组"></a>20.3.5 表达式分组</h4><p>正则表达式模式也可以用圆括号进行分组。</p>
<pre><code>$ echo &quot;cat&quot; | gawk &apos;/(c|b)a(b|t)/{print $0}&apos;
cat
$ echo &quot;cab&quot; | gawk &apos;/(c|b)a(b|t)/{print $0}&apos;
cab
$ echo &quot;bat&quot; | gawk &apos;/(c|b)a(b|t)/{print $0}&apos;
bat
$ echo &quot;bab&quot; | gawk &apos;/(c|b)a(b|t)/{print $0}&apos;
bab</code></pre><p>将分组和管道符号一起使用来创建可能的模式匹配组是很常见的做法。</p>
<h2 id="21-sed进阶"><a href="#21-sed进阶" class="headerlink" title="21 sed进阶"></a>21 sed进阶</h2><blockquote>
<p>本来不想看了，但是好像sed和awk是重点标出来的，还是看一下。</p>
</blockquote>
<h3 id="21-1-多行命令"><a href="#21-1-多行命令" class="headerlink" title="21.1 多行命令"></a>21.1 多行命令</h3><p>处理多行，之前介绍的都是单行。</p>
<h4 id="21-1-1-next命令"><a href="#21-1-1-next命令" class="headerlink" title="21.1.1 next命令"></a>21.1.1 next命令</h4><p>可以对搜索到的数据的下一行进行操作。</p>
<h5 id="1）单行的next命令"><a href="#1）单行的next命令" class="headerlink" title="1）单行的next命令"></a>1）单行的next命令</h5><p>小写<code>n</code></p>
<pre><code>$ sed &apos;/header/{n ; d}&apos; data1.txt
This is the header line.
This is a data line.
This is the last line.
$</code></pre><p>可见，sed会先找到文本中有header的那一行，然后删除其下一行的空格<code>d</code>。</p>
<h5 id="2）-合并文本行"><a href="#2）-合并文本行" class="headerlink" title="2） 合并文本行"></a>2） 合并文本行</h5><p>大写N可以将下一文本行添加到模式空间中已有的文本后，<strong>主要用来匹配不在同一行的对象</strong>。</p>
<pre><code>$ cat data2.txt
This is the header line.
This is the first data line.
This is the second data line.
This is the last line.
$
$ sed &apos;/first/{ N ; s/\n/ / }&apos; data2.txt
This is the header line.
This is the first data line. This is the second data line.
This is the last line.
$</code></pre><p>要注意s后面的<code>\n</code>，是换行符，然后将这个换行符换为空格。</p>
<h4 id="21-1-2-多行删除命令"><a href="#21-1-2-多行删除命令" class="headerlink" title="21.1.2 多行删除命令"></a>21.1.2 多行删除命令</h4><p><code>d</code>是删除单行，多行删除为<code>D</code>，并不是<strong>删除多行</strong>而是<strong>多行查找到后删除目标行</strong>。</p>
<pre><code>$ cat data5.txt
This is the header line.
This is a data line.
This is the last line.
$
$ sed &apos;/^$/{N ; /header/D}&apos; data5.txt
This is the header line.
This is a data line.
This is the last line.
$</code></pre><p>sed编辑器脚本会查找空白行，然后用N命令来将下一文本行添加到模式空间。如果新的模式空间内容含有单词header，则<code>D</code>命令会删除模式空间中的第一行。如果不结合使用<code>N</code>命令和<code>D</code>命令，就不可能在不删除其他空白行的情况下只删除第一个空白行。</p>
<h4 id="21-1-3-多行打印命令"><a href="#21-1-3-多行打印命令" class="headerlink" title="21.1.3 多行打印命令"></a>21.1.3 多行打印命令</h4><blockquote>
<p>模式空间就是sed会将符合规则的内容放入模式空间</p>
</blockquote>
<p>它只打印多行模式空间中的第一行。这包括模式空间中直到换行符为止的所有字符。要和N命令以及D命令组合起来使用才很强大。</p>
<p>在命令脚本中加入N命令，你就能单步扫过整个模式空间，将多行一起匹配。接下来，使用P命令打印出第一行，然后用D命令删除第一行并绕回到脚本的起始处。一旦返回，N命令会读取下一行文本并重新开始这个过程。这个循环会一直继续下去，直到数据流结束。</p>
<h3 id="21-2-保持空间"><a href="#21-2-保持空间" class="headerlink" title="21.2 保持空间"></a>21.2 保持空间</h3><p>sed编辑器有另一块称作保持空间（hold space）的缓冲区域。在处理模式空间中的某些行时，可以用保持空间来临时保存一些行。</p>
<ul>
<li>h 将模式空间复制到保持空间</li>
<li>H 将模式空间附加到保持空间</li>
<li>g 将保持空间复制到模式空间</li>
<li>G 将保持空间附加到模式空间</li>
<li>x 交换模式空间和保持空间的内容</li>
</ul>
<h3 id="21-3-排除命令"><a href="#21-3-排除命令" class="headerlink" title="21.3 排除命令"></a>21.3 排除命令</h3><pre><code>$ sed -n &apos;/header/!p&apos; data2.txt
This is the first data line.
This is the second data line.
This is the last line.
$</code></pre><p>就是输出不符合规则的文本。</p>
<h3 id="21-4-改变流"><a href="#21-4-改变流" class="headerlink" title="21.4 改变流"></a>21.4 改变流</h3><h4 id="21-4-1-分支"><a href="#21-4-1-分支" class="headerlink" title="21.4.1 分支"></a>21.4.1 分支</h4><p>可以排除指定块，不对其使用命令。分支（branch）命令b的格式如下： <strong>[address]b [label]</strong> address参数决定了哪些行的数据会触发分支命令。label参数定义了要跳转到的位置。如果没有加label参数，跳转命令会跳转到脚本的结尾。</p>
<pre><code>$ cat data2.txt
This is the header line.
This is the first data line.
This is the second data line.
This is the last line.
$
$ sed &apos;{2,3b ; s/This is/Is this/ ; s/line./test?/}&apos; data2.txt
Is this the header test?
This is the first data line.
This is the second data line.
Is this the last test?
$</code></pre><p>跳过了第二行和第三行</p>
<h4 id="21-4-2-测试"><a href="#21-4-2-测试" class="headerlink" title="21.4.2 测试"></a>21.4.2 测试</h4><p>如果替换命令成功匹配并替换了一个模式，测试命令就会跳转到指定的标签。如果替换命令未能匹配指定的模式，测试命令就不会跳转。 测试命令使用与分支命令相同的格式。 <strong>[address]t [label]</strong> 跟分支命令一样，在没有指定标签的情况下，如果测试成功，sed会跳转到脚本的结尾。</p>
<blockquote>
<p>这个命令就像是if else，如果替换前面的替换成功了那么后面的就不会进行操作。</p>
</blockquote>
<h3 id="21-5-模式替代"><a href="#21-5-模式替代" class="headerlink" title="21.5 模式替代"></a>21.5 模式替代</h3><p>用通配符<code>.</code>匹配多个单词，对其进行操作。</p>
<h4 id="21-5-1-amp-符号"><a href="#21-5-1-amp-符号" class="headerlink" title="21.5.1 &amp;符号"></a>21.5.1 &amp;符号</h4><pre><code>$ echo &quot;The cat sleeps in his hat.&quot; | sed &apos;s/.at/&quot;&amp;&quot;/g&apos;
The &quot;cat&quot; sleeps in his &quot;hat&quot;.
$</code></pre><p>当模式匹配了单词cat，<code>&quot;cat&quot;</code>就会出现在了替换后的单词里。当它匹配了单词hat，”hat” 就出现在了替换后的单词中。</p>
<h4 id="21-5-2-替代单独的单词"><a href="#21-5-2-替代单独的单词" class="headerlink" title="21.5.2 替代单独的单词"></a>21.5.2 替代单独的单词</h4><p>用单词替代短语，括号括起来的就是子模式。</p>
<pre><code>$ echo &quot;That furry cat is pretty&quot; | sed &apos;s/furry \(.at\)/\1/&apos;
That cat is pretty
$
$ echo &quot;That furry hat is pretty&quot; | sed &apos;s/furry \(.at\)/\1/&apos;
That hat is pretty
$ </code></pre><h2 id="22-gawk进阶"><a href="#22-gawk进阶" class="headerlink" title="22 gawk进阶"></a>22 gawk进阶</h2><blockquote>
<p>粗略的看一看，不要拘泥细节</p>
</blockquote>
<h3 id="22-1-使用变量"><a href="#22-1-使用变量" class="headerlink" title="22.1 使用变量"></a>22.1 使用变量</h3><p>支持两种不同类型的变量：</p>
<ul>
<li>内建变量</li>
<li>自定义变量</li>
</ul>
<h4 id="22-1-1-内建变量"><a href="#22-1-1-内建变量" class="headerlink" title="22.1.1 内建变量"></a>22.1.1 内建变量</h4><p>字段分隔符，用来分割数据。</p>
<ul>
<li>FIELDWIDTHS 由空格分隔的一列数字，定义了每个数据字段确切宽度</li>
<li>FS 输入字段分隔符</li>
<li>RS 输入记录分隔符</li>
<li>OFS 输出字段分隔符</li>
<li>ORS 输出记录分隔符</li>
</ul>
<p>默认分隔符为空格，用FS来判断分隔符，然后用OFS输出不同的分隔符。</p>
<pre><code>$ cat data1
data11,data12,data13,data14,data15
data21,data22,data23,data24,data25
data31,data32,data33,data34,data35
$ gawk &apos;BEGIN{FS=&quot;,&quot;; OFS=&quot;-&quot;} {print $1,$2,$3}&apos; data1
data11-data12-data13
data21-data22-data23
data31-data32-data33</code></pre><p>变量RS和ORS定义了gawk程序如何处理数据流中的字段。默认情况下，gawk将RS和ORS设为换行符。默认的RS值表明，输入数据流中的每行新本就是一条新纪录。</p>
<p>前面的FS是处理字段，这个RS是处理字段里的数据。记录分隔符。</p>
<pre><code>$ cat data2
Riley Mullen
123 Main Street
Chicago, IL 60601
(312)555-1234
Frank Williams
456 Oak Street
Indianapolis, IN 46201
(317)555-9876
Haley Snell
4231 Elm Street
Detroit, MI 48201
(313)555-4938
$ gawk &apos;BEGIN{FS=&quot;\n&quot;; RS=&quot;&quot;} {print $1,$4}&apos; data2
Riley Mullen (312)555-1234
Frank Williams (317)555-9876
Haley Snell (313)555-4938
$ </code></pre><h4 id="22-1-2-自定义变量"><a href="#22-1-2-自定义变量" class="headerlink" title="22.1.2 自定义变量"></a>22.1.2 自定义变量</h4><p>gawk允许你定义自己的变量在程序代码中使用。gawk自定义变量名可以是任意数目的字母、数字和下划线，但不能以数字开头。重要的是，<strong>要记住gawk变量名区分大小写。</strong></p>
<pre><code>$ gawk &apos;
&gt; BEGIN{
&gt; testing=&quot;This is a test&quot;
&gt; print testing
&gt; }&apos;
This is a test
$ </code></pre><h3 id="22-2-处理数组"><a href="#22-2-处理数组" class="headerlink" title="22.2 处理数组"></a>22.2 处理数组</h3><h4 id="22-2-1-定义数组变量"><a href="#22-2-1-定义数组变量" class="headerlink" title="22.2.1 定义数组变量"></a>22.2.1 定义数组变量</h4><p>数组变量赋值的格式如下： <strong>var[index] = element</strong> 和传统语言有点区别，要注意index也可以为任意类型。 下面是一些gawk中数组变量的例子。</p>
<pre><code>capital[&quot;Illinois&quot;] = &quot;Springfield&quot;
capital[&quot;Indiana&quot;] = &quot;Indianapolis&quot;
capital[&quot;Ohio&quot;] = &quot;Columbus&quot; </code></pre><h4 id="22-2-2-遍历数组变量"><a href="#22-2-2-遍历数组变量" class="headerlink" title="22.2.2 遍历数组变量"></a>22.2.2 遍历数组变量</h4><p>重要的是记住这个变量中存储的是索引值而不是数组元素值。可以将这个变量用作数组的索引，轻松地取出数据元素值。</p>
<pre><code>$ gawk &apos;BEGIN{
&gt; var[&quot;a&quot;] = 1
&gt; var[&quot;g&quot;] = 2
&gt; var[&quot;m&quot;] = 3
&gt; var[&quot;u&quot;] = 4
&gt; for (test in var)
&gt; {
&gt; print &quot;Index:&quot;,test,&quot; - Value:&quot;,var[test]
&gt; }
&gt; }&apos;
Index: u - Value: 4
Index: m - Value: 3
Index: a - Value: 1
Index: g - Value: 2</code></pre><p>不像传统语言，索引值不会按任何特定顺序返回，但它们都能够指向对应的数据元素值。明白这点很重要，因为你不能指望着返回的值都是有固定的顺序，只能保证索引值和数据值是对应的。</p>
<h4 id="22-2-3-删除数组变量"><a href="#22-2-3-删除数组变量" class="headerlink" title="22.2.3 删除数组变量"></a>22.2.3 删除数组变量</h4><p>从关联数组中删除数组索引要用一个特殊的命令。 <strong>delete array[index]</strong></p>
<h3 id="22-3-使用模式"><a href="#22-3-使用模式" class="headerlink" title="22.3 使用模式"></a>22.3 使用模式</h3><p>和sed差不多，用正则表达式等进行匹配。</p>
<h3 id="22-4-结构化命令"><a href="#22-4-结构化命令" class="headerlink" title="22.4 结构化命令"></a>22.4 结构化命令</h3><h4 id="22-4-1-if语句"><a href="#22-4-1-if语句" class="headerlink" title="22.4.1 if语句"></a>22.4.1 if语句</h4><p>和脚本不一样，这里的if就像常规的编程语言，需要用花括号<code>{}</code>括起来。</p>
<pre><code>$ gawk &apos;{
&gt; if ($1 &gt; 20)
&gt; {
&gt; x = $1 * 2
&gt; print x
&gt; } else
&gt; {
&gt; &gt; x = $1 / 2
&gt; print x
&gt; }}&apos; data4
5
2.5
6.5
100
68
$ </code></pre><h4 id="22-4-2-while语句"><a href="#22-4-2-while语句" class="headerlink" title="22.4.2 while语句"></a>22.4.2 while语句</h4><p>和C语言一样。</p>
<h4 id="22-4-3-do-while语句"><a href="#22-4-3-do-while语句" class="headerlink" title="22.4.3 do-while语句"></a>22.4.3 do-while语句</h4><p>同上。</p>
<h4 id="22-4-4-for语句"><a href="#22-4-4-for语句" class="headerlink" title="22.4.4 for语句"></a>22.4.4 for语句</h4><p>支持C语言风格的for语句</p>
<pre><code>$ gawk &apos;{
&gt; total = 0
&gt; for (i = 1; i &lt; 4; i++)
&gt; {
&gt; total += $i
&gt; } </code></pre><h3 id="22-5-格式化打印"><a href="#22-5-格式化打印" class="headerlink" title="22.5 格式化打印"></a>22.5 格式化打印</h3><p>和<strong>C语言</strong>中printf的格式一样，可以指定整数或者字符。</p>
<pre><code>$ gawk &apos;BEGIN{
&gt; x = 10 * 100
&gt; printf &quot;The answer is: %e\n&quot;, x
&gt; }&apos;
The answer is: 1.000000e+03
$ </code></pre><h3 id="22-6-内建函数"><a href="#22-6-内建函数" class="headerlink" title="22.6 内建函数"></a>22.6 内建函数</h3><p>也有很多自带函数，和C语言库函数一样。比如sqrt等等。</p>
<h4 id="22-6-1-数学函数"><a href="#22-6-1-数学函数" class="headerlink" title="22.6.1 数学函数"></a>22.6.1 数学函数</h4><ul>
<li><code>atan2(x, y)</code> x/y的反正切，x和y以弧度为单位</li>
<li><code>cos(x)</code> x的余弦，x以弧度为单位</li>
<li><code>exp(x)</code> x的指数函数</li>
<li><code>int(x)</code> x的整数部分，取靠近零一侧的值</li>
<li><code>log(x)</code> x的自然对数</li>
<li><code>rand( )</code> 比0大比1小的随机浮点值</li>
<li><code>sin(x)</code> x的正弦，x以弧度为单位</li>
<li><code>sqrt(x)</code> x的平方根</li>
<li><code>srand(x)</code> 为计算随机数指定一个种子值</li>
</ul>
<h4 id="22-6-2-字符串函数"><a href="#22-6-2-字符串函数" class="headerlink" title="22.6.2 字符串函数"></a>22.6.2 字符串函数</h4><p>挑几个有用一点的。</p>
<ul>
<li><code>split(s, a [,r])</code> 将s用FS字符或正则表达式r（如果指定了的话）分开放到数组a中。返回字段的总数</li>
<li><code>index(s, t)</code> 返回字符串t在字符串s中的索引值，如果没找到的话返回0</li>
<li><code>length([s])</code> 返回字符串s的长度；如果没有指定的话，返回$0的长度</li>
<li><code>tolower(s)</code> 将s中的所有字符转换成小写</li>
</ul>
<h4 id="22-6-3-时间函数"><a href="#22-6-3-时间函数" class="headerlink" title="22.6.3 时间函数"></a>22.6.3 时间函数</h4><ul>
<li>mktime(datespec) 将一个按YYYY MM DD HH MM SS [DST]格式指定的日期转换成时间戳值</li>
<li>strftime(format[,timestamp]) 将当前时间的时间戳或timestamp（如果提供了的话）转化格式化日期（采用shell函数date()的格式）</li>
<li>systime( ) 返回当前时间的时间戳</li>
</ul>
<p>下面是在gawk程序中使用时间函数的例子。</p>
<pre><code>$ gawk &apos;BEGIN{
&gt; date = systime()
&gt; day = strftime(&quot;%A, %B %d, %Y&quot;, date)
&gt; print day
&gt; }&apos;
Friday, December 26, 2014
$ </code></pre><h3 id="22-7-自定义函数"><a href="#22-7-自定义函数" class="headerlink" title="22.7 自定义函数"></a>22.7 自定义函数</h3><p>要定义自己的函数，必须用function关键字。</p>
<pre><code>function name([variables])
{
statements
}</code></pre><p>其他的和常规语言一样，包括调用和编写库函数。</p>
<h2 id="23-总结"><a href="#23-总结" class="headerlink" title="23 总结"></a>23 总结</h2><blockquote>
<p>剩下的章节因为时间关系就不看了。</p>
</blockquote>
<p>通过对本书的系统性学习，发现Linux真的是太强大了，简简单单的命令就能操控一切。尤其是shell脚本编程，早该看到这本书的。以前命令每次忘记了还要去找，然后一大堆的cd vi。现在发现直接用脚本省事多了，熟悉之后真的很方便。</p>
<p>命令行这个东西还是不需要去死记硬背，用多了自然就会了，实在不会的也可以去查阅资料。而且学完本书，感觉自己对Linux的理解又上了一个层次。</p>
<p>编程语言果然是互通的，基本上学好C语言，上手其他语言真的很快，一些格式都是通用的。</p>
<p>看书的过程总的来说并不是相当仔细，现在回想一下有些内容已经忘了，需要做到系统的复习。我的计划是每周花半天时间去回顾之前所做的笔记，查漏补缺。其实最主要的还是需要一个实战的项目才能让自己成长的更快！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/11/arp-e5-8d-8f-e8-ae-ae/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/11/arp-e5-8d-8f-e8-ae-ae/" class="post-title-link" itemprop="url">ARP协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-11 03:24:01" itemprop="dateCreated datePublished" datetime="2018-05-11T03:24:01+08:00">2018-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h1><p><code>《TCP/IP详解 卷1：协议》``posts</code></p>
<ul>
<li><a href="#arp协议">ARP协议</a><ul>
<li><a href="#1-引言">1 引言</a></li>
<li><a href="#2-arp-帧格式">2 ARP 帧格式</a></li>
<li><a href="#3-arp的位置">3 ARP的位置</a></li>
<li><a href="#4-arp高速缓存">4 ARP高速缓存</a><ul>
<li><a href="#41-定义">4.1 定义</a></li>
<li><a href="#42-arp高速缓存的使用">4.2 ARP高速缓存的使用</a></li>
<li><a href="#43-arp高速缓存的优缺点">4.3 ARP高速缓存的优缺点</a></li>
</ul>
</li>
<li><a href="#5-免费arp">5 免费ARP</a></li>
<li><a href="#6-代理arp">6 代理ARP</a></li>
</ul>
</li>
</ul>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>如果一台主机要将一个帧发送到另一台主机，仅知道这台主机的IP地址是不够的，还需要知道主机在网络中的有<strong>有效硬件地址</strong>。操作系统软件必须知道目的主机的硬件地址，以便直接向它发送数据。对于TCP/IP网络，<strong>地址解析协议（ARP）</strong>提供了一种在<code>IPv4</code>地址和各种网络技术使用的硬件地址之间的<strong>映射</strong>。 ARP用于32为IPv4地址和以太网的48位MAC地址之间的映射。</p>
<h2 id="2-ARP-帧格式"><a href="#2-ARP-帧格式" class="headerlink" title="2 ARP 帧格式"></a>2 ARP 帧格式</h2><p>和TCP等差不多，ARP也有自己的格式。 <img src="http://tanwenbo.top/wp-content/uploads/2018/05/2392a0945708651d67d53f13fbc682a7.png" alt=""></p>
<p>字段</p>
<p>长度</p>
<p>作用</p>
<p>DST</p>
<p>6字节</p>
<p>以太网目的地址</p>
<p>SRC</p>
<p>6字节</p>
<p>以太网源地址</p>
<p>长度或类型</p>
<p>2字节</p>
<p>后面的数据类型，ARP请求和ARP应答这个值为0x0806</p>
<p>硬件类型</p>
<p>2字节</p>
<p>硬件地址不只以太网一种，是以太网类型时此值为1</p>
<p>协议类型</p>
<p>2字节</p>
<p>表示要映射的协议地址的类型，要对IPv4地址进行映射，此值为0x0800</p>
<p>硬件大小</p>
<p>1字节</p>
<p>硬件地址长度，MAC地址占6字节</p>
<p>协议大小</p>
<p>1字节</p>
<p>协议地址长度，IP地址占4字节</p>
<p>op</p>
<p>2字节</p>
<p>值为1，表示进行<code>ARP请求</code>；值为2，表示进行<code>ARP应答</code>；值为3，表示进行<code>RARP请求</code>；值为4，表示进行<code>RARP应答</code></p>
<p>发送端以太网地址</p>
<p>6字节</p>
<p>发送端ARP请求或应答的硬件地址，这里是以太网地址，和字段2相同</p>
<p>发送端IP地址</p>
<p>4字节</p>
<p>发送ARP请求或应答的IP地址</p>
<p>目的以太网地址</p>
<p>6字节</p>
<p>目的端的硬件地址</p>
<p>目的IP地址</p>
<p>4字节</p>
<p>目的端的协议地址</p>
<h2 id="3-ARP的位置"><a href="#3-ARP的位置" class="headerlink" title="3 ARP的位置"></a>3 ARP的位置</h2><p>OSI模型有七层，<code>TCP</code>在<code>第4层传输层</code>，<code>IP</code>在<code>第3层网络层</code>，而<code>ARP</code>在<code>第2层数据链路层</code>。高层对低层是有强依赖的，所以TCP的建立前要进行ARP的请求和应答。</p>
<h2 id="4-ARP高速缓存"><a href="#4-ARP高速缓存" class="headerlink" title="4 ARP高速缓存"></a>4 ARP高速缓存</h2><h3 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h3><p>ARP缓存是一个缓冲区，用来储存IP地址和MAC地址，本质就是<code>&lt;IP地址，MAC地址&gt;</code>的对应表。表中一个条目记录了网络上一个主机的IP地址和其对应的MAC地址。 当地址解析协议被询问一个已知IP地址节点的MAC地址时，先在ARP缓存中查看，若存在，就直接返回与之对应的MAC地址，若不存在，才发送ARP请求向局域网查询。</p>
<h3 id="4-2-ARP高速缓存的使用"><a href="#4-2-ARP高速缓存的使用" class="headerlink" title="4.2 ARP高速缓存的使用"></a>4.2 ARP高速缓存的使用</h3><p>当主机发送一个ARP请求时，先查看ARP高速缓存表，如果存在对应条目，则直接返回MAC地址，否则向局域网发送ARP请求广播。</p>
<h3 id="4-3-ARP高速缓存的优缺点"><a href="#4-3-ARP高速缓存的优缺点" class="headerlink" title="4.3 ARP高速缓存的优缺点"></a>4.3 ARP高速缓存的优缺点</h3><ul>
<li>优点：从ARP高速缓存的使用中可以看到，ARP高速缓存可以减小广播量，进而减小网络通信量，提高计算机之间的通信效率。</li>
<li>缺点：造成安全隐患（参考下面免费ARP的作用）。</li>
</ul>
<h2 id="5-免费ARP"><a href="#5-免费ARP" class="headerlink" title="5 免费ARP"></a>5 免费ARP</h2><p>免费ARP指主机发送ARP查找自己的IP地址，通常发生在系统引导期间进行接口配置时。与标准ARP的区别就是免费ARP分组的目的IP地址字段封装的是自己的IP地址，即向所在网络请求自己的MAC地址。</p>
<h2 id="6-代理ARP"><a href="#6-代理ARP" class="headerlink" title="6 代理ARP"></a>6 代理ARP</h2><p>代理ARP就是通过使用一个主机(通常为router)，来作为指定的设备使用自己的 MAC 地址来对另一设备的ARP请求作出应答。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/07/internet-e5-8d-8f-e8-ae-ae/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/07/internet-e5-8d-8f-e8-ae-ae/" class="post-title-link" itemprop="url">Internet 协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-07 02:32:55" itemprop="dateCreated datePublished" datetime="2018-05-07T02:32:55+08:00">2018-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Internet-协议"><a href="#Internet-协议" class="headerlink" title="Internet 协议"></a>Internet 协议</h1><p><code>《TCP/IP详解 卷1：协议》``TCP``posts</code></p>
<ul>
<li><a href="#internet-协议">Internet 协议</a><ul>
<li><a href="#1-引言">1 引言</a></li>
<li><a href="#2-ip数据报">2 IP数据报</a><ul>
<li><a href="#221-生存期ttl">2.2.1 生存期TTL</a></li>
<li><a href="#222-ip-fragment">2.2.2 IP Fragment</a><ul>
<li><a href="#标识">标识</a></li>
<li><a href="#标志">标志</a></li>
<li><a href="#分片偏移">分片偏移</a></li>
<li><a href="#任何一片数据的丢失需要上层重传整个报文">任何一片数据的丢失需要上层重传整个报文</a></li>
<li><a href="#例子">例子</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>IP是TCP/IP协议族中的核心协议。所有TCP、 UDP、 ICMP和IGMP数据都通过IP数 据报传输。 IP提供了一种尽力而为、无连接的数据报交付服务。 “尽力而为”的含义是不保 证IP数据报能成功到达目的地。虽然IP不是简单丢弃所有不必要流量,但它也不对自已尝 试交付的数据报提供保证。当某些错误发生时,例如一台路由器临时用尽缓冲区, IP提供一 个简单的错误处理方法‥ 丢弃一些数据(通常是最后到达的数据报)。任何可靠性必须由上 层(例如TCP)提供。IPv4和IPv6都使用这种尽力而为的基本交付模式。 接下来我们了解一下IP数据报的组成和其有何作用。</p>
<h2 id="2-IP数据报"><a href="#2-IP数据报" class="headerlink" title="2 IP数据报"></a>2 IP数据报</h2><p>数据报分为<code>IPv4</code>和<code>IPv6</code>，先看看<code>IPv4</code><strong>头部中的字段组成</strong> <img src="http://tanwenbo.top/wp-content/uploads/2018/05/79bb31093672f208d93e7b9ab4332da2.png" alt=""></p>
<p>字段</p>
<p>长度</p>
<p>含义</p>
<p>版本</p>
<p>4比特</p>
<p>包含IP数据报的版本号，IPv4为<code>4</code>，IPv6为<code>6</code></p>
<p>IHL</p>
<p>4比特</p>
<p>Internet头部长度，也就是首部长度由于它是一个4位的字段，所以IPv4头部被限制为最多15个32位字，即64字节（为什么头部又说是20字节？）</p>
<p>DS字段（区分服务）</p>
<p>6比特</p>
<p>本来这里应该是服务类型（TOS）字段，但是它们从未被广泛使用，因此最终这个8位长的字段被划分为2个部分。</p>
<p>ECN</p>
<p>2比特</p>
<p>显式拥塞通知字段或指示位</p>
<p>总长度</p>
<p>16比特</p>
<p>通过这个和IHL字段，我们可以知道数据报的数据部分从哪开始，以及它的长度。最大长度<code>65535字节</code></p>
<p>标识</p>
<p>16比特</p>
<p>IPv4软件在存储器中维持一个计数器，每产生一个数据报，计数器就加<code>1</code>，并将此值赋给标识字段</p>
<p>标志</p>
<p>3比特</p>
<p>目前只有两位有意义。<code>最低位M</code>为<code>1</code>表示后面“<code>还有分配</code>”的数据报，为<code>0</code>表示这已经是最后一个数据偏；<code>中间位</code>为<code>1</code>表示“<code>不能分片</code>”，为<code>0</code>才允许分片</p>
<p>分片偏移</p>
<p>13比特</p>
<p>指出较长的分组在分片后，该片在原分组的相对位置</p>
<p>生存期TTL</p>
<p>8比特</p>
<p>Time To Live，表示数据报在网络中的寿命，功能是“跳数限制”，防止分组在网络中无限期地转发</p>
<p>协议</p>
<p>8比特</p>
<p>指出数据报有效荷载部分的数据类型，最常用的值为<code>17（UDP）</code>和<code>6（TCP）</code></p>
<p>头部校验和</p>
<p>16比特</p>
<p>IPv4独有，数据报每经过一个设备，设备都要重新计算以下头部检验和，若头部未发生变化，则此结果必为0，于是就保留这个数据报。<strong>这个字段只检验数据报的首部，但不包括数据部分</strong></p>
<p>源IP地址</p>
<p>32比特</p>
<p>报文发送方的IPv4地址</p>
<p>目的地址</p>
<p>32比特</p>
<p>报文接收方的IPv4地址</p>
<p>选项</p>
<p>0~40字节</p>
<p>用来支持排错、测量以及安全等措施。在必要的时候插入值为0的填充字节</p>
<p>数据部分</p>
<p>可变</p>
<p>用来填充报文</p>
<h3 id="2-2-1-生存期TTL"><a href="#2-2-1-生存期TTL" class="headerlink" title="2.2.1 生存期TTL"></a>2.2.1 生存期TTL</h3><p>生存时间字段用来标识IP数据报在网络中传输的有效期，以秒来计数，占8位。最初的设计是以秒为单位，没经过一个路由器时，就在TTL（Time To Live）中减去数据报在路由器消耗掉的一段时间。若数据报在路由器消耗的时间小于1s，就把TTL值减1。TTL的建议值是<code>32s</code>，最长是<img src="http://tanwenbo.top/wp-content/uploads/2018/05/984ff4d54b80e3fc4c382edc3a1fb3dd." alt="">−1=<code>255s</code>。现在通常认为这个TTL是指数据报允许经过的路由器数，主要有以下几个功能：</p>
<ul>
<li>防止数据报在网络上回环；</li>
<li>由时间值变为为路由的跳数，跳数限制；</li>
<li>当每经过一个路由，跳数限制减1，当为0时丢弃这个数据报，ICMP Time Exceeded Messages包发送给该数据包的源地址。</li>
</ul>
<h3 id="2-2-2-IP-Fragment"><a href="#2-2-2-IP-Fragment" class="headerlink" title="2.2.2 IP Fragment"></a>2.2.2 IP Fragment</h3><p>IP分片由<strong>标识</strong>、<strong>标志</strong>和<strong>分片位移</strong>组成。</p>
<blockquote>
<p>IP fragmentation is an Internet Protocol (IP) process that breaks datagrams into smaller pieces (fragments), so that packets may be formed that can pass through a link with a smaller maximum transmission unit (MTU) than the original datagram size. The fragments are reassembled by the receiving host. ——来自Wikipedia</p>
</blockquote>
<p>IP分片通过IP协议将数据分成更小的碎片，所以数据包可以由带有最大传输单元的链路形成。 在很多链路层网络（比如以太网）中，携带高层协议PDU的帧大小是有限制的。链路层的这种特征被称为_最大传输单元_（<code>MTU</code>），如果IP需要发送一个数据报，并且这个数据报比链路层MTU大，则IP通过<strong>分片</strong>将数据报分解成较小的部分，使每个分片都小于MTU。</p>
<h4 id="标识"><a href="#标识" class="headerlink" title="标识"></a>标识</h4><p>每个IP包的唯一值，相同的分片标识相同</p>
<h4 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h4><p>0</p>
<p>DF</p>
<p>MF</p>
<ul>
<li>DF：Don’t Fragment<ul>
<li>0，可以分片</li>
<li>1，不可分片，出错时发送ICMP</li>
</ul>
</li>
<li>MF：More Fragmen<ul>
<li>0，最后一个分片</li>
<li>1，还有更多的分片在后面</li>
</ul>
</li>
</ul>
<h4 id="分片偏移"><a href="#分片偏移" class="headerlink" title="分片偏移"></a>分片偏移</h4><p>标识本包在整个数据包中的位置，以8字节为单位。</p>
<h4 id="任何一片数据的丢失需要上层重传整个报文"><a href="#任何一片数据的丢失需要上层重传整个报文" class="headerlink" title="任何一片数据的丢失需要上层重传整个报文"></a>任何一片数据的丢失需要上层重传整个报文</h4><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>假设MTU为1300Bytes，现在有一个数据包为3280Bytes要传输。</p>
<p>MF</p>
<p>Offset</p>
<p>data</p>
<p>0</p>
<p>0</p>
<p>3280B</p>
<p>那么将会切割为3部分：</p>
<p>MF</p>
<p>Offset</p>
<p>data</p>
<p>1</p>
<p>0</p>
<p>1280B</p>
<p>1</p>
<p>160</p>
<p>1280B</p>
<p>0</p>
<p>320</p>
<p>720B</p>
<p>之所以是1280B，因为数据头占20B；MF不解释；Offset因为占8个字节，而<img src="http://tanwenbo.top/wp-content/uploads/2018/05/e6c4b48b54d9485cafde9bfbad242f39." alt="">)，那么下一分片的位移就是<img src="http://tanwenbo.top/wp-content/uploads/2018/05/30b369ac934c184e8cf9ae24d89d27b8." alt="">，依次累加。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/e3-80-8a-e7-bc-96-e7-a0-81checklist-e8-a7-84-e8-8c-83-e3-80-8b-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/02/e3-80-8a-e7-bc-96-e7-a0-81checklist-e8-a7-84-e8-8c-83-e3-80-8b-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0/" class="post-title-link" itemprop="url">《编码checklist规范》学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-02 06:45:35" itemprop="dateCreated datePublished" datetime="2018-05-02T06:45:35+08:00">2018-05-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="《编码checklist规范》学习笔记"><a href="#《编码checklist规范》学习笔记" class="headerlink" title="《编码checklist规范》学习笔记"></a>《编码checklist规范》学习笔记</h1><p><code>《编码checklist规范》``posts</code></p>
<ul>
<li><a href="#编码checklist规范学习笔记">《编码checklist规范》学习笔记</a><ul>
<li><a href="#0-前言">0 前言</a></li>
<li><a href="#1-排版">1 排版</a><ul>
<li><a href="#10-总则">1.0 总则</a></li>
<li><a href="#11-缩进">1.1 缩进</a></li>
<li><a href="#12-语句行">1.2 语句行</a></li>
<li><a href="#13-大括号">1.3 大括号</a><ul>
<li><a href="#范例">范例</a></li>
</ul>
</li>
<li><a href="#14-代码行长度">1.4 代码行长度</a></li>
</ul>
</li>
<li><a href="#2-注释">2 注释</a><ul>
<li><a href="#20-总则">2.0 总则</a></li>
<li><a href="#21-声明注释">2.1 声明注释</a></li>
<li><a href="#22-语句注释">2.2 语句注释</a><ul>
<li><a href="#范例-1">范例</a></li>
</ul>
</li>
<li><a href="#23-废弃代码">2.3 废弃代码</a></li>
</ul>
</li>
<li><a href="#3-标识符">3 标识符</a><ul>
<li><a href="#30-总则">3.0 总则</a></li>
<li><a href="#31-命名风格">3.1 命名风格</a></li>
<li><a href="#32-命名要求">3.2 命名要求</a></li>
<li><a href="#33-文件名">3.3 文件名</a></li>
<li><a href="#34-魔数">3.4 魔数</a><ul>
<li><a href="#示例">示例</a></li>
</ul>
</li>
<li><a href="#35-变量名称和用途匹配">3.5 变量名称和用途匹配</a></li>
<li><a href="#36-减小标识符的作用域和可见性">3.6 减小标识符的作用域和可见性：</a><ul>
<li><a href="#示例-1">示例</a></li>
</ul>
</li>
<li><a href="#37-函数声明">3.7 函数声明</a></li>
</ul>
</li>
<li><a href="#4-函数">4 函数</a><ul>
<li><a href="#40-总则">4.0 总则</a></li>
<li><a href="#41-函数规模">4.1 函数规模</a></li>
<li><a href="#42-函数参数">4.2 函数参数</a></li>
<li><a href="#43-返回值">4.3 返回值</a></li>
<li><a href="#44-const使用">4.4 const使用</a></li>
<li><a href="#45-重复代码提炼成函数">4.5 重复代码提炼成函数：</a></li>
<li><a href="#46-格式化字符串的变参函数定义">4.6 格式化字符串的变参函数定义</a></li>
</ul>
</li>
<li><a href="#5-宏定义">5 宏定义</a><ul>
<li><a href="#51-命名">5.1 命名</a></li>
<li><a href="#52-括号使用">5.2 括号使用</a></li>
<li><a href="#53-宏参数">5.3 宏参数</a></li>
<li><a href="#54-减少宏使用">5.4 减少宏使用</a></li>
<li><a href="#55-防止命名冲突">5.5 防止命名冲突</a></li>
</ul>
</li>
<li><a href="#6-结构体">6 结构体</a><ul>
<li><a href="#60-总则">6.0 总则</a></li>
<li><a href="#61-结构体对齐">6.1 结构体对齐</a></li>
<li><a href="#62-保证数据结构在跨平台时的二进制兼容性">6.2 保证数据结构在跨平台时的二进制兼容性：</a></li>
<li><a href="#63-变长结构体">6.3 变长结构体</a></li>
</ul>
</li>
<li><a href="#7语句">7语句</a><ul>
<li><a href="#70-总则">7.0 总则</a></li>
<li><a href="#71-括号使用">7.1 括号使用</a></li>
<li><a href="#72-goto使用限制">7.2 goto使用限制：</a></li>
<li><a href="#73-循环性能优化">7.3 循环性能优化：</a></li>
<li><a href="#74-不使用复杂表达式">7.4 不使用复杂表达式：</a></li>
<li><a href="#75-switchcase语句">7.5 switch/case语句：</a></li>
<li><a href="#76-控制结构ifforwhileswitch等的嵌套">7.6 控制结构(if/for/while/switch等)的嵌套：</a></li>
</ul>
</li>
<li><a href="#8-错误处理">8 错误处理</a><ul>
<li><a href="#80-总则">8.0 总则</a></li>
<li><a href="#81-参数合法性检测">8.1 参数合法性检测</a></li>
<li><a href="#82-数据合法性检查">8.2 数据合法性检查：</a></li>
<li><a href="#83-断言要求">8.3 断言要求：</a></li>
<li><a href="#84-return-返回值检查">8.4 “return - 返回值检查：</a></li>
</ul>
</li>
<li><a href="#9-资源管理">9 资源管理</a><ul>
<li><a href="#90-总则">9.0 总则</a></li>
<li><a href="#91-防止泄露">9.1 防止泄露：</a></li>
<li><a href="#92-使用配套的资源释放函数释放资源重点">9.2 使用配套的资源释放函数释放资源（重点）</a></li>
<li><a href="#93-避免重复释放">9.3 避免重复释放：</a></li>
<li><a href="#94-勿混用内存管理方法">9.4 勿混用内存管理方法：</a></li>
<li><a href="#95-标准输入输出错误的关闭">9.5 标准输入、输出、错误的关闭：</a></li>
</ul>
</li>
<li><a href="#10-内存">10 内存</a><ul>
<li><a href="#100-总则">10.0 总则</a></li>
<li><a href="#101-变量初始化">10.1 变量初始化</a></li>
<li><a href="#102-指针算术">10.2 指针算术：</a></li>
<li><a href="#103-结构体比较">10.3 结构体比较：</a></li>
<li><a href="#104-字符串比较">10.4 字符串比较：</a></li>
<li><a href="#105-防常量字符串修改">10.5 防常量字符串修改：</a></li>
<li><a href="#106-字符串格式化">10.6 字符串格式化：</a></li>
<li><a href="#107-防止字符串缺结束符">10.7 防止字符串缺结束符</a></li>
<li><a href="#108-字符串长度计算">10.8 字符串长度计算：</a></li>
<li><a href="#109-变量大小偏移计算">10.9 变量大小、偏移计算：</a></li>
<li><a href="#1010-c99的变长数组和alloca">10.10 C99的变长数组和alloca：</a></li>
<li><a href="#1011-字符串转整数浮点数">10.11 字符串转整数/浮点数：</a></li>
</ul>
</li>
<li><a href="#11-并发">11 并发</a><ul>
<li><a href="#110-总则">11.0 总则</a></li>
<li><a href="#111-信号处理">11.1 信号处理</a></li>
<li><a href="#112-信号处理函数">11.2 信号处理函数</a></li>
<li><a href="#113-不暴力终止线程">11.3 不暴力终止线程</a></li>
<li><a href="#114-wait-子进程子线程的后事处理">11.4 wait - 子进程/子线程的后事处理</a></li>
<li><a href="#115-互斥锁的使用">11.5 互斥锁的使用</a></li>
<li><a href="#116-锁定区域内睡眠">11.6 锁定区域内睡眠</a></li>
<li><a href="#117-非递归锁的使用">11.7 非递归锁的使用：</a></li>
<li><a href="#118-死锁">11.8 死锁</a></li>
<li><a href="#119-线程创建">11.9 线程创建</a></li>
<li><a href="#1110-需要同步的访问">11.10 需要同步的访问：</a></li>
</ul>
</li>
<li><a href="#12-危险的库特性">12 危险的库特性</a><ul>
<li><a href="#120-总则">12.0 总则：</a></li>
<li><a href="#121-错误号获取">12.1 错误号获取</a></li>
<li><a href="#122-不混用文件机制">12.2 不混用文件机制</a></li>
<li><a href="#123-不使用不安全函数">12.3 不使用不安全函数：</a></li>
</ul>
</li>
<li><a href="#13-危险的语言特性">13 危险的语言特性</a><ul>
<li><a href="#130-总则">13.0 总则</a></li>
<li><a href="#131-自增自减运算">13.1 自增/自减运算：</a></li>
<li><a href="#132-参数顺序依赖性">13.2 参数顺序依赖性：</a></li>
<li><a href="#133-char类型使用">13.3 char类型使用：</a></li>
<li><a href="#134-除0错误预防包括求余运算">13.4 除0错误预防(包括求余运算）：</a></li>
<li><a href="#135-指针转换">13.5 指针转换：</a></li>
<li><a href="#136-移位运算">13.6 移位运算：</a></li>
</ul>
</li>
<li><a href="#14-工具检查">14 工具检查</a><ul>
<li><a href="#140-总则">14.0 总则：</a></li>
<li><a href="#141-cppcheck">14.1 cppcheck：</a></li>
<li><a href="#142-ctest需编译">14.2 c++test(需编译)：</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><p>在学习完《C陷阱与缺陷》后，发现了很多以前没有注意到的错误，比如：字符串与字符的区别，指针函数与函数指针的区别等等。《C陷阱与缺陷》是本值得收藏、反复观看的书籍。 本书《Checklist编码规范》与《C陷阱与缺陷》相辅相成，好的编码规范在编程中能减少很多你难以预料到的BUG，显著提高代码质量。</p>
<blockquote>
<p><strong>文中加粗的部分是我自认为比较重要且以前没有注意的部分。</strong></p>
</blockquote>
<h2 id="1-排版"><a href="#1-排版" class="headerlink" title="1 排版"></a>1 排版</h2><h3 id="1-0-总则"><a href="#1-0-总则" class="headerlink" title="1.0 总则"></a>1.0 总则</h3><p>总则： 统一清晰的排版可以帮助代码阅读者迅速聚焦代码的关键逻辑，迅速定位区块的开始结束位置，大大提高代码阅读的效率。主要注意以下几点：</p>
<ol>
<li>排版风格在同一文件中，必须保持统一；</li>
<li>尽量把关系密切的逻辑集中在一起，保证视线无需漂移即可浏览到整个逻辑单元；</li>
<li>在尚未养成习惯之前，可采用astyle之类的工具软件格式化代码；</li>
</ol>
<h3 id="1-1-缩进"><a href="#1-1-缩进" class="headerlink" title="1.1 缩进"></a>1.1 缩进</h3><blockquote>
<p>代码的缩进可以说是编程的灵魂了，良好的代码缩进阅读起来十分方便，但是如果没有缩进，代码压根不能看！</p>
</blockquote>
<p>程序块要采用统一的缩进和对齐风格编写。整个项目中或者是<code>4</code>个空格，或者是一个<code>TAB</code>。不允许混用这两种。 如果是使用<code>TAB</code>，需保证<code>TAB</code>键的宽度是<code>4</code>个空格（）。 如果是在原有代码上修改（如Linux内核代码），需和原有代码的缩进、对齐方式保持一致。 建议在编辑器设置中将TAB键宽度设置为4（大多数编辑器都有这个设置），建议统一使用空格进行对齐。</p>
<ul>
<li><p>缩进要求：</p>
<ul>
<li>if else case for while语句需要缩进；</li>
<li>case语句与所属的switch语句对齐；</li>
<li>所有{}需要缩进，extern “”C”“, namespace 块除外，case语句除外。</li>
</ul>
</li>
<li><p>空格使用：</p>
<ul>
<li>关键字 if else switch case for while 之后要加空格；</li>
<li>如果<code>，；</code>后面没有立即换行, 即后面有变量或语句时, 要在后面加空格，<strong>类似for循环<code>for(int a = 1; a &lt; 100; a++)</code>每个条件后都加了空格；</strong></li>
<li><strong>小括号内侧不能有空格</strong>, 函数调用(或宏)的名字与括号之间<strong>不能有空格</strong>；</li>
<li><strong>一元</strong>操作符 <code>&amp; * + - ~ ! ++ --</code> 要紧贴对应的<strong>变量</strong>，<strong>不能有空格</strong>；</li>
<li><strong>二元</strong>操作符 <code>= + - * / % &amp; | ^ == != &gt;= &lt;= &gt; &lt; ? :</code> 两侧<strong>要加空格</strong>；</li>
<li>结构体成员操作符 <code>. -&gt;</code> <strong>前后不加空格</strong>。</li>
</ul>
</li>
</ul>
<p>规范示例：</p>
<pre><code>缩进的范例代码：
struct string_t {
    int len;
    char data[0];
};
//注意大括号的写法，但个人习惯这样写。其实大多数IDE都为你设置好了编码风格，但是如果用linux等就要自己注意了。
struct string_t 
{
    int len;
    char data[0];
};
//-----------------------
#ifdef __cplusplus
extern &quot;C&quot; {
#endif

struct string_t *create_string(int max_len);
struct string_t *copy_string(const char *str);
void release_string(struct string_t *str);

#ifdef __cplusplus
}
#endif

struct string_t *copy_string(const char *str)
{
    int len = strlen(str) + sizeof(struct string_t) + 1;

    struct string_t *pstr = (struct string_t *)malloc(len);
    if (!pstr)
        return NULL;

    pstr-&gt;len = len - sizeof(struct string_t) - 1;
    strcpy(pstr-&gt;data, str);
    return pstr;
}

switch (state) {
case STATE_CONNECT:
    ...
    break;
case STATE_LOGIN:
    ...
    break;
case STATE_NORMAL:
    ...
    break;
default:
    break;
}

for (i = 0; i &lt; cnt; ++i) {
    if (arr[i] &gt; value) {
        list_add(list, arr[i]);
    }
} </code></pre><h3 id="1-2-语句行"><a href="#1-2-语句行" class="headerlink" title="1.2 语句行"></a>1.2 语句行</h3><p>一行只写一条语句，不允许把多个短语句写在一行中。大多数以分号<code>；</code>算作一条语句。</p>
<h3 id="1-3-大括号"><a href="#1-3-大括号" class="headerlink" title="1.3 大括号"></a>1.3 大括号</h3><p>大括号是编码中的灵魂，没有大括号就没有作用域。具体规范如下：</p>
<ul>
<li><p><code>}</code> 必须独占一行，有两种例外：</p>
<ul>
<li>如果是在if(…){}else if(…){}else{}中，可与else放同一行；</li>
<li>如果是在do{}while(…)中，可与while放同一行；</li>
</ul>
</li>
<li><p><code>{</code></p>
<p>可以独占一行，且与上一语句的起始位置对齐。 也可以跟在相应的if、for、do、while、switch、class声明、函数声明后面；</p>
</li>
<li><p><code>{</code>,<code>}</code> 的相对位置在整个模块中必须保持一致。 if、for、do、while、switch这几种语句块的<code>{</code>必须保持相对位置一致。 其他语句块的<code>{</code>只要求在同类型之间保持相对位置一致即可。</p>
</li>
</ul>
<h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><p><strong>以下这段代码符合checklist要求：</strong></p>
<pre><code>int find_split(const char* str)
{
    assert(str);
    int len = strlen(str);
    for (int i = 0 ; i &lt; len ; ++i) {
        if (str[i] == &apos;,&apos; || str[i] == &apos;.&apos;) {
            return i;
        }
    }
    return -1;
}</code></pre><p><strong>以下这几段代码不符合checklist要求：</strong></p>
<ul>
<li><p>if语句和for语句的<code>{</code>相对位置不一致<strong>（要统一，不要两种风格并存）</strong></p>
<p>int find_split(const char* str)<br>{</p>
<pre><code>assert(str);
int len = strlen(str);
for (int i = 0 ; i &lt; len ; ++i) {
    if (str[i] == &apos;,&apos; || str[i] == &apos;.&apos;) 
    {
        return i;
    }
}
return -1;</code></pre><p>}</p>
</li>
</ul>
<ul>
<li><p><code>{</code>没有和上一语句的起始位置对齐</p>
<p>int find_split(const char* str)<br>{</p>
<pre><code>assert(str);
int len = strlen(str);
for (int i = 0 ; i &lt; len ; ++i) 
  {
    if (str[i] == &apos;,&apos; || str[i] == &apos;.&apos;) 
      {
        return i;
      }
  }
return -1;</code></pre><p>} </p>
</li>
</ul>
<h3 id="1-4-代码行长度"><a href="#1-4-代码行长度" class="headerlink" title="1.4 代码行长度"></a>1.4 代码行长度</h3><p>每行代码不应超过80列。 如果某些行需要超出80列（比如调用win32 API时，由于API参数过多，往往会超出80列），应该折成多行显示。 <strong>例外条款：</strong></p>
<ul>
<li>注释可以例外；</li>
<li>如果字符串单独占一行仍超出80列，可以例外；</li>
</ul>
<h2 id="2-注释"><a href="#2-注释" class="headerlink" title="2 注释"></a>2 注释</h2><p>注释对代码来说十分重要，可以使阅读代码的人能很好的理解代码。好的注释显得尤其重要，因为若干年后，代码作者可能自己都看不懂自己当年所写的代码是什么意思。</p>
<h3 id="2-0-总则"><a href="#2-0-总则" class="headerlink" title="2.0 总则"></a>2.0 总则</h3><p>注释的目的是提升代码可读性，帮助代码读者更快速的了解代码作者的实际意图。</p>
<ul>
<li><p>注释应重点阐述目的，而非过程；</p>
</li>
<li><p>注释应重点阐述隐性知识，<strong>即代码无法直接反映的意图、原则，如扩展方法，锁策略，内存分配限制等等</strong>；</p>
</li>
<li><p>注释应重点阐述模块/函数之间的关联知识。 即对比分析多个函数才能得到的知识，比如：</p>
<ul>
<li><strong>参数及返回值的含义、约束；</strong></li>
<li><strong>外部数据的含义、取值范围；</strong></li>
<li><strong>函数/模块之间的协作关系；</strong></li>
<li><strong>多个变量/函数之间的相互关系；</strong></li>
<li>……</li>
</ul>
</li>
<li><p><strong>注释应避免描述显而易见的知识，比如：“这是一个构造函数”，“定义一个整型变量”；</strong></p>
</li>
<li><p>注释内容需要和代码实际行为保持一致，不应涉及无关内容，如“今天天气很好”，“checklist规定这里要注释”；</p>
</li>
<li><p>注释需要及时更新，反映代码当前的状态，否则反而误导代码读者； 本条款为阐述、建议性条款；</p>
</li>
</ul>
<h3 id="2-1-声明注释"><a href="#2-1-声明注释" class="headerlink" title="2.1 声明注释"></a>2.1 声明注释</h3><blockquote>
<p>变量的声明很重要，是对变量含义的进一步解释，而不是只是知道其是什么类型。平时自己写注释最多写下函数的作用，一般很少写的那么详细。但是长久来说这是值得的。</p>
</blockquote>
<p>主要注意以下几点：</p>
<ul>
<li><strong>文件头</strong>：在头文件(<em>.h，</em>.hpp，*.inc等）和源文件头部应注释说明该其功能；</li>
<li><strong>函数头</strong>：函数头部应注释说明其功能及各参数、返回值的含义(无参构造函数、析构函数、重载的运算符函数可无需注释)；</li>
<li><strong>全局变量</strong>：全局变量应注释说明其功能；</li>
<li><strong>常量</strong>: 所有常量定义都应注释说明其功能；</li>
<li><strong>类型</strong>：所有类型定义(包括struct,class,enum,union)，都应注释说明其功能；</li>
<li><strong>宏定义</strong>：所有宏定义应注释说明其功能，如果宏有参数，必须说明参数的用法；</li>
</ul>
<p><strong>注释采用doxygen的注释标准。方便根据注释直接生成说明文档。范例请参考:</strong></p>
<ul>
<li><p><strong>文件头注释范例：</strong></p>
<p>/*<br>  功能：本文件定义文件列表的接口，文件列表是个存储文件路径名和文件信</p>
<pre><code>息的列表，本文件提供了文件列表的存储、读取、定位、访问等接口。</code></pre><p>  日期：2011-3-4<br>  作者：zbc<br>*/<br>#ifndef FILELIST_H_<br>#define FILELIST_H_<br>…<br>#endif //FILELIST_H_</p>
</li>
</ul>
<ul>
<li><p><strong>函数头注释范例：</strong></p>
<p>/**</p>
<ul>
<li>发送数据给服务器</li>
<li>@param [in]buf  数据缓冲区指针</li>
<li>@param len   数据长度</li>
<li>@return &lt;0表示失败，否则表示实际发送成功的字节数</li>
<li>@sample</li>
<li>int len = send_buf(buf, buflen);</li>
<li>if (len &lt; 0) {</li>
<li>DUMP(“send failed, errno: %x\n”, len);</li>
<li>return -1;</li>
<li>} else {</li>
<li>DUMP(“send ok, already send %d bytes.\n”, len);</li>
<li>}</li>
<li>/<br>int send_buf(const char* buf, int len);</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>类型定义注释：</strong></p>
<p>/**</p>
<ul>
<li>文件列表类</li>
<li>@remark</li>
<li>可用于记录系统所缓存的所有小文件，该列表可存在磁盘上</li>
<li>@note</li>
<li>/<br>class filelist {<br>…<br>};</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>全局变量注释：</strong></p>
<p>1）<br>char g_log_fname[MAX_PATH]; //日志文件的路径名称，从配置文件中读取得到<br>2）<br>//日志文件的路径名称，从配置文件中读取得到<br>char g_log_fname[MAX_PATH]; </p>
</li>
</ul>
<ul>
<li><p><strong>宏注释：</strong></p>
<p>/**</p>
<ul>
<li>释放内存，并把指针清零，防止重复释放</li>
<li>@param ptr 内存块指针，只允许传入malloc/remalloc/strdup等</li>
<li>C库函数分配的内存块指针</li>
<li>/<br>#define FREE_ZERO(ptr)         <br>do{                            <br>  if (!(ptr)) {              \<pre><code>free(ptr);             \
ptr = NULL;            \</code></pre>  }                          <br>}while(0)</li>
</ul>
<p>//  最大的缓冲区长度<br>#define MAX_BUF_SIZE 200 </p>
</li>
</ul>
<h3 id="2-2-语句注释"><a href="#2-2-语句注释" class="headerlink" title="2.2 语句注释"></a>2.2 语句注释</h3><blockquote>
<p>主要是对控制结构进行注释，因为具体的跳转如果只通过代码就有点难理解</p>
</blockquote>
<p>在下述控制结构处应按要求进行注释。语句块少于5行允许例外。</p>
<ul>
<li>if语句的各个分支，注释说明条件和具体功能；</li>
<li>for/while/do的头部，注释说明循环条件和具体功能；</li>
<li>switch头部，注释说明判断条件和具体功能；</li>
</ul>
<h4 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h4><ul>
<li><p><strong>if 语句注释：</strong></p>
<p>// 将buf中保存的消息发送给CGI进程<br>ret = send(sk, buf, datalen, 0);<br>if (ret &lt; 0) {                // 没有发送成功</p>
<pre><code>LOGDBG(&quot;send failed, errno: %d\n&quot;, errno);</code></pre><p>} else if (ret == 0) {        // 对端关闭</p>
<pre><code>LOGDBG(&quot;send failed, peer shutdown\n&quot;);</code></pre><p>} else {                      // 发送成功</p>
<pre><code>LOGDBG(&quot;send ok, length: %d\n&quot;, ret);</code></pre><p>}</p>
</li>
</ul>
<ul>
<li><p><strong>for 语句注释：</strong></p>
<p>// 遍历文件列表，直到找到名字为filename的文件对象，或列表遍历完毕<br>for (int i = 0 ; i &lt; cnt ; ++i) {</p>
<pre><code>if (strcmp(filename, filelists[i]-&gt;name) == 0)
    return i;</code></pre><p>}</p>
</li>
</ul>
<ul>
<li><p><strong>while/do…while 语句注释：</strong></p>
<p>// 将所有用户配置文件打包<br>pdir = opendir(“/var/sangfor”);<br>if (!pdir) {</p>
<pre><code>...
return -1;</code></pre><p>}<br>// 遍历/var/sangfor目录下所有配置文件(*.conf)，通过tar命令将其打到压缩包<br>while ((pcur = readdir(pdir)) != NULL) {</p>
<pre><code>...</code></pre><p>} </p>
</li>
</ul>
<h3 id="2-3-废弃代码"><a href="#2-3-废弃代码" class="headerlink" title="2.3 废弃代码"></a>2.3 废弃代码</h3><p>确定不适用的功能代码要删除，或者通过注释和<code>#if 0</code>关闭。</p>
<pre><code>#if 0   
    code
#endif</code></pre><p><code>#if</code>适用于较长的代码，且如果想让code生效，只需要把<code>#if 0</code>改为<code>#if 1</code>。但是千万不要把#if 0 来当作块注释使用， #if 1可以让其间的变量成为<code>局部变量</code>。</p>
<h2 id="3-标识符"><a href="#3-标识符" class="headerlink" title="3 标识符"></a>3 标识符</h2><p>变量命名相当重要，对代码的可读性至关重要。如果你写的代码所定义的变量都是<code>a、b、c</code>，那么谁知道其代表什么意思呢？一般的变量命名都是用英文单词，不熟悉英文的会用拼音或者拼音缩写代替。</p>
<h3 id="3-0-总则"><a href="#3-0-总则" class="headerlink" title="3.0 总则"></a>3.0 总则</h3><p>标识符声明的终极目的是达到“代码即文档”的效果。 所谓“代码即文档”，即由代码本身清晰的反映出作者的意图。 其中，最关键的就是利用标识符给一段代码/一段数据打个“标签”，说明这段代码是用来干嘛的，或者这段数据是用来干嘛的。</p>
<ul>
<li><p><strong>标识符的命名应反映目的，而非过程；</strong></p>
</li>
<li><p><strong>作用域越大，影响逻辑越多的标识符，其取名越完整。作用域越小、影响面越小的标识符，其取名越简练。</strong></p>
<ul>
<li><strong>如循环变量可使用无特殊含义的单字符i进行命名；</strong></li>
</ul>
</li>
<li><p>标识符的命名规则应当统一；</p>
</li>
<li><p>命名中不应包含对理解代码意图无帮助的部分，如：个人姓名，无意义字符等；</p>
</li>
</ul>
<h3 id="3-1-命名风格"><a href="#3-1-命名风格" class="headerlink" title="3.1 命名风格"></a>3.1 命名风格</h3><p>命名风格在同一模块中统一。有三种风格可供选择：</p>
<ul>
<li>UNIX的全小写加下划线的风格,如：<strong>create_file</strong>；</li>
<li>匈牙利命名法(大小写混排),如：<strong>CreateFile</strong>；</li>
<li>Java风格，如 <strong>createFile</strong>。</li>
</ul>
<p>就本人而言，一般会匈牙利命名法和java风格混用。</p>
<h3 id="3-2-命名要求"><a href="#3-2-命名要求" class="headerlink" title="3.2 命名要求"></a>3.2 命名要求</h3><p>标识符使用1个或多个英文单词或其缩写进行命名。要求：</p>
<ul>
<li>不使用拼音；</li>
<li>不使用无意义的字母组合；</li>
<li>除循环变量可使用i、j、k，指针变量可使用p之外，不使用单字符的名字；</li>
<li><strong>不使用下划线开头；</strong></li>
<li><strong>非静态全局变量使用<code>g_</code>开头；</strong></li>
<li><strong>静态全局变量使用<code>s_</code>开头；</strong></li>
<li><strong>类成员变量使用<code>m_</code>开头，等同于C结构体的（没成员函数的）可以例外，union可以例外；</strong></li>
<li>局部变量不加前缀；”</li>
</ul>
<p>全局变量的命名学习了，还有类成员的，怪不得经常看到m开头的命名。</p>
<h3 id="3-3-文件名"><a href="#3-3-文件名" class="headerlink" title="3.3 文件名"></a>3.3 文件名</h3><p>使用include包含的文件名全部使用小写。Windows界面相关的代码文件允许例外。</p>
<blockquote>
<p>也就是说头文件定义一般用小写，而不是大写。这个我之前一直用错了。</p>
</blockquote>
<h3 id="3-4-魔数"><a href="#3-4-魔数" class="headerlink" title="3.4 魔数"></a>3.4 魔数</h3><blockquote>
<p>用常量代替数字，比如定义数组长度，用max代表，而不是在需要定义数组长度的时候写数字。</p>
</blockquote>
<p>不允许使用0,1,-1之外的魔数，有需要用到数字的地方，请用命名常量代替。 如果作为标识（比如状态标识）时，0,1,-1也不允许直接使用。 所谓<strong>魔数</strong>，指以字面值形式出现的数值常量（不包括字符串常量），比如3，-4，256，3.14，0.628。 <strong>作为特例，以下情形是允许的：</strong></p>
<ul>
<li>初始化一个变量时允许使用魔数，如<code>int num = 20；timeval tv = {10, 10};</code></li>
<li>定义替代魔数的命名常量时允许使用魔数,如<code>#define PI 3.14；</code></li>
<li>该魔数代表参数个数,且该参数个数无法通过sizeof等方法测量得到；（请参考注释）</li>
<li><code>0、-1</code>如果作为返回值，分别代表正常、出错，是允许的。<code>1、0</code>作为布尔值表示真、假，也是允许的。</li>
<li>作为<strong>位运算</strong>或其他算法的固有参数时，允许使用魔数，但需注释说明；</li>
<li>该魔数只跟当前语句有关(<strong>即无需与模块其它代码保持一致</strong>），且替换为标识符常量后对代码可读性没有明显提升，则允许直接使用魔数；</li>
</ul>
<p>定义标识符常量替代魔数的原则是该标识符必须包含更丰富的信息，以提升代码可读性。 典型的可以指明上下文，指明常量的含义（如：USRCFG_USERNAME_MAXSIZE，指在用户配置中用到的用户名的最大长度） <strong>以下命名方式是常见的误区：</strong></p>
<ul>
<li>直接在标识符常量中出现魔数本身，如：<code>#define BUFSIZE_128 128</code></li>
<li>使用含糊的语义，如：<code>#define LEN 128</code></li>
<li>把字符串常量也当成魔数，如：<code>#define MKDIR_ERROR_STR &quot;&quot;mkdir error, errno(%d):%s\n&quot;&quot;&quot;</code></li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>所谓魔数: 指以字面值形式出现的数值常量。</p>
<ul>
<li><p><strong>不可以这样：</strong></p>
<p>return 2;<br>ouble area = 3.14<em>radius</em>radius;<br>mkdir(usrcfg_fname, 0660);  //创建文件，并指定权限，有时候别人不知道0660是什么意思，具体可看linux文件权限码</p>
</li>
</ul>
<ul>
<li><p><strong>可以这样：</strong></p>
<p>1) 在头文件中有常量的统一定义：</p>
<pre><code>const int EOUTMEM = 2;  或#define EOUTMEM 2</code></pre><p>   使用时引用已经定义好的常量：</p>
<pre><code>return EOUTMEM;</code></pre><p>2) #define PI 3.14</p>
<pre><code>double area = PI*radius*radius;</code></pre><p>3) #define USRCFG_UGO_RW_RW_NONE 0660</p>
<pre><code>mkdir(usrcfg_name, USRCFG_UGO_RW_RW_NONE);</code></pre></li>
</ul>
<ul>
<li><p>作为特例，允许使用魔数的情形：</p>
<ul>
<li>魔数代表参数个数：</li>
</ul>
<p>int ret = sscanf(sz, “%u.%u.%u.%u”, &amp;ip1, &amp;ip2, &amp;ip3, &amp;ip4);<br>if (ret != 4) {</p>
<pre><code>printf(&quot;read ip failed\n&quot;);</code></pre><p>}<br>//该代码中，4代表读取到的参数个数。</p>
<p>int sum(int num, int para1, …);<br>int val = sum(3, num1, num2, num3);</p>
<p>//该代码中，3代表传给sum的待累加的参数的个数。</p>
</li>
</ul>
<ul>
<li><p>魔数代表位运算的固有参数：</p>
<p>ret = (val &gt;&gt; 4) &amp; 0xff; //取val的4到8位<br>size = (size + 3) / 4 * 4; //4字节对齐 </p>
</li>
</ul>
<h3 id="3-5-变量名称和用途匹配"><a href="#3-5-变量名称和用途匹配" class="headerlink" title="3.5 变量名称和用途匹配"></a>3.5 变量名称和用途匹配</h3><p>主要是不要取无意义或无厘头的变量名</p>
<ul>
<li>变量的名字和实际用途相符，不使用和实际用途完全无关或相反的命名；</li>
<li>在变量的作用域内，一个变量不用作多个用途；（请参考注释）</li>
<li>如果变量有多个取值范围，且各取值范围代表不同意思，须保证各个取值范围之间不得有重叠；（请参考注释）</li>
</ul>
<p>1) 完全无关的命名： 比如：<code>count</code>用于表示颜色； 2) 名字和用途相反： 比如：<code>free_cnt</code>用于表示当前存活的对象数目；<strong>应该是当前释放的对象数目</strong> 3) 一个变量多个用途： 一个实际引起了BUG的例子：value既作为入参表示哈希值，又作为出参，表示是否成功。</p>
<pre><code>#define HASH_INSERT(hash_table, node, value, type)  \
    do {                                            \
        node-&gt;pre = NULL;                           \
        node-&gt;pnext = NULL;                         \
        unsigned int h_i_i = value % HASH_SIZE;     \
        if (hash_table[h_i_i] != NULL &amp;&amp;            \
            hash_table[h_i_i]-&gt;key != node-&gt;key) {  \
            ...                                     \
        }else if (hash_table[h_i_i] == NULL) {      \
            hash_table[h_i_i] = node;               \
        } else {                                    \
            value = 0;                              \
        }                                           \
    } while (0);</code></pre><p>4) 同一个用途，多次使用是允许的，如：</p>
<pre><code>int ret = 0;
ret = init_pools();
ret = init_threads();
ret = init_plugins();   
//都表示初始化是否成功</code></pre><p>5) 不同取值范围代表不同意思，比如:</p>
<pre><code>int find_string(const vector&lt;string&gt;&amp; lst, const char* name);</code></pre><p>find_string的功能是从字符串列表中查找是否存在字符串name，当返回值<code>大于0</code>时，表示name在字符串列表lst中的索引，<code>==0</code>表示未找到，<code>&lt;0</code>时查找过程出错，并指示出错类型。 如果0也是列表的合法索引值，则find_string违反了本条款的第3项，即：取值范围有重叠，0既可能是索引值，也可能代表没找到。</p>
<h3 id="3-6-减小标识符的作用域和可见性："><a href="#3-6-减小标识符的作用域和可见性：" class="headerlink" title="3.6 减小标识符的作用域和可见性："></a>3.6 减小标识符的作用域和可见性：</h3><p>1) <strong>不允许在头文件中定义非静态全局变量，仅仅声明除外，例子见批注；</strong> 2) <strong>不被别的编译单元访问的全局变量，必须声明为静态全局变量</strong>（即必须在定义和声明前加static修饰） 3) <strong>不被别的编译单元访问的函数</strong>，必须加上<code>static</code>声明； 4) <strong>不被别的类访问的成员函数</strong>，必须声明为<code>private</code>函数； 5) <strong>只被派生类访问的成员函数</strong>，必须声明为<code>protected</code>函数； 如确有必要违反以上2、3、4、5项条款，注释说明清楚原因后可以例外。</p>
<blockquote>
<p>有时候严格一点效果可能更好，这一段是必须记住的。</p>
</blockquote>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><ul>
<li><p>全局变量定义:</p>
<p>int g_debug;<br>int g_debug = 1;</p>
</li>
</ul>
<ul>
<li><p>全局变量声明：</p>
<p>extern int g_debug;</p>
</li>
</ul>
<ul>
<li><p>静态全局变量：</p>
<p>static int s_debug; </p>
</li>
</ul>
<h3 id="3-7-函数声明"><a href="#3-7-函数声明" class="headerlink" title="3.7 函数声明"></a>3.7 函数声明</h3><blockquote>
<p>在头文件里写声明，在c/cpp里写定义</p>
</blockquote>
<p>1) 函数声明必须和函数定义的保持原型一致； 2) 引用其它模块或<code>.c/.cpp</code>文件提供的有外部链接特性的函数(extern函数)， 应使用include头文件的方式引用其函数声明，不允许自行声明，<strong>不允许在.c/.cpp中直接声明</strong>； 3) 提供给.c文件使用的函数声明，必须放在extern “”C”” {}域内，并通过<strong>宏防止问题</strong>（见注释）；”</p>
<ul>
<li><p>提供给c模块使用的函数原型声明：</p>
<p>#ifdef __cplusplus<br>extern “C” {<br>#endif</p>
<p>void foo(int xxx, int yyy);</p>
<p>#ifdef __cplusplus<br>}<br>#endif </p>
</li>
</ul>
<h2 id="4-函数"><a href="#4-函数" class="headerlink" title="4 函数"></a>4 函数</h2><p>函数定义的好坏直接决定代码的质量，良好的软件设计应遵循<strong>“高内聚，低耦合”</strong>，函数的设计也应遵循此原则。</p>
<h3 id="4-0-总则"><a href="#4-0-总则" class="headerlink" title="4.0 总则"></a>4.0 总则</h3><p>函数是控制代码复杂度的最有效工具。 函数可以隔绝两段代码之间的相互影响，约束两段代码之间只能通过参数/返回值/全局变量来传递影响。 函数通过函数名给一段代码“打标签”，能帮助读者快速了解代码片段的意图，提升代码可读性；</p>
<ul>
<li><strong>使用工具评估代码复杂度</strong>，常用的有SourceMonitor、CCCC等，常用的用于评价函数复杂度的指标有代码行数、圈复杂度等；</li>
<li><strong>降低函数参数个数</strong>，有助于提高函数的易用性，且降低函数实现的复杂度；</li>
<li><strong>减少函数内部相互作用的变量个数</strong>，有助于降低函数的复杂度；</li>
<li><strong>尽可能保证函数功能单一性</strong>，不做完全无关的两件事情，不做和函数名没有关系的事情；</li>
<li><strong>使用统一的错误处理模型</strong>，有助于提高代码易读性，精简代码的同时避免错误；</li>
<li><strong>时刻关注代码的冗余度</strong>，相似代码越多，意味着逻辑抽象程度越差，应想办法将相似逻辑提炼成函数；</li>
</ul>
<h3 id="4-1-函数规模"><a href="#4-1-函数规模" class="headerlink" title="4.1 函数规模"></a>4.1 函数规模</h3><p>一个函数不超过100行，工具自动生成的除外。对既有的第三方代码（比如内核代码）进行修改可例外（新增函数依然不得超过100行）。</p>
<blockquote>
<p>想起了以前自己写的函数，基本上功能丰富一点的都要超过好几百行了吧，应该把一些功能切割开来，实现低耦合！</p>
</blockquote>
<h3 id="4-2-函数参数"><a href="#4-2-函数参数" class="headerlink" title="4.2 函数参数"></a>4.2 函数参数</h3><ul>
<li>函数调用传递大对象（超过8个字节大小，或者其构造函数会分配资源）时不使用按值传递。<strong>返回值允许例外</strong>。（<strong>也就是引用传递，直接引用原来的对象；返回值例外就是在函数里再定义一个对象，然后将其返回</strong>）</li>
<li><strong>不允许在函数参数中使用布尔类型</strong>(包括使用数值类型仿制的布尔类型）。<strong>如有需要用到这类标志性参数，可用枚举代替，或者分拆成多个函数实现</strong>，具体见示例。</li>
<li><strong>函数参数中不得定义数组参数</strong>，应使用指针代替数组。请注意：如果参数是数组的指针不违反本条款。（也就是C缺陷里的数组即指针），如果数组定义没有指定数组长度，也可例外，如：<code>int main(int argc, char *argv[])</code></li>
<li>函数参数个数<code>不超过5</code>个(&lt;=5)。</li>
</ul>
<p><strong>建议：</strong> 建议拆分函数功能，分成多个函数实现，这样每个函数功能更简单，参数更少。 如果内部没有复杂逻辑，可以通过结构体指针传参。 <strong>以下函数声明违反checklist:</strong></p>
<pre><code>1) void func(string name)；
//应该直接用引用，不要按值传递
2) struct record {
    int type;
    int len;
    char data[16];
};
void send_record(record rec);
//这个好像没什么问题啊</code></pre><p>注2： 函数参数中使用布尔类型，会使代码更难以理解，如：</p>
<pre><code>UpdateData(TRUE)
CreateProcess(chPath, &quot;&quot;, NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, &amp;pi)</code></pre><p>如果不是对这些函数非常熟悉，你知道这些TRUE，FALSE代表什么意思吗？</p>
<pre><code>如果改为UpdateData(SAVE_VALIDATE)，CreateProcess(chPath, &quot;&quot;, NULL, NULL, NO_INHERIT_HANDLE, 0, NULL, NULL, &amp;si, &amp;pi)会不会好一点？

改造方法：

UpdateData是MFC函数，原型如下：
BOOL UpdateData(BOOL bSaveAndValidate);

下述修改方法都可以提高UpdateData的可读性：

1）分拆成两个函数实现
BOOL UpdateData();
BOOL UpdateData_SaveAndValidate();

2）将bSaveAndValidate参数改造成枚举
enum SaveAndValidate_e{
    SAVE_VALIDATE,
    NO_SAVE_VALIDATE
};
BOOL UpdateData(enum SaveAndValidate_e eSave);
这样，在调用这个函数时就有一个名字了,可以通过枚举的名字更好的理解这个函数调用的意思，如：UpdateData(SAVE_VALIDATE);</code></pre><p><strong>多使用枚举代替ture和false！</strong></p>
<pre><code>void test_arr_copy(int arr[ARRAY_SIZE])
{
    int buf[ARRAY_SIZE];
    memcpy(buf, arr, sizeof(arr));
}</code></pre><p>以上代码违反子条款3，sizeof(arr)的结果为sizeof(int)，而非sizeof(int)*ARRAY_SIZE 可改为：</p>
<pre><code>void test_arr_copy(int *arr)
{
...
}</code></pre><p>以下函数定义不违反本条款（因为p是指向数组的指针，而非数组）：</p>
<pre><code>void test_arr_copy(int (*p)[ARRAY_SIZE]); </code></pre><h3 id="4-3-返回值"><a href="#4-3-返回值" class="headerlink" title="4.3 返回值"></a>4.3 返回值</h3><blockquote>
<p>一般自己使用返回值都是返回函数里定义的局部变量，原来这是不行的。</p>
</blockquote>
<ul>
<li><strong>不返回本函数内定义的非静态局部变量的地址</strong>（包括以指针或引用形式返回）。也不允许通过出参或全局变量、类成员变量的方式返回；</li>
<li>在linux平台，如果返回值是int/short/long,且用于标识出错，<strong>则统一使用&lt;0表示出错，&gt;=0表示成功。</strong>回调函数等有约束的函数可以例外(比如main的返回值)；</li>
<li>返回值为BOOL类型的函数，只允许返回TRUE和FALSE两种取值；</li>
<li><strong>在函数返回值中使用的函数指针，必须使用typedef定义的别名。</strong>（不容易出现歧义） <strong>比如：</strong></li>
</ul>
<pre><code>typedef int (*PfnScanner)();
PfnScanner get_scanner(const char *name);
//指向返回值为int类型的函数的指针 </code></pre><h3 id="4-4-const使用"><a href="#4-4-const使用" class="headerlink" title="4.4 const使用"></a>4.4 const使用</h3><blockquote>
<p>在使用const的时候要对其十分了解，不然会出现错误。</p>
</blockquote>
<ul>
<li><p>函数参数：</p>
<ul>
<li>对于指针或引用参数，如果函数内部<strong>不改变该参数的值</strong>且<strong>不调用需要该参数为左值（通俗点说就是可以放在赋值运算符左边的变量）的函数</strong>，则<strong>必须在该参数定义前加const修饰</strong>。</li>
<li>钩子函数（回调函数）如果需要和指定的函数原型保持一致可以例外（比如：定时器函数，消息处理函数，qsort的回调函数等）。</li>
</ul>
</li>
</ul>
<blockquote>
<p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>
</blockquote>
<ul>
<li><p>如果该函数需要返回一个依赖某参数的指针，而这个指针可能被其它函数用来改写数据，则认为这个被依赖的参数是个非const参数，不需要const修饰。例子见注释。</p>
</li>
<li><p>非静态成员函数： 对于非静态成员函数，如果<strong>函数内部不修改普通成员变量</strong>（<strong>没有</strong>用<code>static</code>及<code>mutable</code>修饰的成员变量），则必须声明该函数为const成员函数（在参数列表后加const）。 下列情形可以例外：</p>
<ul>
<li>构造、析构、重载操作符函数；</li>
<li>作为钩子或回调函数使用；</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code>void print(const char *buf, size_t len);

//成员函数，如：
int ini::find(const char* name) const;

//返回一个依赖参数的可写指针：
msg_hdr *get_hdr(char *buf)
{
    return (msg_hdr *)buf;
}
void get_hdr(char *buf, msg_hdr **hdr)
{
    *hdr = (msg_hdr *)buf;
} </code></pre><h3 id="4-5-重复代码提炼成函数："><a href="#4-5-重复代码提炼成函数：" class="headerlink" title="4.5 重复代码提炼成函数："></a>4.5 重复代码提炼成函数：</h3><p>超过5行（不算空白行、注释行、只有大括号的行）的重复代码应提炼成<strong>函数</strong>（特殊情况也可提炼为宏）。 如有效率要求，可将函数内联。重复代码，指满足以下所有条件的代码块：</p>
<ul>
<li>出现次数超过2次；</li>
<li>去除分隔符（比如空白符、大括号、注释等）以后，只有变量名字或常量内容不同；”</li>
</ul>
<h3 id="4-6-格式化字符串的变参函数定义"><a href="#4-6-格式化字符串的变参函数定义" class="headerlink" title="4.6 格式化字符串的变参函数定义"></a>4.6 格式化字符串的变参函数定义</h3><p>如果需要定义类似于printf的拥有可变参数列表、能格式化输出字符串的函数，需要在函数声明中加上<strong>检查参数有效性的属性声明</strong>，如下：</p>
<pre><code>void my_print(int fd, const char *fmt, ...) __attribute__((format(printf, 2, 3))); </code></pre><h2 id="5-宏定义"><a href="#5-宏定义" class="headerlink" title="5 宏定义"></a>5 宏定义</h2><h3 id="5-1-命名"><a href="#5-1-命名" class="headerlink" title="5.1 命名"></a>5.1 命名</h3><p>除非有特殊理由，否则宏使用全大写加下划线的方式命名。（有特殊理由的须注释说明原因）</p>
<h3 id="5-2-括号使用"><a href="#5-2-括号使用" class="headerlink" title="5.2 括号使用"></a>5.2 括号使用</h3><blockquote>
<p>因为宏是直接替换代码，所以一定要用括号规避运算符优先级的问题</p>
</blockquote>
<ul>
<li>用宏定义表达式时，要使用完备的括号。保证该宏的所有可能的使用方法(即包含潜在的某些使用方法）都不会发生运算符优先级问题；</li>
<li>如果宏定义中包含多条语句或者包含有if语句，须将这些语句放在大括号中，建议使用do{…}while(0)的形式；</li>
</ul>
<h3 id="5-3-宏参数"><a href="#5-3-宏参数" class="headerlink" title="5.3 宏参数"></a>5.3 宏参数</h3><p>使用宏时，不允许参数中出现会发生副作用（即会改变某些变量的值或程序的运行环境）的表达式。 比如不允许使用<code>MAX(++a, b+=2)</code>。在《C缺陷》里也有讨论到这个问题。</p>
<h3 id="5-4-减少宏使用"><a href="#5-4-减少宏使用" class="headerlink" title="5.4 减少宏使用"></a>5.4 减少宏使用</h3><p>如果能通过下述方式替代宏，且程序功能不会发生变化，则不允许使用宏：</p>
<ul>
<li>C++的常量定义或枚举；（注：C++常量和枚举都可用作编译期常量，用于数组长度定义等需要编译期常量的场合）</li>
<li>函数或内联函数；（注：需要性能保证的多条语句可以封装成内联函数）”</li>
</ul>
<h3 id="5-5-防止命名冲突"><a href="#5-5-防止命名冲突" class="headerlink" title="5.5 防止命名冲突"></a>5.5 防止命名冲突</h3><p>宏内部如果需要定义局部变量,必须防止该变量和上下文中的变量名字冲突，建议加上特殊前缀或后缀。 Gcc编译器开启-Wshadow后对该问题会产生警告，需消除。” 例如：</p>
<pre><code>//遍历列表

#define foreach_list(list, func)                    \
    do {                                            \
        int i;                                      \
        int cnt = list_size(list);                  \
        for (i = 0 ; i &lt; cnt ; ++i) {               \
            func(list, i);                          \
        }                                           \
    } while (0)

//假如调用者用法如下，就可能发生错误：
for (i = 0 ; i &lt; cnt ; ++i) {
    foreach_list(&amp;lists[i], do_print_list);
}

//经过宏替换后，代码如下：
for (i = 0 ; i &lt; cnt ; ++i) {
    do {
        int i;
        int cnt = list_size(&amp;lists[i]);
        for (i = 0 ; i &lt; cnt ; ++i) {
            do_print_list(&amp;lists[i], i);
        }
    } while (0);
}
/*由于内层作用域定义的名字自动屏蔽外层定义的名字，编译器不会报错。
这样一来，原本foreach_list(&amp;lists[i],do_print_list)是想访问外层的i，但经宏替换后实际访问到的i却是内层定义的，张冠李戴，岂不糟糕？*/</code></pre><p>解决办法是－－给宏内部定义的局部变量加特殊前缀或后缀， 如：将<code>int i;int cnt;</code>改为<code>int i_;int cnt_;</code></p>
<h2 id="6-结构体"><a href="#6-结构体" class="headerlink" title="6 结构体"></a>6 结构体</h2><h3 id="6-0-总则"><a href="#6-0-总则" class="headerlink" title="6.0 总则"></a>6.0 总则</h3><p>结构体(struct)和联合体(union)提供一种按名字访问数据块中数据内容的能力。使用结构体/联合体，可以让代码更具可维护性，且有助于让代码跨平台。为了更大的发挥各平台的性能，编译器在排布结构体/联合体中的数据成员时，可能在各变量间插入一些“垫片”数据，使得每个变量都做到对齐访问。这些“隐形”的“垫片”，可能导致访问未初始化数据问题（如memcmp比较两个结构体）。</p>
<h3 id="6-1-结构体对齐"><a href="#6-1-结构体对齐" class="headerlink" title="6.1 结构体对齐"></a>6.1 结构体对齐</h3><blockquote>
<p>结构体对齐的问题在面试中经常会被问道，需要十分注意</p>
</blockquote>
<ul>
<li><p>保证结构体(C++类也一样）至少是4字节对齐的。 长度大等于2的成员的偏移位置必须能被2整除，长度大等于4的成员的偏移位置必须能被4整除。另：如果不强行指定对齐方式，编译器默认会将所有结构体对齐，即可满足本条款；</p>
</li>
<li><p>需要跨进程传递的结构体，必须保证<code>pack(1)</code>和<code>pack(4)</code>编译后是一样的内存结构（即各成员的偏移是一样的）。</p>
<ul>
<li>如果结构体中含有64位(如double,long long)的数据成员，必须保证<strong>pack(1)</strong>和<strong>pack(8)</strong>编译后是一样的内存结构；</li>
<li>有一个技巧可以较容易达到这个要求，<strong>即结构内成员按成员的对齐系数(alignment modulus)从大到小的顺序排列。</strong></li>
<li><strong>结构体类型的成员的对齐系数是该结构体各成员对齐系数的最大值。</strong></li>
</ul>
</li>
</ul>
<p>具体对齐原则可见其他笔记。</p>
<h3 id="6-2-保证数据结构在跨平台时的二进制兼容性："><a href="#6-2-保证数据结构在跨平台时的二进制兼容性：" class="headerlink" title="6.2 保证数据结构在跨平台时的二进制兼容性："></a>6.2 保证数据结构在跨平台时的二进制兼容性：</h3><p>需要在异构平台上传递的结构，不直接使用随平台不一样而导致长度不一的数据类型,如：int,long,unsigned long；</p>
<blockquote>
<p>long在32位是占2个字节，而在64位占4个</p>
</blockquote>
<p>可使用在不同平台保持长度一致的各种类型别名，如：<code>int32_t,U32,WORD</code></p>
<h3 id="6-3-变长结构体"><a href="#6-3-变长结构体" class="headerlink" title="6.3 变长结构体"></a>6.3 变长结构体</h3><p>变长结构体，指那种含有元素个数可变的数组成员的结构体。</p>
<ul>
<li>长度可变的数组成员必须是结构体的最后一个成员；</li>
<li>如果该数组成员的元素个数定义为0，则结构体大小并不包含该数组成员的大小；</li>
<li>该结构体必须使用动态分配，并预留足够的内存空间（该结构体大小加上数组成员的大小）；</li>
<li>该结构体必须是POD（plain old data）类型，具体原因请参考注释；</li>
</ul>
<blockquote>
<p>POD就是C语言自带的变量，而不是string之类的类，是int，short等</p>
</blockquote>
<p>如果结构体不充当变长结构体使用（比如只访问结构体前面固定长度字段），则可以例外。</p>
<ul>
<li><p>变长结构体的大小：</p>
<p>struct port_group{<br>   unsigned int cnt;<br>   unsigned short ports[0];<br>};</p>
</li>
</ul>
<p>上述结构体中，ports成员的大小为0，所以整个结构体的大小<code>sizeof(struct port_group) == sizeof(unsigned int)</code>。</p>
<ul>
<li><p>变长结构体必须动态计算长度和分配内存，直接定义变量是有问题的。如下代码会造成运行时错误：</p>
<p>void fun()<br>{</p>
<pre><code>struct port_group pg;
pg.cnt = 1;
pg.ports[0] = 1;</code></pre><p>}</p>
</li>
</ul>
<ul>
<li><p>变长结构体分配：</p>
<p>struct port_group *create_port_group(size_t port_cnt)<br>{</p>
<pre><code>size_t size = sizeof(struct port_group) + sizeof(unsigned short) * port_cnt;
struct port_group *p = (struct port_group *)calloc(1, size);
if (!p){
    return p;
}
p-&gt;cnt = port_cnt;
return p;</code></pre><p>}</p>
</li>
</ul>
<ul>
<li><p>变长结构体必须是POD（plain old data）类型，以下结构体定义是有问题的:</p>
<p>struct port_group{</p>
<pre><code>std::string name;
unsigned int cnt;
unsigned short ports[0];</code></pre><p>};</p>
</li>
</ul>
<p>因为port_group必须使用类似<code>malloc</code>的方法分配内存，name得不到初始化，需要使用placement new 的方法才能正常初始化，很麻烦。</p>
<h2 id="7语句"><a href="#7语句" class="headerlink" title="7语句"></a>7语句</h2><h3 id="7-0-总则"><a href="#7-0-总则" class="headerlink" title="7.0 总则"></a>7.0 总则</h3><p>对C&amp;C++语句使用的一些约束，主要目的是降低语句复杂度，帮助代码阅读者更容易理解代码的意思。</p>
<h3 id="7-1-括号使用"><a href="#7-1-括号使用" class="headerlink" title="7.1 括号使用"></a>7.1 括号使用</h3><p>括号的使用永远是编码风格必须讨论的东西。 <strong>以下情况必须使用括号明确表达式优先级：</strong></p>
<ol>
<li>同时出现 &amp;、^、| 这三种运算符中的任意两种（或&amp;、^同时出现两次）；</li>
<li>同时出现位运算符（&amp; ^ |）和比较运算符(&lt; &lt;= &gt; &gt;= == !=)</li>
<li>同时出现&amp;&amp;和||；</li>
<li>同时出现移位运算符(&lt;&lt; &gt;&gt;)和比较运算符(&lt; &lt;= &gt; &gt;= == !=)</li>
<li>同时出现比较运算符中(&lt; &lt;= &gt; &gt;= == !=)的任意两种（或一种出现两次）；</li>
<li>同时出现位运算符(&amp; ^ |)和逻辑运算符(&amp;&amp; ||)；</li>
<li>同时出现移位运算符(&lt;&lt; &gt;&gt;)和算术运算符(+ - * / %)</li>
</ol>
<p><strong>如果一个上述运算符没有同时出现在一个操作数（或高优先级表达式）的两边，可以不做要求。</strong> <strong>不符合要求：</strong></p>
<ul>
<li>if (op_bits &amp; OP_READ &amp;&amp; op_bits &amp; OP_WRITE) &amp;和&amp;&amp;同时出现在OP_READ的两边</li>
<li>if (1 &gt; mid != max) &gt;和!=同时出现在mid的两边</li>
<li>ret = op_bits | OP_READ &amp; OP_MASK; |和&amp;同时出现在操作数OP_READ的两边；</li>
<li>ret = op_bits | (g_def_opbits &amp; 0xffff) &amp; OP_MASK; |和&amp;同时出现在高优先级表达式(g_def_opbits&amp;oxffff)的两边；</li>
<li>if (pb == 0 || len == 0 &amp;&amp; pe == 0) ||和&amp;&amp;同时出现在高优先级表达式len == 0的两边；</li>
</ul>
<p><strong>符合要求：</strong></p>
<ul>
<li>if ((op_bits &amp; OP_READ) &amp;&amp; (op_bits &amp; OP_WRITE)) 以上表达式已使用括号明确了优先级</li>
<li>if (mid &gt;= min &amp;&amp; mid &lt; max) 以上表达式中&gt;= 和 &lt;没有同时出现在某个高优先级表达式的两边，中间的&amp;&amp;运算符优先级比较低。</li>
<li>if (p &amp;&amp; p &lt; pEnd &amp;&amp; p &gt; pBegin + 1)</li>
</ul>
<h3 id="7-2-goto使用限制："><a href="#7-2-goto使用限制：" class="headerlink" title="7.2 goto使用限制："></a>7.2 goto使用限制：</h3><ul>
<li>只允许在同一个块作用域内跳转，或者跳转到上层的块作用域。</li>
<li>不得用于跳转到更深的块作用域或者其它平行的块作用域。</li>
<li>不允许使用goto在switch的多个case语句/default语句之间跳转；</li>
</ul>
<blockquote>
<p>迪杰斯特拉说要取消goto，编程这么久了还没用过goto这个语句</p>
</blockquote>
<p>例如：下述代码是不符合要求的。</p>
<pre><code>if (ok)
   goto ready;
func();
while(1){
ready:
//…
} </code></pre><h3 id="7-3-循环性能优化："><a href="#7-3-循环性能优化：" class="headerlink" title="7.3 循环性能优化："></a>7.3 循环性能优化：</h3><p>可以在循环体外进行的耗时计算不放入循环体中。” <strong>反例：</strong></p>
<pre><code>for(int i = 0; i &lt; lst.count(); ++i) {
    printf(&quot;%d&quot;, lst[i]);
}               </code></pre><p>注：lst是虚拟的一个list类，具有链表的含义，有count（利用遍历求链表长度）和operator[]（遍历取指定位置成员）两个成员函数。此例会导致count不必要的重复计算，时间复杂度O(n*n). 类似的还有下面这段代码：</p>
<pre><code>for(int i = 0; i &lt; strlen(str); ++i) {
    if (str[i] == &apos; &apos;) {
        break;
    }
}</code></pre><p><strong>学习了，以后针对这种应该在循环外定义一个变量，只计算一次，减少开销。</strong></p>
<h3 id="7-4-不使用复杂表达式："><a href="#7-4-不使用复杂表达式：" class="headerlink" title="7.4 不使用复杂表达式："></a>7.4 不使用复杂表达式：</h3><p>不使用过于复杂的表达式，如确实有必要这样写须注释说明该表达式的意思。鼓励把复杂表达式分拆成多句书写。虽然能减少代码量，但是生涩难懂对看代码的人来说是种负担</p>
<ul>
<li>所谓过于复杂的表达式，指一个运算数某一边的运算符个数大等于2个。 单目运算符+，-，<em>，!，~，&amp;，sizeof及括号[]，()不计算在内。 如：**</em>stat_poi ++ += 1<strong>；应拆分成*</strong>stat_poi += 1;++stat_poi；**</li>
<li><code>?:</code>运算符不允许嵌套使用，如：ret = a &lt; b ? (a &lt; c ? a : c) : (b &lt; c ? b : c);[2012-9-6]”</li>
</ul>
<h3 id="7-5-switch-case语句："><a href="#7-5-switch-case语句：" class="headerlink" title="7.5 switch/case语句："></a>7.5 switch/case语句：</h3><ul>
<li>每个<code>case</code>语句必须以<code>break</code>语句(或continue/goto/return/longjmp/exit等流程转移语句)结束。 如果不需要<code>break</code>，必须在末尾注释说明。《C陷阱》里也有提到。 如果该<code>case</code>标签后没有任何处理语句可以例外。没有处理语句的多个case标签可以写在一行；</li>
<li>每个switch语句都必须要有default标签；</li>
</ul>
<p>例如：</p>
<pre><code>switch (*pch) {
case &apos;:&apos;: case &apos;-&apos;:
    ...
    break;
case &apos;\0&apos;:
    return;
case &apos;%&apos;:
    ...
    /* no break */
default:
    ++pch;
    break;
} </code></pre><h3 id="7-6-控制结构-if-for-while-switch等-的嵌套："><a href="#7-6-控制结构-if-for-while-switch等-的嵌套：" class="headerlink" title="7.6 控制结构(if/for/while/switch等)的嵌套："></a>7.6 控制结构(if/for/while/switch等)的嵌套：</h3><blockquote>
<p>有时候条件查询又不得不用到多层嵌套，也可以用&amp;&amp;等将其提拉到平级控制</p>
</blockquote>
<ul>
<li>不使用过深的嵌套：循环嵌套不超过3层，总共不超过5层；</li>
<li>如果if子句和else子句行数相差超过3行，须保证else子句比if子句长。 如果该条件语句有多个条件，可以例外（即存在else if子句）。 建议使用短路返回的方法减少嵌套层数；</li>
</ul>
<p><strong>不合格嵌套：</strong></p>
<pre><code>for(int row = 0; row &lt; rowcnt; ++row) {
    for(int col = 0; col &lt; colcnt; ++col) {
        char *pname = g_pool[row][col].name;
        for(int i = 0; i &lt; MAX_NAME_LEN; ++i) {
            char ch = pname[i];
            for(int j = 0; j &lt; PREDEF_TABU_SIZE; ++j) {
                if (ch == g_predef_tabu[j]) {
                    return false;
                }
            }
            ...
        }  
    }
}</code></pre><p><strong>可以改造为：</strong></p>
<pre><code>inline bool is_tabu(char c)
{
    for(int j = 0; j &lt; PREDEF_TABU_SIZE; ++j) {
        if (ch == g_predef_tabu[j]) {
            return true;
        }
    }
    return false;
}
for(int row = 0; row &lt; rowcnt; ++row) {
    for(int col = 0; col &lt; colcnt; ++col) {
        char *pname = g_pool[row][col].name;
        for(int i = 0; i &lt; MAX_NAME_LEN; ++i) {
            char ch = pname[i];
            if (is_tabu(ch))
                return false;
            ...
        }  
    }
}</code></pre><p><strong>短路返回</strong></p>
<pre><code>if (match_condition()) {
    ... ...
    if (...)
        ... ...
} else {
    break;
}</code></pre><p><strong>改为以下语句就是短路返回:</strong></p>
<pre><code>if (!match_condition())
    break;
... ...
if (...)
    ... ... </code></pre><h2 id="8-错误处理"><a href="#8-错误处理" class="headerlink" title="8 错误处理"></a>8 错误处理</h2><h3 id="8-0-总则"><a href="#8-0-总则" class="headerlink" title="8.0 总则"></a>8.0 总则</h3><p>异常，无处不在。异常处理的完善程度，决定了代码的健壮程度。 有些异常需要在设计方案层面善加考虑，有些异常，却仅仅需要局部的关注、处理，就能得到很好的效果。异常是会传播和扩散的，城门失火，殃及池鱼。而且，一些关键信息会在异常传播过程中丢失，导致异常难以定位。所以，异常处理应遵守九字原则：早检查、勤记录、早处理。及早发现异常，记录上下文，处理异常，可以及早定位解决问题，并防止异常造成更大的破坏。 如果严谨的遵守以下checklist条款，在对程序进行逻辑分析时，就可以在局部聚焦正常数据、流程，无需关注其它逻辑引发的异常数据蔓延。也更不容易在代码维护过程中破坏一些假设条件，引入bug。</p>
<h3 id="8-1-参数合法性检测"><a href="#8-1-参数合法性检测" class="headerlink" title="8.1 参数合法性检测"></a>8.1 参数合法性检测</h3><p>主要集中在外部接口和内部函数</p>
<blockquote>
<p>外部接口：指会被其它模块调用的函数； 内部函数：指不会被其他模块调用的函数；</p>
</blockquote>
<ul>
<li><p>外部接口（指函数）在使用参数前需检查参数合法性。</p>
<ul>
<li>不使用该参数或该参数的任何取值都是合法值不会引起程序异常可以例外。</li>
<li>参数有效性检查不要用断言等只在调试版本生效的方法。</li>
<li>应当保证在release版本下检查处理措施依然有效，在发现不合法的参数时执行错误处理(比如返回标识错误的值，抛出异常,执行错误处理流程），保证程序健壮性。</li>
</ul>
</li>
<li><p>所有内部函数的函数入口处必须通过断言检查所有参数的合法性。</p>
<ul>
<li>不使用该参数或该参数的所有取值都是合法值，可以不检查该参数。</li>
</ul>
</li>
<li><p>无论外部接口还是内部函数，发现参数异常都必须输出供错误诊断用的调试信息。</p>
<ul>
<li>断言本身会输出诊断信息，故使用断言检测异常无需额外打印调试信息。”</li>
</ul>
</li>
</ul>
<p><strong>结构体或类对象的合法性可通过专门设计的检查函数或宏来进行。</strong> <strong>结构体的检查方法如：</strong></p>
<pre><code>struct str{
    char *ptr;
    size_t size;
};
#define CHECK_STR(x) ASSERT((x).ptr &amp;&amp; (x).size &lt; 1024)
void foo(struct str *p){
    ASSERT(p);
    CHECK_STR(*p);
    … … 
}</code></pre><p><strong>类对象的检查方法：</strong></p>
<pre><code>class str {
public:
#ifndef NDEBUG
    void assert_valid(){
        ASSERT(m_ptr);     //assert，断言assert的作用是现计算表达式 expression ，如果其值为假（即为0），那么它先向stderr打印一条出错信息。
        ASSERT(m_size &lt; 1024);
        //也就是如果m_ptr为空或者m_size &gt; 1024则报错！
    }
#endif
private:
    char *m_ptr;
    size_t m_size;
};
#define ASSERT_VALID(x) (x).assert_valid()  //直接调用类的
void foo(class str&amp; strs){
    ASSERT_VALID(strs);
    … … 
} </code></pre><h3 id="8-2-数据合法性检查："><a href="#8-2-数据合法性检查：" class="headerlink" title="8.2 数据合法性检查："></a>8.2 数据合法性检查：</h3><p>从外部读取的数据必须检查合法性，不可直接使用，外部数据指通过文件、进程间通讯设施或界面所获取的输入。 不使用该数据或该数据所有取值都是合法值可以例外。 外部数据的检查不应使用断言等仅在调试版本生效的措施。发现数据不满足要求时，必须输出供错误诊断用的调试信息。</p>
<blockquote>
<p>比如用户输入的数据，需要检查其合法性。</p>
</blockquote>
<h3 id="8-3-断言要求："><a href="#8-3-断言要求：" class="headerlink" title="8.3 断言要求："></a>8.3 断言要求：</h3><p>断言中禁止对变量赋值或改变变量的值，如<code>assert (size++ &gt; 100)</code>， 禁止调用有副作用的函数。 有副作用的函数，指函数内会更改变量值、改变系统环境、进行IO。</p>
<blockquote>
<p>和宏定义一样，不要有副作用</p>
</blockquote>
<h3 id="8-4-“return-返回值检查："><a href="#8-4-“return-返回值检查：" class="headerlink" title="8.4 “return - 返回值检查："></a>8.4 “return - 返回值检查：</h3><p>主要集中在API和内部函数里</p>
<ul>
<li><p>API： 对于返回新分配资源（句柄或指针）或者返回出错标识（比如使用FALSE，负数，0指针标识失败）的系统API（<strong>包括标准库、WIN32 API、MFC、ATL、POSIX API，第三方库</strong>），<strong>必须检查并处理失败情况。</strong> 不允许使用只在<code>DEBUG</code>版本生效的检查措施（比如：assert，VERIFY）。release也要检查！ 包括但不限于下述函数：</p>
<ul>
<li><p>malloc/realloc/calloc/new;</p>
</li>
<li><p>open/socket/pipe/epoll_create/pthread_create/fork/dup/popen;</p>
</li>
<li><p>CreateProcess/CreateThread/CreateFile;</p>
</li>
<li><p>fopen/fdopen/freopen;</p>
</li>
<li><p>GetMessage/PeekMessage;</p>
</li>
<li><p>mkdir/findfirst/lstat/recv/send;</p>
</li>
<li><p>sendto, recvfrom, bind, accept, sendmsg, recvmsg, setsockopt, select, poll, epoll_ctl,epoll_wait,connect；</p>
</li>
<li><p>例外：</p>
</li>
<li><p>如果忽略该错误不会影响程序正确性，可以在函数调用前加(void)忽略返回值检查。 建议同时注释说明为什么无需处理返回值；</p>
</li>
<li><p>如果API文档有明确说明，在条件满足时一定不会失败的，且调用该API之前已经保证满足不失败条件， 可以直接使用其返回值，或在函数调用前加(void)忽略返回值检查。例如snprintf,time等。</p>
</li>
</ul>
</li>
<li><p>内部函数： <strong>对于内部函数（非系统API），如果有返回值，且返回值会用于标识失败情况（比如使用FALSE，负数，0指针标识失败），必须检查并处理失败情况。</strong> 如果确认当前调用在用户环境不可能失败，或者该错误可以忽略，允许使用这两种错误处理手段：</p>
<ul>
<li><p>对于不可能失败的情况，可使用只在DEBUG版本生效的检查处理机制（如：assert,VERIFY）；[2010-9-8]</p>
</li>
<li><p><strong>在函数调用前面加(void)</strong>强调该函数不会出错或者错误可以忽略，建议同时注释说明为什么无需处理返回值；</p>
<p>(void)close(fd);        //调用close函数的时候强调void，表示其无返回值</p>
</li>
</ul>
</li>
</ul>
<p><strong>只要会返回失败，都应该应对失败情况。</strong></p>
<ul>
<li><p>对于recv,send一类函数调用来说，几乎不可能避免失败，而且失败的情况很多。必须针对每一种失败都有妥善的处理。允许把若干种失败情况合并起来处理。</p>
</li>
<li><p>对于一些有严格要求的程序来说，即使是<strong>CloseHandle/close</strong>一类的调用，也必须处理失败。比如流缓存、数据库一类的就需要检查CloseHandle/close，判断是否会有磁盘回写失败一类的情况。</p>
</li>
<li><p>对于一些要求没那么严格的程序来说，一般的处理方法是，在这些函数失败的时候打印日志信息，帮助开发者了解其中发生的异常情况。</p>
</li>
<li><p>如果明确不可能失败（比如有些函数资料已经明确说明只有在参数无效时才失败），或者不关注这种失败，可以用(void)CloseHandle(hFile)的方法处理返回值。这种方法可以屏蔽来自PC-LINT一类工具的警告，也可以提示代码阅读者知道作者不关注这个错误；</p>
</li>
</ul>
<h2 id="9-资源管理"><a href="#9-资源管理" class="headerlink" title="9 资源管理"></a>9 资源管理</h2><h3 id="9-0-总则"><a href="#9-0-总则" class="headerlink" title="9.0 总则"></a>9.0 总则</h3><p>资源问题是C/C++/ASM语言中独有的问题，这些语言认为资源管理非常重要，所以应该把资源管理权交给程序员，在语言机制上缺乏垃圾回收机制。 这种理念给了程序员更多的灵活性，能得到更好的性能，但也大大增加了出错的可能性。 最容易出现的资源问题有：</p>
<ul>
<li>资源使用完毕后没有释放；</li>
<li>资源重复释放；</li>
<li><strong>资源被释放后仍然被引用和访问，包括引用了已经被重新分配出去的资源</strong>。 比如：perror之类的函数默认往2号fd输出信息，如果先关闭2号fd，然后open/socket之类的调用会重用2这个fd，导致perror将信息错误输出到其它文件或socket；</li>
<li>使用错误的手段释放资源，比如使用fclose关闭被popen打开的FILE指针；</li>
</ul>
<p><strong>减少资源使用出错，有几个简单有效的原则：</strong></p>
<ul>
<li><p><strong>“配对”原则</strong>，即分配资源的函数出现在哪个函数里，与之配对的释放资源函数就应出现在哪个函数里。 <strong>- “使用前检查，释放后置空”</strong>原则，像这段代码一样的做法：</p>
<p> if (s_fp) { fclose(s_fp); s_fp = NULL;} </p>
</li>
</ul>
<h3 id="9-1-防止泄露："><a href="#9-1-防止泄露：" class="headerlink" title="9.1 防止泄露："></a>9.1 防止泄露：</h3><p>资源的分配和释放必须配对:</p>
<ul>
<li><p><strong>在某函数内分配的资源必须在该函数内释放</strong>；</p>
</li>
<li><p>如果函数分配了资源但不能马上释放，必须：</p>
<ul>
<li>必须有机制供调用者获取新分配的资源（通过返回值、出参、全局变量、类变量等）；</li>
<li>必须提供与之对应的能保证释放资源的函数(或者能通过delete,free等API直接释放)， 并在函数头的注释中说明负责释放的函数名称。 如果需要释放的资源是类的成员且负责释放的函数是析构函数，可不说明。析构函数自动释放资源。</li>
</ul>
</li>
</ul>
<h3 id="9-2-使用配套的资源释放函数释放资源（重点）"><a href="#9-2-使用配套的资源释放函数释放资源（重点）" class="headerlink" title="9.2 使用配套的资源释放函数释放资源（重点）"></a>9.2 使用配套的资源释放函数释放资源（重点）</h3><p>对于各类动态分配得到的资源，必须使用与之配套的释放函数释放。包括但不限于：</p>
<ul>
<li>open/creat/dup/socket/epoll_create分配的描述符由close释放；</li>
<li>fopen/fdopen/fopen分配的文件指针由fclose释放；</li>
<li>CreateFile分配的句柄由CloseHandle释放；</li>
<li>popen分配的文件指针由pclose释放；</li>
<li>new分配的内存由delete释放；</li>
<li><strong>new[]分配的内存由delete[]释放；</strong></li>
<li>malloc/realloc/strdup/calloc分配的内存由free释放；</li>
<li><strong>qdbm_open分配的数据结构由qdbm_close释放；</strong></li>
<li>kmalloc分配的由kfree释放；</li>
<li>vmalloc分配的由vfree释放；</li>
</ul>
<h3 id="9-3-避免重复释放："><a href="#9-3-避免重复释放：" class="headerlink" title="9.3 避免重复释放："></a>9.3 避免重复释放：</h3><ul>
<li><p>句柄或指针在资源释放结束后应置为无效值：</p>
<ul>
<li>delete/free后需要将指针置为0,不使用delete,free释放非堆内存;</li>
<li>close关闭的文件描述符必须置为-1；</li>
<li>fclose,pclose关闭的FILE指针必须置为0;</li>
<li>CloseHandle关闭的句柄必须置为INVALID_HANDLE_VALUE;</li>
<li>其它函数释放的资源必须置为对应的无效标识；</li>
</ul>
<p><strong>例外情况：</strong></p>
<ul>
<li>析构函数中可以例外；</li>
<li>即将退出程序时可以例外；</li>
<li>如果是局部变量且马上退出函数可以例外；</li>
<li>如果释放后马上指向其它有效资源的可以例外；</li>
</ul>
</li>
</ul>
<p><strong>以上例外情况需保证已释放资源不再被引用到。</strong></p>
<ul>
<li>释放资源前需判断句柄/指针的有效性，保证已经置为<strong>无效值的指针</strong>或句柄不会重复释放。能保证资源处于有效状态的可以例外。</li>
<li>如果释放函数本身能保证0指针或无效句柄释放的安全性，也可以例外，比如free(NULL)是安全的，无需if (!p) free(p)。</li>
</ul>
<p><strong>资源的分配和释放必须配对。即：</strong></p>
<ul>
<li>分配和释放应配对出现在同一个函数中，在父函数中分配的资源不应交给子函数释放，具体可参考注释；</li>
<li>一个分配不可对应多个释放操作；</li>
<li>如果封装了资源的分配，就应封装资源的释放，反过来也成立。这两个封装过的资源分配和释放操作应配对出现在同一个函数中。”</li>
</ul>
<p><strong>错误做法：</strong></p>
<pre><code>void child(void *p)
{
    //操作p ...
    free(p);
}

void parent(void)
{
    void *p = malloc(sizeof(int));
    child(p);
    //free(p);
}</code></pre><p>对于全局资源，建议：</p>
<pre><code>static char *s_buf;

int init_buf(void)
{
    if (s_buf)
        return 0;
    s_buf = malloc(BUFSIZ);
    return s_buf ? 0 : -1;
}

void clean_buf(void)
{
    if (!s_buf)
        return;
    free(s_buf);
    s_buf = NULL;
} </code></pre><h3 id="9-4-勿混用内存管理方法："><a href="#9-4-勿混用内存管理方法：" class="headerlink" title="9.4 勿混用内存管理方法："></a>9.4 勿混用内存管理方法：</h3><p>不能根据标识对同一个指针选用不同的内存管理方法（尤其是内存释放）</p>
<blockquote>
<p>delete和free不要混用，怎么声明的就怎么释放</p>
</blockquote>
<p>比如：</p>
<pre><code>void process_message(void *ptr, size_t size, bool bInHelp)
{
    ...
    if(bInHeap)
        free(ptr);
}
void post_send(void *ptr, size_t size, int flags)
{
    ...
    if (flags &amp; CRT_HEAP) {
        free(ptr);
    } else if (flags &amp; SYS_HEAP) {
        HeapFree(ptr);
    } else if (flags &amp; CPP_HEAP) {
        delete[] ptr;
    }
} </code></pre><h3 id="9-5-标准输入、输出、错误的关闭："><a href="#9-5-标准输入、输出、错误的关闭：" class="headerlink" title="9.5 标准输入、输出、错误的关闭："></a>9.5 标准输入、输出、错误的关闭：</h3><p>对于标准输入、标准输出、标准错误输出这三个文件，如果有必要关闭的话，<strong>必须将其重新打开，</strong> 定向到空文件描述符（比如/dev/null）。 <strong>这三个文件在不同平台下分别为：</strong></p>
<ul>
<li><p>linux下： 文件描述符为0，1，2；</p>
</li>
<li><p>windows下： GetStdHandle(STD_INPUT_HANDLE) GetStdHandle(STD_OUTPUT_HANDLE) GetStdhandle(STD_ERROR_HANDLE)</p>
</li>
<li><p>标准C中： stdin,stdout,stderr</p>
</li>
</ul>
<p><strong>将标准输入、标准输出、标准错误输出进行重定向：</strong></p>
<pre><code>close(0);
close(1);
close(2);
fd0 = open(&quot;/dev/null&quot;, O_RDWR);
fd1 = dup(fd0);
fd2 = dup(fd0);
if (fd0 != 0 || fd1 != 1 || fd2 != 2) {
   exit(1);
} </code></pre><h2 id="10-内存"><a href="#10-内存" class="headerlink" title="10 内存"></a>10 内存</h2><h3 id="10-0-总则"><a href="#10-0-总则" class="headerlink" title="10.0 总则"></a>10.0 总则</h3><blockquote>
<p>C语言中内存管理太难是许多人放弃c转向JAVA的主要原因</p>
</blockquote>
<p>内存问题是C/C++/ASM语言中独有的问题。 这些语言要<strong>求程序员自行管理对内存的访问，所以很容易因为程序员的失误引起bug。</strong></p>
<ul>
<li>尽量避免多个逻辑持有同一个内存块的引用/指针（<strong>某个逻辑释放内存块时，其它逻辑继续引用，引起悬挂访问）；</strong></li>
<li>尽量避免指针/引用长时间指向一个内存块的内部（当该内存块释放时可能引起悬挂访问）；</li>
<li><strong>变量总是应该初始化后再使用，尤其是指针</strong>；</li>
<li>对数组进行遍历时应当<strong>提防临界错误</strong>（比如＋1或－1的错误）；</li>
<li>警惕为<code>NULL</code>的指针和长度为<code>0</code>的数组；</li>
</ul>
<h3 id="10-1-变量初始化"><a href="#10-1-变量初始化" class="headerlink" title="10.1 变量初始化"></a>10.1 变量初始化</h3><p>1）<strong>对堆和栈上分配的变量、内存块进行了初始化；</strong> 例外情况：</p>
<ul>
<li>定义处和第一次赋值处相隔不超过5行，这两处之间未访问过该变量，<strong>并且没有出现过任何访问了该变量的控制结构（如if/for/while/switch/do等）。</strong></li>
</ul>
<p><strong>符合的例子：</strong></p>
<pre><code>int foo(const char *name) {
    int ret;
    printf(&quot;[debug] foo(%s) called\n&quot;, name);
    ret = find_hash(name);
    if (ret &lt; 0)
        return ret;
    return insert_hash(name); 
}</code></pre><p><strong>不符合例子：</strong></p>
<pre><code>int foo(const char *name) {
    int ret; 
    if (name &amp;&amp; name[0] != &apos;\0&apos;) {
        ret = find_hash(name);
        if (ret &lt; 0) {
            return ret;
        }
    }
    return insert_hash(name);
}</code></pre><p><strong>后续维护时，如果在insert_hash前加上访问ret的代码（如printf(“%d”, ret)）就会有问题了。</strong></p>
<ul>
<li>效率原因。这种情况须注释说明原因，且保证不出现读未初始化数据的问题。</li>
</ul>
<p>对于结构体、对象、字符串、数组等内存块，可以通过以下几种方法初始化：</p>
<ul>
<li>使用初始化列表，如：char buf[BUFSIZE] = {0};</li>
<li>使用构造函数、拷贝构造函数进行初始化；</li>
<li>使用memset，bzero等可以将内存块设置初始值的函数将整个内存块设置为某个初值， 或者使用memcpy等函数拷贝一块合法内存，保证整个内存块数据都为已初始化数据；</li>
</ul>
<p>使用赋值运算符对结构体和对象类型初始化，如：</p>
<pre><code>struct person customer;
customer = s_default_person;</code></pre><ul>
<li><strong>使用strcpy等能保证该内存块是合法字符串（有’\0’结尾）的函数初始化；</strong></li>
<li>使用分配时即初始化的函数（如calloc）进行内存分配；</li>
<li>使用其它自定义的函数，只要保证该数据块所有成员都已初始化为有效数据，或成为一个合法字符串（即’\0’之后的部分可以无需赋值）；</li>
</ul>
<p>2）作为出参使用的指针参数，必须在返回之前进行赋值。如明确无需赋值，需注释说明。 例子：</p>
<pre><code>void foo(const char *name) {
    char buf[BUFSIZE];  //get_full_name会首先初始化buf
    get_full_name(name, buf);
    printf(&quot;%s\n&quot;, buf);
}</code></pre><p>3）对于<strong>资源句柄</strong>（包括指针，下同），应初始化为一个<strong>无效标识值</strong>，或者通过分配得到的资源句柄，或者确定的可安全引用的资源句柄。 注意: 不要初始化为未获得授权的资源句柄，比如：<strong>把文件描述符直接初始化为0，或者将指针指向了不能安全访问的内存或变量（0除外）。</strong></p>
<h3 id="10-2-指针算术："><a href="#10-2-指针算术：" class="headerlink" title="10.2 指针算术："></a>10.2 指针算术：</h3><p>指针的移动</p>
<ul>
<li><strong>结构体类型的指针如果要指向下一个结构体头部，只要对指针加1，而不是加结构体长度；</strong></li>
<li>如果结构体是不定长的结构体，应该将指针先转换成char*类型，然后加需要偏移的字节长度；”</li>
</ul>
<p>例如:</p>
<pre><code>struct iphdr *iph = ip_hdr(skb);
struct tcphdr *tcph = (struct tcphdr *)(iph + (iph-&gt;ihl &lt;&lt; 2));

/上述代码有很严重的BUG，正确应该是：
struct tcphdr *tcph = (struct tcphdr *)((char *)iph + (iph-&gt;ihl &lt;&lt; 2)); </code></pre><h3 id="10-3-结构体比较："><a href="#10-3-结构体比较：" class="headerlink" title="10.3 结构体比较："></a>10.3 结构体比较：</h3><p>不使用memcmp（或者其它按位比较方法）比较两结构是否相等（C++类也一样）。 确认安全的允许例外，但须在类的注释中说明。”</p>
<blockquote>
<p>主要是注意结构体内存对齐的问题，memcmp比较需要保证结构体字节按1对其，结构体中必须没有空隙。</p>
</blockquote>
<p>比如：</p>
<pre><code>struct strus {
    char m_char;
    int m_int;
} a, b;

//strus占8个字节
a.m_char = 0; 
a.m_int = 0; 
b.m_char = 0;
b.m_int = 0;
if (memcmp(&amp;a, &amp;b, sizeof(a)) == 0) //有问题

if(a == b)  //比较的是a和b的地址

//理想的方法是重载==运算符，一个个比较 </code></pre><h3 id="10-4-字符串比较："><a href="#10-4-字符串比较：" class="headerlink" title="10.4 字符串比较："></a>10.4 字符串比较：</h3><p>禁止把字符串转成整数进行比较。如:</p>
<pre><code>if(*(int*)&quot;&quot;desc&quot;&quot; == *(int*)str)&quot; </code></pre><h3 id="10-5-防常量字符串修改："><a href="#10-5-防常量字符串修改：" class="headerlink" title="10.5 防常量字符串修改："></a>10.5 防常量字符串修改：</h3><p>不可修改常量字符串，比如</p>
<pre><code>char* p = &quot;&quot;NeiCun&quot;&quot;; 
p[0] =&apos;R&apos;; </code></pre><h3 id="10-6-字符串格式化："><a href="#10-6-字符串格式化：" class="headerlink" title="10.6 字符串格式化："></a>10.6 字符串格式化：</h3><ul>
<li>保证fprintf/sprintf/snprintf/printf参数的格式化控制符和实参的一致(gcc可以检查出部分此类问题）</li>
<li>通过外部数据得到的字符串不直接作为格式化参数（系统配置文件中的日志信息可以例外）；</li>
</ul>
<p>即用<code>printf(&quot;%s&quot;, strings)</code>替换掉<code>printf(strings)</code>。</p>
<h3 id="10-7-防止字符串缺结束符"><a href="#10-7-防止字符串缺结束符" class="headerlink" title="10.7 防止字符串缺结束符"></a>10.7 防止字符串缺结束符</h3><blockquote>
<p>这个问题很容易忽略，要相当注意</p>
</blockquote>
<ul>
<li>通过进程间通讯措施（比如：<strong>mmap/read/recv/recvfrom/fread/copy_from_user等</strong>）读取的内存块，</li>
<li>如块尾是一个字符串，需在末尾补’\0’，避免写入端没有写入’\0’结束符导致错误。</li>
</ul>
<p>例如：</p>
<pre><code>char *p = (char *)malloc(msgsize + 1);
int ret = recv(sk, p, msgsize, 0);
if (ret &lt;= 0) {
    …
}
p[msgsize] = &apos;\0&apos;; </code></pre><h3 id="10-8-字符串长度计算："><a href="#10-8-字符串长度计算：" class="headerlink" title="10.8 字符串长度计算："></a>10.8 字符串长度计算：</h3><blockquote>
<p>用strlen而不要用sizeof，后者是计算字符串定义长度</p>
</blockquote>
<ul>
<li>不可直接假定字符串长度，需使用strlen计算得到，分配容纳字符串的缓冲区，必须给’\0’结束符预留空间；</li>
<li>不可通过sizeof计算常量指针指向的字符串的长度； 作为特例：字面值常量的长度允许使用sizeof计算得到（sizeof计算得到的长度已经包含了’\0’结束符）。 如：</li>
</ul>
<pre><code>const char* pstr = &quot;hello&quot;;</code></pre><p><strong>通过<code>sizeof(pstr)</code>计算字符串长度是错误的，但是通过<code>sizeof(&quot;hello&quot;)-1</code>计算字符串长度是允许的。</strong></p>
<h3 id="10-9-变量大小、偏移计算："><a href="#10-9-变量大小、偏移计算：" class="headerlink" title="10.9 变量大小、偏移计算："></a>10.9 变量大小、偏移计算：</h3><ul>
<li>变量大小计算： <strong>计算变量大小，必须使用sizeof，不允许人为假定变量大小。</strong> 只要可能，就应该测量变量的大小，而不是测量类型的大小。（也就是不要测量int的大小，而是测量int a ，sizeof(a)）</li>
<li>成员偏移计算： 计算结构内成员的偏移使用offsetof（或和该宏等价的措施），不许人为假定成员偏移；</li>
</ul>
<p>比如：</p>
<pre><code>int val;

//推荐：
memcpy(buf, &amp;val, sizeof(val));
//不应该使用这两种：
memcpy(buf, &amp;val, 4);
memcpy(buf, &amp;val, sizeof(int));</code></pre><p><strong>对于通过参数传递的数组，无法直接测试数组长度，推荐：</strong></p>
<pre><code>void foo(int arr[ARRAY_SIZE])
{
    memcpy(g_buf, arr, sizeof(int) * ARRAY_SIZE);
}

//错误：
void foo(int arr[ARRAY_SIZE])
{
    memcpy(g_buf, arr, sizeof(arr));
} </code></pre><h3 id="10-10-C99的变长数组和alloca："><a href="#10-10-C99的变长数组和alloca：" class="headerlink" title="10.10 C99的变长数组和alloca："></a>10.10 C99的变长数组和alloca：</h3><ul>
<li>禁止使用C的变长数组；</li>
<li>禁止使用alloca/_alloca分配内存。</li>
</ul>
<p>建议使用std::vector或者malloc替代以上两种用法。 例如: C99的变长数组：</p>
<pre><code>void foo(int n)
{
    int a[n];

    a[0] = 1;
    ...
}</code></pre><p>上述代码在n的值超出范围时，会导致栈溢出。</p>
<h3 id="10-11-字符串转整数-浮点数："><a href="#10-11-字符串转整数-浮点数：" class="headerlink" title="10.11 字符串转整数/浮点数："></a>10.11 字符串转整数/浮点数：</h3><blockquote>
<p>将字符串转换为整数或者浮点数，不要使用ctype里的函数，可能会丢失精度</p>
</blockquote>
<p>不使用atoi,atol读取数字，除非对输入合法性没有要求的场合。 所使用的读取函数必须保证数字不被截断、不丢失精度，不能double变int。 建议：</p>
<ul>
<li>有符号整数建议使用strtol读取；</li>
<li>无符号整数建议使用strtoul读取；</li>
<li>浮点数建议使用strtod读取；</li>
<li>有符号的64位整数建议使用strtoll读取；</li>
<li>无符号的64位整数建议使用strtoull读取；”</li>
</ul>
<p>atoi和strtol函数均是把字符串转换成整数，两者的不同点主要是：</p>
<ul>
<li><p>atoi的返回值无法区分是正常的返回还是错误的返回，如：</p>
<p>int val;<br>val = atoi(“abc”); 与val = atoi(“0”);<br>两者返回的val均为0，因此无法区分哪个是正确parse后的值。</p>
</li>
</ul>
<ul>
<li><p>strtol函数对异常的返回可以设置errno，从而可以发现异常的返回，如：</p>
<p>errno = 0;    /* To distinguish success/failure after call */<br>val = strtol(str, &amp;endptr, base); </p>
</li>
</ul>
<h2 id="11-并发"><a href="#11-并发" class="headerlink" title="11 并发"></a>11 并发</h2><h3 id="11-0-总则"><a href="#11-0-总则" class="headerlink" title="11.0 总则"></a>11.0 总则</h3><p>并发指同一时间运行多个逻辑，<strong>包括使用分时手段运行的“伪”并发。</strong> 使用并发可以充分利用多CPU、多主机的性能，可以同时服务多个用户。 并发逻辑之间的相互影响非常难以分析，引发的缺陷很难重现和定位，所以应当审慎的选用你的并发方案。</p>
<ul>
<li>优先使用隔离能力强的并发手段，比如物理隔离的多台设备，内存空间隔离的多个进程，尽量不使用隔离能力差的多线程并发；</li>
<li>尽量限制并发逻辑之间的信息交互，降低并发逻辑之间的相互影响；</li>
</ul>
<h3 id="11-1-信号处理"><a href="#11-1-信号处理" class="headerlink" title="11.1 信号处理"></a>11.1 信号处理</h3><p>长时间运行的linux程序必须处理信号，必须处理或忽略的信号有SIGTERM，SIGINT，SIGPIPE，SIGBUS，SIGSEGV，SIGABRT。</p>
<ul>
<li>对于SIGPIPE信号，需忽略，或者保证处理之后程序仍能正常运行；</li>
<li>对于SIGBUS、SIGSEGV信号，应打印堆栈，保留现场信息供后续调试；</li>
<li>对于SIGCHLD信号，应保持系统默认行为，即SIG_DFL。</li>
</ul>
<p>如果能保证后续不调用和waitpid相关的函数（如system,pclose），或者程序逻辑不依赖waitpid的返回值，可以例外。 对于库代码，特别注意不要改变SIGCHLD的行为，以免影响库调用者的一些程序逻辑。</p>
<blockquote>
<p>要防止出现僵尸进程和孤儿进程</p>
</blockquote>
<h3 id="11-2-信号处理函数"><a href="#11-2-信号处理函数" class="headerlink" title="11.2 信号处理函数"></a>11.2 信号处理函数</h3><p><strong>信号处理函数中不调用不可重入函数</strong>。不可重入的函数<strong>典型特征</strong>有：</p>
<ul>
<li>内部使用了全局变量/静态变量，如：<code>malloc</code>，<code>printf</code>；</li>
<li>内部使用了可能导致死锁的机制，如：<code>localtime</code>，<code>localtime_r</code>；</li>
<li>调用了其它不可重入函数；</li>
</ul>
<p>建议采用的信号处理方法：<strong>在信号处理函数中仅仅设置信号标识（或计数），在主循环中判断信号标识执行相应的信号处理。</strong>（可以通过这个方法判断子进程）</p>
<blockquote>
<p>信号需要绑定函数，然后信号触发后调用相应的函数。具体信号函数可查资料。</p>
</blockquote>
<h3 id="11-3-不暴力终止线程"><a href="#11-3-不暴力终止线程" class="headerlink" title="11.3 不暴力终止线程"></a>11.3 不暴力终止线程</h3><p><strong>除非程序退出，否则不采用暴力方式终止线程。</strong> 推荐通过在线程函数中return的方式结束线程，但不强制要求，确认安全时使用pthread_exit/ExitThread退出线程也可以。</p>
<blockquote>
<p>一般用信号终止，绑定一个信号函数专门用来结束线程</p>
</blockquote>
<h3 id="11-4-wait-子进程-子线程的后事处理"><a href="#11-4-wait-子进程-子线程的后事处理" class="headerlink" title="11.4 wait - 子进程/子线程的后事处理"></a>11.4 wait - 子进程/子线程的后事处理</h3><p>处理进程的时候要注意：</p>
<ul>
<li>子进程终止后必须通过<code>waitpid/wait</code>等待结束，<strong>避免子进程成为僵尸进程；</strong></li>
<li>子线程必须使用<code>pthread_join</code>等待结束，或者使用<code>pthread_detach</code>使子线程成为detached状态，避免线程资源泄露；</li>
</ul>
<h3 id="11-5-互斥锁的使用"><a href="#11-5-互斥锁的使用" class="headerlink" title="11.5 互斥锁的使用"></a>11.5 互斥锁的使用</h3><blockquote>
<p>互斥是一个很重要的概念，尤其是在多进程/多线程编程中，还有数据库的使用</p>
</blockquote>
<p>主要注意以下几点：</p>
<ul>
<li>使用互斥锁之前，必须对互斥锁的结构体或对象进行初始化，或调用初始化函数；</li>
<li>使用互斥锁之后，必须使用销毁函数对互斥锁的结构体或对象进行销毁。使用<code>PTHREAD_MUTEX_INITIALIZER</code>初始化的可以例外；</li>
</ul>
<h3 id="11-6-锁定区域内睡眠"><a href="#11-6-锁定区域内睡眠" class="headerlink" title="11.6 锁定区域内睡眠"></a>11.6 锁定区域内睡眠</h3><p>在互斥锁锁定区域内<strong>不调用阻塞进程</strong>或者<strong>引发进程睡眠的系统调用</strong>，如果确实需要调用，须注释说明； 比如：</p>
<pre><code>//以下代码可能有问题：
lock();
sleep(1);
unlock();
－－－－－－－－－－－－－－－－
lock();
recv(sk, buf, bufsize, 0);
unlock(); </code></pre><h3 id="11-7-非递归锁的使用："><a href="#11-7-非递归锁的使用：" class="headerlink" title="11.7 非递归锁的使用："></a>11.7 非递归锁的使用：</h3><p>Mutex可以分为<strong>递归锁(recursive mutex)</strong>和<strong>非递归锁(non-recursive mutex)</strong>。可递归锁也可称为可重入锁(reentrant mutex)，非递归锁又叫不可重入锁(non-reentrant mutex)。 二者唯一的区别是：</p>
<ul>
<li>同一个线程可以多次获取同一个递归锁，不会产生死锁。</li>
<li>而如果一个线程多次获取同一个非递归锁，则会产生死锁。</li>
</ul>
<p>需要注意以下几点：</p>
<ul>
<li>非递归锁不用于递归函数；</li>
<li>非递归锁的锁定区域内不调用其它使用相同锁的函数。</li>
</ul>
<blockquote>
<p>(linux下的<code>pthread_mutex_t</code>默认是非递归锁，windows的临界区是递归锁）</p>
</blockquote>
<h3 id="11-8-死锁"><a href="#11-8-死锁" class="headerlink" title="11.8 死锁"></a>11.8 死锁</h3><p>以下情况会出现死锁：</p>
<ul>
<li><p>不解锁返回： 锁定区域内不允许出现不解锁的返回（包括抛出异常）</p>
</li>
<li><p>锁的相互等待： 如果两段代码同时使用<strong>两把相同的锁</strong>，<strong>不允许出现相互等待的现象</strong>。 例如：</p>
<p>//A线程：<br>lockA();<br>lockB();<br>unlockB();<br>unlockA()<br>//B线程：<br>lockB();<br>lockA();<br>unlockA();<br>unlockB() </p>
</li>
</ul>
<h3 id="11-9-线程创建"><a href="#11-9-线程创建" class="headerlink" title="11.9 线程创建"></a>11.9 线程创建</h3><p>线程创建需要注意以下情况：</p>
<ul>
<li><p><strong>失败处理</strong>： <strong>创建线程必须判断并处理失败情况；</strong> 说明：windows下创建线程可通过_beginthread/_beginthreadex/CreateThread/AfxBeginThread/线程类， Linux下创建线程可通过pthread_create。</p>
</li>
<li><p><strong>启动时序控制</strong>： 不可假定线程的执行顺序（除非创建时使用了CREATE_SUSPENDED等控制线程执行顺序的标志）， 不可简单使用sleep/usleep等不可靠方法来控制线程的执行顺序。</p>
</li>
<li><p><strong>Windows平台线程创建方法</strong>：</p>
<ul>
<li>在MFC中，创建界面线程使用AfxBeginThread或线程类，不使用_beginthread/_beginthreadex和CreateThread；</li>
<li>其它情况创建线程使用_beginthreadex（MFC中创建工作线程或非MFC程序），不直接使用CreateThread；</li>
</ul>
</li>
</ul>
<blockquote>
<p>linux的fork是创建进程</p>
</blockquote>
<h3 id="11-10-需要同步的访问："><a href="#11-10-需要同步的访问：" class="headerlink" title="11.10 需要同步的访问："></a>11.10 需要同步的访问：</h3><p>如果多个线程同时访问同一个变量，以下情况需要同步：</p>
<ul>
<li>一个线程线程先读后写，另一个线程有写；</li>
<li>一个线程写，另一个线程写了再读；（这种情况应避免，可以读临时值） 如果多个线程同时访问多个相联系的变量，只要一个线程有写，整个访问区间都应该同步保护，防止数据结构不一致。</li>
</ul>
<p><strong>单变量访问，比如：</strong></p>
<pre><code>//A线程：
if (g_cnt &lt; MAXCNT)
    g_cnt++;
//B线程：
if (g_cnt &gt; 0)
    g_cnt--;</code></pre><p>上述情况需要做同步。 <strong>多变量同时访问这两个变量：</strong></p>
<pre><code>char* buf;
int buf_cnt;
//A线程: 
buf[0] = 0;
buf_cnt = 0;
//B线程：
buf[0] = 10;
buf_cnt = 1;</code></pre><p>如果不做同步，可能造成“明明buf里已经没有数据”，但与之相关的buf_cnt计数却被置为1。</p>
<h2 id="12-危险的库特性"><a href="#12-危险的库特性" class="headerlink" title="12 危险的库特性"></a>12 危险的库特性</h2><h3 id="12-0-总则："><a href="#12-0-总则：" class="headerlink" title="12.0 总则："></a>12.0 总则：</h3><p>C&amp;C++标准库中存在一些不安全的特性或者函数，我们应当尽量避免使用。即使需要使用，也应该以保证安全的形式使用。</p>
<h3 id="12-1-错误号获取"><a href="#12-1-错误号获取" class="headerlink" title="12.1 错误号获取"></a>12.1 错误号获取</h3><p>在以错误号标识错误类型的API调用和错误号获取代码之间，不允许出现其它可能影响错误号的代码。 这些类型的API，包括Win32 API，socket API，标准C库函数。</p>
<blockquote>
<p>errno 是记录系统的最后一次错误代码。代码是一个int型的值，在errno.h中定义。查看错误代码errno是调试程序的一个重要方法。当linux C api函数发生异常时,一般会将errno变量(需include errno.h)赋一个整数值,不同的值表示不同的含义,可以通过查看该值推测出错的原因。在实际编程中用这一招解决了不少原本看来莫名其妙的问题。 比如：</p>
</blockquote>
<pre><code>1)
HANDLE hFile = CreateFile(…);
OnCreateFile(hFile, …);
if (hFile == INVALID_HANDLE_VALUE){
    DWORD err = GetLastError();
    ...
}
2)
HANDLE hFile = CreateFile(…);
if (hFile == INVALID_HANDLE_VALUE){
    WRITELOG(&quot;CreateFile failed\n&quot;);
    if (GetLastError() == XXX)
        ...
} </code></pre><h3 id="12-2-不混用文件机制"><a href="#12-2-不混用文件机制" class="headerlink" title="12.2 不混用文件机制"></a>12.2 不混用文件机制</h3><p>对同一文件或标准io流，不混用这三种机制：</p>
<ul>
<li>标准C库的文件IO（如: printf,fprintf,fseek,fgets）；</li>
<li>POSIX IO（如：open,ftruncate,lseek）；</li>
<li>C++ iostream(如：ostream, istream, fstream）；</li>
</ul>
<blockquote>
<p>主要根据自己写的是什么代码决定</p>
</blockquote>
<p>确定没有问题的可以例外，但需注释说明。</p>
<h3 id="12-3-不使用不安全函数："><a href="#12-3-不使用不安全函数：" class="headerlink" title="12.3 不使用不安全函数："></a>12.3 不使用不安全函数：</h3><p>标准库(或posix)中存在一些历史遗留的不安全函数，这些函数标准库已经提供了对应的安全版本。 对于这类函数，必须使用其安全版本，包括：</p>
<ul>
<li>提供了后缀为_r的替代函数的不可重入函数：<code>strtok,localtime,asctime,ctime,gmtime；</code></li>
<li>不判断输入长度的函数：gets；</li>
</ul>
<blockquote>
<p>VS里有使用后缀为_s的替代函数</p>
</blockquote>
<h2 id="13-危险的语言特性"><a href="#13-危险的语言特性" class="headerlink" title="13 危险的语言特性"></a>13 危险的语言特性</h2><h3 id="13-0-总则"><a href="#13-0-总则" class="headerlink" title="13.0 总则"></a>13.0 总则</h3><p>C&amp;C++语言中存在一些特征，这些特性或者很容易导致缺陷，或者是由实现定义，容易引起可移植性问题。</p>
<ul>
<li>不使用由实现定义的特性，如果确实有必要，<strong>应将这部分代码独立出来</strong>，通过条件编译技术保证各平台上的一致性；</li>
<li><strong>不使用未定义的语言特征，比如访问未初始化数据；</strong></li>
</ul>
<h3 id="13-1-自增-自减运算："><a href="#13-1-自增-自减运算：" class="headerlink" title="13.1 自增/自减运算："></a>13.1 自增/自减运算：</h3><p>表达式计算结果不能依赖于<strong>副作用</strong>计算发生的时机。</p>
<ul>
<li>同一语句中不得对同一变量使用多次自增或自减运算符。比如：*p++ = 2 + *p++;</li>
<li>不允许在一个表达式中既对该变量赋值，又对该变量使用自增/自减运算符。 <strong>比如：it = lst.erase(it++);</strong></li>
</ul>
<h3 id="13-2-参数顺序依赖性："><a href="#13-2-参数顺序依赖性：" class="headerlink" title="13.2 参数顺序依赖性："></a>13.2 参数顺序依赖性：</h3><p>函数调用参数列表中，参数值的计算<strong>不得有顺序依赖性。</strong> 比如：</p>
<pre><code>Call(a = b, ++a);
Call(foo1(), foo2());</code></pre><p>其中foo1和foo2的执行顺序不同会造成不同结果。</p>
<h3 id="13-3-char类型使用："><a href="#13-3-char类型使用：" class="headerlink" title="13.3 char类型使用："></a>13.3 char类型使用：</h3><ul>
<li>不直接使用char类型的变量做数组的索引。char类型既可能是有符号的(值的范围：-128<del>127)，也可能没符号(值的范围：0</del>255)。</li>
<li>需要将char变量当成int等类型使用前，必须先将char类型转化为unsigned char类型。</li>
<li>不使用<code>getch,fgetc,getchar,getc</code>返回的int型变量做数组索引（除非已经确定值大等于0）。”</li>
</ul>
<h3 id="13-4-除0错误预防-包括求余运算）："><a href="#13-4-除0错误预防-包括求余运算）：" class="headerlink" title="13.4 除0错误预防(包括求余运算）："></a>13.4 除0错误预防(包括求余运算）：</h3><ul>
<li>用作除数的变量需保证不为0。</li>
<li>求余运算符的右操作数也需保证不为0。</li>
<li>如果该变量来自不可信的输入（外部输入或者其它模块传递的参数），必须先判断是否为0，为0时不作为除数参与运算。”</li>
</ul>
<p>例如:</p>
<pre><code>size_t unitsize = ini_get(&quot;unitsize&quot;);
if (unitsize == 0)
    unitsize = 1;
size_t unitnum = size / unitsize; </code></pre><h3 id="13-5-指针转换："><a href="#13-5-指针转换：" class="headerlink" title="13.5 指针转换："></a>13.5 指针转换：</h3><p>void*类型的指针和其它类型的指针之间必须使用强制转换；</p>
<h3 id="13-6-移位运算："><a href="#13-6-移位运算：" class="headerlink" title="13.6 移位运算："></a>13.6 移位运算：</h3><p>移位运算的右操作数（即移动位数）必须大等于0并小于左操作数的位数；” &lt; C缺陷里有提到</p>
<h2 id="14-工具检查"><a href="#14-工具检查" class="headerlink" title="14 工具检查"></a>14 工具检查</h2><h3 id="14-0-总则："><a href="#14-0-总则：" class="headerlink" title="14.0 总则："></a>14.0 总则：</h3><p>工欲善其事，必先利其器。 善用代码静态扫描工具，可以找出代码中容易引起问题的不良写法，能找出部分内存访问或逻辑冲突之类的低级错误。</p>
<h3 id="14-1-cppcheck："><a href="#14-1-cppcheck：" class="headerlink" title="14.1 cppcheck："></a>14.1 cppcheck：</h3><p>所有C/C++代码须通过cppcheck检查，检查时须打开所有的检查选项。 除可以明确是误报的以外，不允许出现任何BUG及风格问题。(第三方代码除外）</p>
<blockquote>
<p>Cppcheck是一种C/C++代码缺陷静态检查工具，不同于C/C++编译器及其它分析工具，Cppcheck只检查编译器检查不出来的bug，不检查语法错误。</p>
</blockquote>
<h3 id="14-2-c-test-需编译-："><a href="#14-2-c-test-需编译-：" class="headerlink" title="14.2 c++test(需编译)："></a>14.2 c++test(需编译)：</h3><p>所有C/C++代码须通过C++test检查。除可以明确是误报的以外，不允许出现任何警告及错误(第三方代码除外）。 扫描需使用公司预置选项，如果需要额外关闭某些检查选项，需提前取得RDM书面认可。</p>
<blockquote>
<p>cppcheck是静态，这个需要编译</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/28/e7-ac-ac-e4-b8-83-e7-ab-a0-e5-8f-af-e7-a7-bb-e6-a4-8d-e6-80-a7-e7-bc-ba-e9-99-b7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/28/e7-ac-ac-e4-b8-83-e7-ab-a0-e5-8f-af-e7-a7-bb-e6-a4-8d-e6-80-a7-e7-bc-ba-e9-99-b7/" class="post-title-link" itemprop="url">第七章 可移植性缺陷</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-28 07:27:31" itemprop="dateCreated datePublished" datetime="2018-04-28T07:27:31+08:00">2018-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第七章-可移植性缺陷"><a href="#第七章-可移植性缺陷" class="headerlink" title="第七章 可移植性缺陷"></a>第七章 可移植性缺陷</h1><p><code>《C陷阱与缺陷》学习笔记``posts</code></p>
<ul>
<li><a href="#第七章-可移植性缺陷">第七章 可移植性缺陷</a><ul>
<li><a href="#导读">导读</a></li>
<li><a href="#71-应对c语言标准变更">7.1 应对C语言标准变更</a></li>
<li><a href="#72-标识符名称的限制">7.2 标识符名称的限制</a></li>
<li><a href="#73-整数的大小">7.3 整数的大小</a></li>
<li><a href="#74-字符是有符号整数还是无符号整数">7.4 字符是有符号整数还是无符号整数</a></li>
<li><a href="#75-移位运算符">7.5 移位运算符</a></li>
<li><a href="#76-内存位置0">7.6 内存位置0</a></li>
<li><a href="#77-除法运算时发生的截断">7.7 除法运算时发生的截断</a></li>
<li><a href="#78-随机数的大小">7.8 随机数的大小</a></li>
<li><a href="#79-大小写转换">7.9 大小写转换</a></li>
<li><a href="#710-首先释放然后重新分配">7.10 首先释放，然后重新分配</a></li>
<li><a href="#711-可移植性问题的一个例子">7.11 可移植性问题的一个例子</a></li>
</ul>
</li>
</ul>
<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>C语言编写的程序能够方便地在不同的编程环境中移植。</p>
<h2 id="7-1-应对C语言标准变更"><a href="#7-1-应对C语言标准变更" class="headerlink" title="7.1 应对C语言标准变更"></a>7.1 应对C语言标准变更</h2><p>C语言的标准一直在变化，比如<code>ANSI C</code>标准是现在用的最多的，但是其一直在增加新的特性。有些人如果没有及时升级，那么可能新版本的代码在他的电脑上就不能运行了。 比如函数原型的概念：</p>
<pre><code>1.double
2.square(double x)
3.{
4.        return x*x;
5.}</code></pre><p>这样写是不能通过编译的，很奇怪的写法。一般我们都是这样写：</p>
<pre><code>1.double square(double x)
2.{
3.    return x*x;
4.}
5.main ()
6.{
7.    double a = square(10);
8.}</code></pre><p>这样在square声明中表面x是double类型，而不是其他的。</p>
<h2 id="7-2-标识符名称的限制"><a href="#7-2-标识符名称的限制" class="headerlink" title="7.2 标识符名称的限制"></a>7.2 标识符名称的限制</h2><p>目前的C语言的标识符是对大小写敏感的，但是在以前版本的ANSI C标准所能保证的是，必须能够区别前6个字符不同的外部名称。而且，这个定义中并没有区分大写字母与其对应的小写字母。 <strong>所以编译器禁止使用与库函数同名的标志，即使大小写也不行！</strong></p>
<h2 id="7-3-整数的大小"><a href="#7-3-整数的大小" class="headerlink" title="7.3 整数的大小"></a>7.3 整数的大小</h2><p>C语言中有三种不同长度的整数：</p>
<ul>
<li>short</li>
<li>int</li>
<li>long</li>
</ul>
<p>C语言的定义中对各种不同类型整数的相对长度作了一些规定：</p>
<ul>
<li>3种类型的整数其长度是非递减的。也就是说，<code>short</code>型整数容纳的值肯定能被<code>int</code>型整数容纳；</li>
<li>一个普通（<code>int</code>类型）整数足够大以容纳任何数组下标；</li>
<li>字符长度由硬件特性决定（比如<code>long</code>类型在<code>32</code>位和<code>64</code>位的值可能不同，一个占<code>4</code>字节，一个占<code>8</code>字节）。</li>
</ul>
<h2 id="7-4-字符是有符号整数还是无符号整数"><a href="#7-4-字符是有符号整数还是无符号整数" class="headerlink" title="7.4 字符是有符号整数还是无符号整数"></a>7.4 字符是有符号整数还是无符号整数</h2><p>当要把char类型转到int类型，是要将字符作为有符号数还是应该无符号处理？正确的来说是应该作无符号处理的。但是c在转换为无符号的时候会先被转换成<code>int</code>类型，这样可能得到非预期的效果。 正确的方式是使用语句<code>(unsigned char)c</code>，因为一个unsighed char类型的字符在转换为无符号整数时无需首先转换为int类型，而是直接进行转换。</p>
<h2 id="7-5-移位运算符"><a href="#7-5-移位运算符" class="headerlink" title="7.5 移位运算符"></a>7.5 移位运算符</h2><p>对数进行移位的时候，空出的位会背哦符号位所填充。要注意一个规则：</p>
<blockquote>
<p>如果被移位的对象长度是n位，那么移位计数必须大于或等于0，而严格小于n。</p>
</blockquote>
<p>举例来说，如果一个int型整数是32位，n是一个int型整数，那么<code>n&lt;&lt;31</code>和n<code>&lt;&lt;0</code>这样是合法的，而<code>n&lt;&lt;32</code>和<code>n&lt;&lt;-1</code>是非法的。 且可以用移位运算符代替除法运算符，但要被移位的必须是非负数。</p>
<pre><code>mid = (low + high) &gt;&gt; 1;
mid = (low + high ) / 2;

a=a*4; 
b=b/4; 
//可以改为
a=a&lt;&lt;2; 
b=b&gt;&gt;2; </code></pre><blockquote>
<p>说明： 除2 = 右移1位 乘2 = 左移1位 除4 = 右移2位 乘4 = 左移2位 除8 = 右移3位 乘8 = 左移3位</p>
</blockquote>
<h2 id="7-6-内存位置0"><a href="#7-6-内存位置0" class="headerlink" title="7.6 内存位置0"></a>7.6 内存位置0</h2><p>null指针并不指向任何对象。因此，除非是用于赋值或比较运算，出于其他任何目的使用null指针都是非法的。 不同的编译器有不同的效果，有一些对内存位置0只允许读，不允许写。要检查出这类问题的最简单的办法就是，把程序移到不允许读内存位置0的机器上运行。</p>
<h2 id="7-7-除法运算时发生的截断"><a href="#7-7-除法运算时发生的截断" class="headerlink" title="7.7 除法运算时发生的截断"></a>7.7 除法运算时发生的截断</h2><p>假定我们让a除以b，商为q，余数为r：</p>
<pre><code>1.q= a/b;
2.r= a%b;</code></pre><p>我们希望a、b、q、r之间维持怎样的关系呢？</p>
<ul>
<li>最重要的一点，我们希望q*b+r==a，因为这是定义余数的关系。</li>
<li>如果我们改变a的正负号，我们希望这会改变q的符号，这不会改变q的绝对值。</li>
<li>当b&gt;0时，我们希望保证r&gt;=0且r&lt;b。例如，如果余数用于哈希表的索引，确保它是一个有效的索引值很重要。</li>
</ul>
<p><strong>余数与被除数的正负号要相同</strong>，否则上述条件都不能满足。所以在取余的时候尽量避免被余数为负，最好是为<strong>无符号数</strong>。</p>
<h2 id="7-8-随机数的大小"><a href="#7-8-随机数的大小" class="headerlink" title="7.8 随机数的大小"></a>7.8 随机数的大小</h2><p>随机数其实是伪随机数，有一定规律。现在实现随机数会加上时间种子，根据时间的变化产生相应的随机数。 如果想要一定范围的随机数，可以将其对范围值取余。比如1到100的随机数：</p>
<pre><code>1.b=rand()%100;</code></pre><h2 id="7-9-大小写转换"><a href="#7-9-大小写转换" class="headerlink" title="7.9 大小写转换"></a>7.9 大小写转换</h2><pre><code>1.#define toupper(c) ((c) + &apos;A&apos; - &apos;a&apos;)
2.#define tolower(c) ((c) + &apos;a&apos; - &apos;A&apos;)</code></pre><p>早起的库函数toupper和tolower是这样实现的。但是有不足之处，如果输入的不是字母就会产生其他垃圾信息。</p>
<h2 id="7-10-首先释放，然后重新分配"><a href="#7-10-首先释放，然后重新分配" class="headerlink" title="7.10 首先释放，然后重新分配"></a>7.10 首先释放，然后重新分配</h2><p>大多数c语言实现都为使用者提供了3个内存分配函数：<code>malloc</code>，<code>realloc</code>和<code>free</code>。其他的不说，这个realloc有点陌生。 调用realloc函数时，需要把指针向一块已分配内存的区域指针以及这块内存新的大小作为参数传入，就可以调整这块内存区域为新的大小，这个过程可能涉及到内存的拷贝。</p>
<pre><code>1.free(p);
2.p = realloc (p, newsize);</code></pre><p>先释放再分配是第七版参考手册中所规定的。</p>
<h2 id="7-11-可移植性问题的一个例子"><a href="#7-11-可移植性问题的一个例子" class="headerlink" title="7.11 可移植性问题的一个例子"></a>7.11 可移植性问题的一个例子</h2><p>看不懂（狗头）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/28/e7-ac-ac-e5-85-ad-e7-ab-a0-e9-a2-84-e5-a4-84-e7-90-86-e5-99-a8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/28/e7-ac-ac-e5-85-ad-e7-ab-a0-e9-a2-84-e5-a4-84-e7-90-86-e5-99-a8/" class="post-title-link" itemprop="url">第六章 预处理器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-28 01:28:21" itemprop="dateCreated datePublished" datetime="2018-04-28T01:28:21+08:00">2018-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第六章-预处理器"><a href="#第六章-预处理器" class="headerlink" title="第六章 预处理器"></a>第六章 预处理器</h1><p><code>《C陷阱与缺陷》学习笔记``posts</code></p>
<ul>
<li><a href="#第六章-预处理器">第六章 预处理器</a><ul>
<li><a href="#导读">导读</a></li>
<li><a href="#61-不能忽视宏定义中的空格">6.1 不能忽视宏定义中的空格</a></li>
<li><a href="#62-宏并不是函数">6.2 宏并不是函数</a><ul>
<li><a href="#621-括号预防优先级问题">6.2.1 括号预防优先级问题</a></li>
<li><a href="#622-避免参数副作用">6.2.2 避免参数副作用</a></li>
</ul>
</li>
<li><a href="#63-宏并不是语句">6.3 宏并不是语句</a></li>
<li><a href="#63-宏并不是类型定义">6.3 宏并不是类型定义</a></li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
</ul>
<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>预处理器使得编程者可以简化某些工作，它的重要性可以由两个主要的原因说明。</p>
<ul>
<li>第一，有时候我们希望将某个特定数量（如数据表的大小）在程序中出现的<strong>所有实例</strong>统统加以修改。只要改一个地方，其他所有地方都修改。</li>
<li>第二，C语言函数调用时都会带来巨大的系统开销。因此，我们希望有这样一种程序块，它看上去像一个函数，但却没有函数调用。比如，<code>getchar</code>和<code>putchar</code>经常被实现为宏，</li>
</ul>
<p>宏的作用非常强大，有时候可以使代码看起来更加容易理解，将数字或符号替换为自己熟悉的命名。</p>
<h2 id="6-1-不能忽视宏定义中的空格"><a href="#6-1-不能忽视宏定义中的空格" class="headerlink" title="6.1 不能忽视宏定义中的空格"></a>6.1 不能忽视宏定义中的空格</h2><p>宏也是有参数的，和函数一样。函数有空格无关紧要，但是如果宏定义带了空格意思就不一样了。 比如</p>
<pre><code>#define f (x) ((x) - 1)</code></pre><p>可能观察不仔细的人会以为是将f(x)替换成((x) - 1)，这样编译通过不了！所以必须要像下面这样写：</p>
<pre><code>#define f(x) ((x) - 1)</code></pre><p><strong>这一规则不适用与宏调用，只对宏定义有用。因此，在上面完成宏定义后，f(3)与f (3)求值后都等于2。</strong></p>
<h2 id="6-2-宏并不是函数"><a href="#6-2-宏并不是函数" class="headerlink" title="6.2 宏并不是函数"></a>6.2 宏并不是函数</h2><h3 id="6-2-1-括号预防优先级问题"><a href="#6-2-1-括号预防优先级问题" class="headerlink" title="6.2.1 括号预防优先级问题"></a>6.2.1 括号预防优先级问题</h3><p>宏严格来说并不是函数，但是很多程序员都喜欢把一些简单的函数定义为宏。比如如下写法：</p>
<pre><code>#define abs(x) (((x) &gt;= 0) ? (x) : -(x))
#define max(a,b) ((a) &gt; (b) ? (a) : (b))</code></pre><p>之所以这么多括号是预防引起<code>优先级</code>有关的问题，如果没有括号可能会造成优先级的问题。因为宏不像函数，宏只是起到了一个替换的作用，直接将define的中间替换为后面的表达式。比如</p>
<pre><code>#define abs(x) x&gt;0?x:-x
abs(a-b);       //</code></pre><p>会被展开为 <code>a-b&gt;0?a-b:-a-b</code>，其中的-a-b相当于(-a)-b，而不是想象中的-(a-b)。所以最好用括号括起来。</p>
<h3 id="6-2-2-避免参数副作用"><a href="#6-2-2-避免参数副作用" class="headerlink" title="6.2.2 避免参数副作用"></a>6.2.2 避免参数副作用</h3><p>在用到类似的三元运算符宏定义<code>#define max(a,b) a&gt;b ? a : b</code>时，因避免在三元运算符里对数进行改变而产生<strong>副作用</strong>。比如：</p>
<pre><code>biggest = ((biggest) &gt; (x[i++]) &gt; (biggest) : (x[i++]));</code></pre><p>在上述表达式中，若<code>i</code>为<code>0</code>，那么<code>biggest</code>会与<code>x[0]</code>先比较，然后因为<code>i++</code>的作用，此时<code>i</code>为1，然后再在后面的赋值中又有<code>i++</code>，此时计算完毕<code>i</code>的值已经为<code>2</code>，而不是预料之中的<code>1</code>。 所以要确保<strong>max中的参数没有副作用</strong>。</p>
<h2 id="6-3-宏并不是语句"><a href="#6-3-宏并不是语句" class="headerlink" title="6.3 宏并不是语句"></a>6.3 宏并不是语句</h2><p>有些人会认为宏也是语句，如果单独使用也和语句一样，有分号作终止符，其实大错特错！ 比如assert宏，它的参数是一个表达式，如果该表达式为0，就使程序终止执行并给出一条错误信息。</p>
<pre><code>#define assert(e) if(!e) assert_error(_FILE,_LINE_)

if(x &gt; 0 &amp;&amp; y &gt; 0)
    assert(x &gt; y);
else
    assert(y &gt; x);</code></pre><p>上面的式子通过宏替换后就是这样样子:</p>
<pre><code>if( x &gt; 0 &amp;&amp; y &gt; 0)
    if(!(x &gt; y)) assert_error(&quot;foo.c&quot;,37);
else
    if(!(y &gt; x)) assert_error(&quot;foo.c&quot;,39);</code></pre><p>请注意之前的if-else结合优先级问题，未匹配的<code>else</code>会与其最近的<code>if</code>结合。将代码适当缩排一下：</p>
<pre><code>if( x &gt; 0 &amp;&amp; y &gt; 0)
    if(!(x &gt; y)) 
        assert_error(&quot;foo.c&quot;,37);
    else
        if(!(y &gt; x)) 
            assert_error(&quot;foo.c&quot;,39);</code></pre><p>可以看到实际流程与我们想象中的有所出入，那么如何解决这个问题？ 这样定义assert：</p>
<pre><code>#define assert(e) ((void)((e))||_assert_error(__FILE__,__LINE__)))</code></pre><p>这个定义实际上利用了<code>||</code>运算符对两侧的操作数依次顺序求值的性质。具体的也不是很理解。</p>
<h2 id="6-3-宏并不是类型定义"><a href="#6-3-宏并不是类型定义" class="headerlink" title="6.3 宏并不是类型定义"></a>6.3 宏并不是类型定义</h2><p>宏的一个常见用途是，使多个不同变量的类型可在一个地方说明：</p>
<pre><code>#define FOOTYPE struct foo
FOOTYPE a;
FOOTYPE b,c;</code></pre><p>这样，编程者只需在程序中改动一行代码，即可改变<code>a、b、c</code>的类型，而与<code>a、b、c</code>在程序中的什么地方声明无关。这种用法有一个优点——<strong><code>可移植性</code></strong>。但是我们最好还是使用类型定义：</p>
<pre><code>typedef struct foo FOOTYPE;</code></pre><p>看起来差不多，但是使用起来就会有很大的差别。例如，如下代码：</p>
<pre><code>#define T1 struct foo *
typedef struct foo  *T2;</code></pre><p>从上面看，<code>T1</code>和<code>T2</code>好像完全一样，都是指向结构<code>foo</code>的指针。但是当我们试图用他们来声明多个变量时，问题就来了。</p>
<pre><code>T1 a, b;
T2 a, b;
//第一个声明被扩展为：
struct foo *a, b;</code></pre><p>这个语句中<code>a</code>被定义为一个指向结构的指针，而<code>b</code>却被定义为一个结构。第二个声明则不同，它定义的都是指向结构的指针。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>宏是一个强大的功能，用好了则事半功倍，否则事倍功半！总结以下几点，写代码的时候要十分注意。</p>
<ul>
<li><strong>宏不要随便加空格</strong>，因为<code>define</code>后面的<code>两个式子</code>就是<code>相互替换</code>的关系，如果多了一个空格那么就会变成三个式子；</li>
<li><strong>宏不是函数</strong>，是直接替换内容，要考虑运算符优先级的问题，必要时应该加上空格防止优先级错误；</li>
<li><strong>宏要避免参数副作用</strong>，不要在宏里进行多余的操作，比如<code>++</code>操作；</li>
<li><strong>宏不是语句</strong>，不要想当然的当成语句来处理，需要加分号等结束符；</li>
<li><strong>宏不适用于类型定义</strong>，多重定义的时候会出现歧义。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/26/e7-ac-ac-e4-ba-94-e7-ab-a0-e5-ba-93-e5-87-bd-e6-95-b0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/26/e7-ac-ac-e4-ba-94-e7-ab-a0-e5-ba-93-e5-87-bd-e6-95-b0/" class="post-title-link" itemprop="url">第五章 库函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-26 01:16:41" itemprop="dateCreated datePublished" datetime="2018-04-26T01:16:41+08:00">2018-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第五章-库函数"><a href="#第五章-库函数" class="headerlink" title="第五章 库函数"></a>第五章 库函数</h1><p><code>《C陷阱与缺陷》学习笔记``posts</code></p>
<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>C语言中没有定义输入/输出语句，任何一个有用的C程序都必须调用库函数来完成最基本的输入/输出操作。</p>
<blockquote>
<p>就像内存相关的的函数malloc和free是库函数，但是C++里的new和delete是运算符。</p>
</blockquote>
<p>最好尽量使用系统头文件，因为库文件的编写是经过深思熟虑的，代码的功能都是十分完全的。</p>
<ul>
<li><a href="#第五章-库函数">第五章 库函数</a><ul>
<li><a href="#导读">导读</a></li>
<li><a href="#51-返回整数的getchar函数">5.1 返回整数的getchar函数</a></li>
<li><a href="#52-更新顺序文件">5.2 更新顺序文件</a><ul>
<li><a href="#521-函数理解">5.2.1 函数理解</a></li>
<li><a href="#522-代码解释">5.2.2 代码解释</a></li>
<li><a href="#523-如果不fseek直接fread会发生什么呢">5.2.3 如果不fseek直接fread会发生什么呢？</a></li>
</ul>
</li>
<li><a href="#53-缓冲输出与内存分配">5.3 缓冲输出与内存分配</a><ul>
<li><a href="#531-使用setbuf库函数">5.3.1 使用setbuf库函数</a></li>
</ul>
</li>
<li><a href="#54-使用errno">5.4 使用errno</a></li>
<li><a href="#55-库函数signal">5.5 库函数signal</a></li>
</ul>
</li>
</ul>
<h2 id="5-1-返回整数的getchar函数"><a href="#5-1-返回整数的getchar函数" class="headerlink" title="5.1 返回整数的getchar函数"></a>5.1 返回整数的getchar函数</h2><blockquote>
<p>第一眼看到getchar就想起了缓冲回车符，有时候如果不多加一个getchar来缓冲回车符代码就会出错。因为回车也是一个符号，也会进入缓冲区，getchar就是从缓冲区一个个读字符。getchar() 在键盘输入信息时, 并不是在键盘上敲一个字符，该字符就立即送到计算机中，这些字符暂存在键盘的缓冲区中，只有按了Enter键才会把这些字符一起送到计算机中。</p>
</blockquote>
<p>为什么getchar会返回整数int？先看看下面这个例子：</p>
<pre><code>#include&lt;stdio.h&gt;
main()
{
    char c;
    while((c = getchar()) != EOF )
            putchar(c);
}</code></pre><p>C语言中对getchar的描述为：</p>
<pre><code>int getchar(void);</code></pre><p>按理返回值应用<code>char</code>,但为了包含<code>EOF</code>，<code>EOF</code>是一个整型数，通常值为<code>-1</code>，<code>char</code>就装不下，就用了更大的int来装（ASCII码的取值范围<code>0-127</code>）。 编译器会把<code>EOF</code>做<strong>“截断”</strong>处理，把被<strong>“截断”</strong>的值返回给<code>c</code>。</p>
<h2 id="5-2-更新顺序文件"><a href="#5-2-更新顺序文件" class="headerlink" title="5.2 更新顺序文件"></a>5.2 更新顺序文件</h2><blockquote>
<p>可以看一下这篇问答，讲的很好！<a href="http://www.dewen.net.cn/q/9263/%E8%B0%83%E7%94%A8fread%E5%90%8E%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8fwrite%E5%86%99%E4%B8%8D%E8%BF%9B%E5%8E%BB%EF%BC%8C%E5%8F%8D%E4%B9%8B%E4%B9%9F%E6%98%AF%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F" target="_blank" rel="noopener">调用fread后直接调用fwrite写不进去，反之也是，为什么？</a></p>
</blockquote>
<h3 id="5-2-1-函数理解"><a href="#5-2-1-函数理解" class="headerlink" title="5.2.1 函数理解"></a>5.2.1 函数理解</h3><p>linux下，man fread和fread结果</p>
<ul>
<li><code>size_t</code> fread(void <code>*ptr</code>,size_t <code>size</code>,size_t <code>nmemb</code>,File <code>*stream</code> )定义：</li>
</ul>
<blockquote>
<p>fread是一个函数，它从文件流中读数据，最多读取<code>numeb</code>个项，每个项<code>size</code>个字节，如果调用成功返回实际读取到的项个数（小于或等于<code>nmemb</code>），如果不成功或读到文件末尾返回 0。</p>
</blockquote>
<ul>
<li><code>size_t</code> fwrite(void <code>*ptr</code>, size_t <code>size</code>, size_t <code>nmemb</code>, FILE <code>*stream</code>)定义：</li>
</ul>
<blockquote>
<p>fwrite() 是 C 语言标准库中的一个文件处理函数，功能是向指定的文件中写入若干数据块，如成功执行则返回实际写入的数据块数目。该函数以二进制形式对文件进行操作，不局限于文本文件。</p>
</blockquote>
<ul>
<li><code>int</code> fseek(FILE <code>*stream</code>, long <code>offset</code>, int <code>whence</code>);</li>
</ul>
<blockquote>
<p>文件指针偏移，根据whence偏移起始位置偏移offset个字节。</p>
</blockquote>
<ul>
<li><p>fseek的函数参数列表第三个的数字含义： 偏移起始位置：</p>
<ul>
<li>文件头<code>0</code>(SEEK_SET)；</li>
<li>当前位置<code>1</code>(SEEK_CUR)；</li>
<li>文件尾<code>2</code>(SEEK_END)。</li>
</ul>
</li>
</ul>
<h3 id="5-2-2-代码解释"><a href="#5-2-2-代码解释" class="headerlink" title="5.2.2 代码解释"></a>5.2.2 代码解释</h3><p>那么我们再来看下面这段代码：</p>
<pre><code>FILE * fp;  
struct record rec;  
//... ...  
//从fp读结构体rec，每次读一个
while (fread((char *)&amp;rec, sizeof(rec), 1, fp) == 1) 
{  
    /* 对rec执行某些操作 */  
    if (/* rec 必须被重新写入 */) 
    {  
         fseek(fp, -(long)sizeof(rec), 1); 
         /*因为要重新将rec写入到fp，要对文件指针向前回溯，所以是fseek的第二项是负数，后面的1是文件指针当前位置，表明回溯起点是文件中rec的尾部*/
         fwrite((char *)&amp;rec, sizeof(rec), 1, fp);  
         /*rec写入缓冲区，等待写入。*/
         fseek(fp,0L,1);
         /*之所以要调用fseek，因为fwrite的数据只是写入到了缓冲区，而fseek函数中调用了fflush（因版本而异），这样才将缓冲区的内容输入写进fp。*/
         /*其实这个指令看似什么也做，但是其使得磁盘文件中的数据改变了，并且使文件可以正常读取了*/
    }  
}  </code></pre><p>上述代码之前应该有<code>fopen()</code>操作，这个操作是将文件数据读入缓存区，然后fread从缓存区读数据。 flush除了写入文件外，它还把将<code>file</code>中<code>_ptr</code>（文件缓存的指针）的位置重新设置到缓存的开始处了。 借用上面网址中的一幅图，可以很直观的理解文件操作和为什么要<code>fseek</code>。 <img src="http://tanwenbo.top/wp-content/uploads/2018/05/771203f53a763dd89db9de9bd235b906.png" alt=""> </p>
<h3 id="5-2-3-如果不fseek直接fread会发生什么呢？"><a href="#5-2-3-如果不fseek直接fread会发生什么呢？" class="headerlink" title="5.2.3 如果不fseek直接fread会发生什么呢？"></a>5.2.3 如果不fseek直接fread会发生什么呢？</h3><p><strong>fwrite</strong>将数据写入缓存区，<strong>fread</strong>又从文件读数据到缓存区，缓存区中有2组数据，但是fseek只将文件指针向后偏移了一组数据的偏移量，那么数据后面的就会被覆盖。 小结一下</p>
<ul>
<li>连续的fread不用调用fseek</li>
<li>使用了fwrite后应该及时调用fseek，使文件缓存真正写入磁盘文件中。</li>
</ul>
<h2 id="5-3-缓冲输出与内存分配"><a href="#5-3-缓冲输出与内存分配" class="headerlink" title="5.3 缓冲输出与内存分配"></a>5.3 缓冲输出与内存分配</h2><p>程序输出有两种方式：</p>
<ul>
<li>一种是及时处理方式；</li>
<li>另一种是先暂存起来，然后再大块写入的方式。</li>
</ul>
<p>前者往往造成较高的系统负担。因此，C语言实现通常都允许程序员进行实际的写操作之前控制产生的输出数据量。</p>
<h3 id="5-3-1-使用setbuf库函数"><a href="#5-3-1-使用setbuf库函数" class="headerlink" title="5.3.1 使用setbuf库函数"></a>5.3.1 使用setbuf库函数</h3><p>setbuf(stdout,buf);</p>
<p>语句将通知输入/输出库，所有写入到stdout的输出都应该使用buf作为输出缓冲区，知道buf缓冲区被填满或者程序员直接调用fflush（调用之后缓冲区的内容才被实际的写入该文件）。 如果直接在main函数里声明缓冲数组会出错，因为main函数结束后<code>缓冲数组</code>会被释放。解决的方法就是</p>
<ul>
<li><p>声明静态函数</p>
<p>static char buf[BUFSIZ];</p>
</li>
</ul>
<ul>
<li><p>动态分配缓冲区</p>
<p>char *malloc();<br>setbuf(stdout, malloc(BUFSIZ)); </p>
</li>
</ul>
<h2 id="5-4-使用errno"><a href="#5-4-使用errno" class="headerlink" title="5.4 使用errno"></a>5.4 使用errno</h2><p>很多库函数，特别是那些与操作系统有关的，当执行失败时会通过一个名称为<code>errno</code>的外部变量，通知程序该函数调用失败。</p>
<blockquote>
<p>errno 是记录系统的最后一次错误代码。代码是一个int型的值，在errno.h中定义。查看错误代码errno是调试程序的一个重要方法。当linux C api函数发生异常时,一般会将errno变量(需include errno.h)赋一个整数值,不同的值表示不同的含义,可以通过查看该值推测出错的原因。在实际编程中用这一招解决了不少原本看来莫名其妙的问题。</p>
</blockquote>
<p>在调用库函数时，我们应该首先检测作为错误提示的返回值，确定程序执行已经失败。然后，再检查errno，来搞清楚出错原因：</p>
<pre><code>//调用库函数
if(返回的错误值)
        检查errno </code></pre><h2 id="5-5-库函数signal"><a href="#5-5-库函数signal" class="headerlink" title="5.5 库函数signal"></a>5.5 库函数signal</h2><p>信号函数，作为捕获异步事件的一种方式。</p>
<pre><code>#include&lt;signal.h&gt;
signal(signal type, handler function);</code></pre><p>signal type代表信号中的某些常量，比如（<code>SIGINT</code>）。<code>liunx</code>有<code>64</code>种信号，其中<code>32</code>种是不可靠信号，另外<code>32</code>种是可靠信号。 从安全角度出发，signal不应该调用系统的<code>库函数</code>，也就是<code>function</code>不应该是<code>库函数</code>，应该是自己定义的函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/24/four-link/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/24/four-link/" class="post-title-link" itemprop="url">第四章 连接</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-24 12:05:28" itemprop="dateCreated datePublished" datetime="2018-04-24T12:05:28+08:00">2018-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="http://maxiang.io/#/?provider=evernote&guid=558692fd-8021-498e-a42c-9f3d939845dd&notebook=%E3%80%8AC%E9%99%B7%E9%98%B1%E4%B8%8E%E7%BC%BA%E9%99%B7%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0" target="_blank" rel="noopener">Edit</a></p>
<h1 id="第四章-连接"><a href="#第四章-连接" class="headerlink" title="第四章 连接"></a>第四章 连接</h1><p>《C陷阱与缺陷》学习笔记 形参 实参 static posts</p>
<ul>
<li><a href="#第四章-连接">第四章 连接</a></li>
</ul>
<ul>
<li><p><a href="#41-什么是连接器">4.1 什么是连接器</a></p>
</li>
<li><p><a href="#42-声明和定义">4.2 声明和定义</a></p>
</li>
<li><p><a href="#43-命名冲突与static修饰符">4.3 命名冲突与static修饰符</a></p>
</li>
</ul>
<ul>
<li><p><a href="#431-变量">4.3.1 变量</a></p>
</li>
<li><p><a href="#432-函数">4.3.2 函数</a></p>
</li>
</ul>
<ul>
<li><a href="#44-形参实参与返回值">4.4 形参、实参与返回值</a></li>
</ul>
<ul>
<li><p><a href="#441-形参实参的区别">4.4.1 形参实参的区别</a></p>
</li>
<li><p><a href="#442-强制转换">4.4.2 强制转换</a></p>
</li>
<li><p><a href="#443-返回值">4.4.3 返回值</a></p>
</li>
</ul>
<ul>
<li><a href="#45-检查外部类型">4.5 检查外部类型</a></li>
</ul>
<ul>
<li><p><a href="#原内存布局">原内存布局</a></p>
</li>
<li><p><a href="#现内存布局">现内存布局</a></p>
</li>
</ul>
<ul>
<li><p><a href="#46-头文件">4.6 头文件</a></p>
</li>
<li><p><a href="#总结">总结</a></p>
</li>
</ul>
<h2 id="4-1-什么是连接器"><a href="#4-1-什么是连接器" class="headerlink" title="4.1 什么是连接器"></a>4.1 什么是连接器</h2><blockquote>
<p>在C语言中，一个重要的思想就是分别编译，即若干个源程序可以在不同的时候单独进行编译，然后在恰当的时候整合到一起。但是连接器一般是与C编译器分离的，连接器如何做到把若干个C源程序合并成一个整体呢？</p>
<p>典型的连接器把由编译器或汇编器生成的若干个目标模块，整合成一个被称为载入模块或可执行文件的实体，该实体能够被操作系统直接执行。其中，某些目标模块是直接作为输入提供给连接器的；而另外一些目标模块则是根据连接过程的需要，从包括有类似printf函数的库文件中取得的。</p>
</blockquote>
<p>简而言之，连接器就是用来连接各个编译好的模块，然后将其组成一个模块或者可执行文件。且会检查外部对象是否有重复，重复则报错。因为大多数连接器都进制同一个载入模块中的两个不同对象拥有相同的名称。</p>
<h2 id="4-2-声明和定义"><a href="#4-2-声明和定义" class="headerlink" title="4.2 声明和定义"></a>4.2 声明和定义</h2><p>声明在函数体之外的变量是全局变量，也称为外部对象。</p>
<p>1.int a; //声明</p>
<p>2.a = 1; //定义</p>
<p>3.int b = 1; //声明并定义</p>
<p>如果使用了extern关键字，则代表该变量是其他地方分配的。</p>
<p>1.extern int a;</p>
<h2 id="4-3-命名冲突与static修饰符"><a href="#4-3-命名冲突与static修饰符" class="headerlink" title="4.3 命名冲突与static修饰符"></a>4.3 命名冲突与static修饰符</h2><h3 id="4-3-1-变量"><a href="#4-3-1-变量" class="headerlink" title="4.3.1 变量"></a>4.3.1 变量</h3><p>static修饰的变量只会初始化一次，其值固定在内存空间直至销毁，所以如果再次对其进行赋值是无效的。</p>
<p>static变量可以重名，不会发生冲突</p>
<p>1.static int a;</p>
<p>2.int a;</p>
<h3 id="4-3-2-函数"><a href="#4-3-2-函数" class="headerlink" title="4.3.2 函数"></a>4.3.2 函数</h3><p>static声明的函数可以在外部使用，一般称其为静态函数。</p>
<p>1.static int g(int x)</p>
<p>2.{</p>
<p>3…..</p>
<p>4.}</p>
<p>5.</p>
<p>6.void f()</p>
<p>7.{</p>
<ol start="8">
<li>b = g(a);</li>
</ol>
<p>9.}</p>
<h2 id="4-4-形参、实参与返回值"><a href="#4-4-形参、实参与返回值" class="headerlink" title="4.4 形参、实参与返回值"></a>4.4 形参、实参与返回值</h2><h3 id="4-4-1-形参实参的区别"><a href="#4-4-1-形参实参的区别" class="headerlink" title="4.4.1 形参实参的区别"></a>4.4.1 形参实参的区别</h3><p>老生常谈了，用段代码来解释下形参和实参。</p>
<p>1.#include&lt;stdio.h&gt;</p>
<p>2.void swap(int a,int b)</p>
<p>3.{</p>
<ol start="4">
<li>int c = a;</li>
</ol>
<p>5.#include&lt;stdio.h&gt;</p>
<p>6.void swap(int a,int b) //传的形参</p>
<p>7.{</p>
<ol start="8">
<li><p>int c = a;</p>
</li>
<li><p>a = b;</p>
</li>
<li><p>b = c;</p>
</li>
</ol>
<p>11.}</p>
<p>12.void swap1(int *a,int *b) //传实参</p>
<p>13.{</p>
<p>14.</p>
<ol start="15">
<li><p>int c = *a;</p>
</li>
<li><p>*a = *b;</p>
</li>
<li><p>*b = c;</p>
</li>
</ol>
<p>18.}</p>
<p>19.int main()</p>
<p>20.{</p>
<ol start="21">
<li><p>int a = 1,b = 2;</p>
</li>
<li><p>swap(a,b); //没有交换</p>
</li>
<li><p>printf(“%d %d\n”,a ,b);</p>
</li>
<li><p>swap1(&amp;a,&amp;b); //交换了</p>
</li>
<li><p>printf(“%d %d\n”,a , b);</p>
</li>
<li><p>return 0 ;</p>
</li>
</ol>
<p>27.}</p>
<h3 id="4-4-2-强制转换"><a href="#4-4-2-强制转换" class="headerlink" title="4.4.2 强制转换"></a>4.4.2 强制转换</h3><p>当函数指定了参数类型，会进行强制转换，比如：</p>
<p>1.double square(double);</p>
<p>2.square(2); //合法，会自动转换为双精度类型</p>
<h3 id="4-4-3-返回值"><a href="#4-4-3-返回值" class="headerlink" title="4.4.3 返回值"></a>4.4.3 返回值</h3><p>函数除了构造函数和析构函数之外，都要声明返回值，void或者其他类型。</p>
<h2 id="4-5-检查外部类型"><a href="#4-5-检查外部类型" class="headerlink" title="4.5 检查外部类型"></a>4.5 检查外部类型</h2><p>在引用外部变量的时候要注意最好是类型一样，比如：</p>
<p>1.char filename[] = “/etc/passwd”;</p>
<p>2.</p>
<p>3.extern char* filename; //外部引用</p>
<p>虽然指针与数组好像是一样的，但是filename的类型是“字符数组”，而不是“字符指针”。在第二个声明中，filename被确定为一个指针。这两个对filename的声明使用存储空间的方式是不同的。</p>
<h4 id="原内存布局"><a href="#原内存布局" class="headerlink" title="原内存布局"></a>原内存布局</h4><p><img src="https://tanwenbo.top/wp-content/uploads/2018/06/e98054d288ab979ab00d1b0319cfc674.png" alt=""></p>
<h4 id="现内存布局"><a href="#现内存布局" class="headerlink" title="现内存布局"></a>现内存布局</h4><p><img src="https://tanwenbo.top/wp-content/uploads/2018/06/b8923f18c4555c4870fdfd935f6c55e7.png" alt=""></p>
<p>应该改为同样类型：</p>
<p>1.char filename[] = “/etc”;</p>
<p>2.extern char filename[];</p>
<p>3.</p>
<p>4.char* filename= “/etc”;</p>
<p>5.extern char* filename;</p>
<h2 id="4-6-头文件"><a href="#4-6-头文件" class="headerlink" title="4.6 头文件"></a>4.6 头文件</h2><p>每个外部对象应只在一个头文件中声明，需要用到该外部对象的所有模块都应该包括这个头文件。定义该外部对象的模块也应该包括这个头文件。比如：</p>
<p>public.h</p>
<p>1.int a = 1;</p>
<p>2.char* str = “123”;</p>
<p>main.c</p>
<p>1.#include &lt;stdio.h&gt;</p>
<p>2.#include “public.h”</p>
<p>3.extern int a;</p>
<p>4.extern char* str;</p>
<p>5.int main()</p>
<p>6.{</p>
<ol start="7">
<li><p>printf(“%d\n”,a);</p>
</li>
<li><p>return 0;</p>
</li>
</ol>
<p>9.}</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C语言的连接是一个很强大的东西，将小的模块组成大的模块，文件和变量之间能很好的进行交互，从而达到高内聚低耦合的效果。</p>
<p>%23%u7B2C%u56DB%u7AE0%20%u8FDE%u63A5%0A@%28%u300AC%u9677%u9631%u4E0E%u7F3A%u9677%u300B%u5B66%u4E60%u7B14%u8BB0%29%5B%u5F62%u53C2%7C%u5B9E%u53C2%7Cstatic%7Cposts%5D%0A%0A%5BTOC%5D%0A%0A%23%23%204.1%20%u4EC0%u4E48%u662F%u8FDE%u63A5%u5668%0A%3E%20%u5728C%u8BED%u8A00%u4E2D%uFF0C%u4E00%u4E2A%u91CD%u8981%u7684%u601D%u60F3%u5C31%u662F%u5206%u522B%u7F16%u8BD1%uFF0C%u5373%u82E5%u5E72%u4E2A%u6E90%u7A0B%u5E8F%u53EF%u4EE5%u5728%u4E0D%u540C%u7684%u65F6%u5019%u5355%u72EC%u8FDB%u884C%u7F16%u8BD1%uFF0C%u7136%u540E%u5728%u6070%u5F53%u7684%u65F6%u5019%u6574%u5408%u5230%u4E00%u8D77%u3002%u4F46%u662F%u8FDE%u63A5%u5668%u4E00%u822C%u662F%u4E0EC%u7F16%u8BD1%u5668%u5206%u79BB%u7684%uFF0C%u8FDE%u63A5%u5668%u5982%u4F55%u505A%u5230%u628A%u82E5%u5E72%u4E2AC%u6E90%u7A0B%u5E8F%u5408%u5E76%u6210%u4E00%u4E2A%u6574%u4F53%u5462%uFF1F%0A%3E%20%u5178%u578B%u7684%u8FDE%u63A5%u5668%u628A%u7531%u7F16%u8BD1%u5668%u6216%u6C47%u7F16%u5668%u751F%u6210%u7684%u82E5%u5E72%u4E2A%u76EE%u6807%u6A21%u5757%uFF0C%u6574%u5408%u6210%u4E00%u4E2A%u88AB%u79F0%u4E3A%u8F7D%u5165%u6A21%u5757%u6216%u53EF%u6267%u884C%u6587%u4EF6%u7684%u5B9E%u4F53%uFF0C%u8BE5%u5B9E%u4F53%u80FD%u591F%u88AB%u64CD%u4F5C%u7CFB%u7EDF%u76F4%u63A5%u6267%u884C%u3002%u5176%u4E2D%uFF0C%u67D0%u4E9B%u76EE%u6807%u6A21%u5757%u662F%u76F4%u63A5%u4F5C%u4E3A%u8F93%u5165%u63D0%u4F9B%u7ED9%u8FDE%u63A5%u5668%u7684%uFF1B%u800C%u53E6%u5916%u4E00%u4E9B%u76EE%u6807%u6A21%u5757%u5219%u662F%u6839%u636E%u8FDE%u63A5%u8FC7%u7A0B%u7684%u9700%u8981%uFF0C%u4ECE%u5305%u62EC%u6709%u7C7B%u4F3Cprintf%u51FD%u6570%u7684%u5E93%u6587%u4EF6%u4E2D%u53D6%u5F97%u7684%u3002%0A%0A%u7B80%u800C%u8A00%u4E4B%uFF0C%u8FDE%u63A5%u5668%u5C31%u662F%u7528%u6765%u8FDE%u63A5%u5404%u4E2A%u7F16%u8BD1%u597D%u7684%u6A21%u5757%uFF0C%u7136%u540E%u5C06%u5176%u7EC4%u6210%u4E00%u4E2A%u6A21%u5757%u6216%u8005%u53EF%u6267%u884C%u6587%u4EF6%u3002%u4E14%u4F1A%u68C0%u67E5%u5916%u90E8%u5BF9%u8C61%u662F%u5426%u6709%u91CD%u590D%uFF0C%u91CD%u590D%u5219%u62A5%u9519%u3002%u56E0%u4E3A<strong>%u5927%u591A%u6570%u8FDE%u63A5%u5668%u90FD%u8FDB%u5236%u540C%u4E00%u4E2A%u8F7D%u5165%u6A21%u5757%u4E2D%u7684%u4E24%u4E2A%u4E0D%u540C%u5BF9%u8C61%u62E5%u6709%u76F8%u540C%u7684%u540D%u79F0</strong>%u3002%0A%0A%23%23%204.2%20%u58F0%u660E%u548C%u5B9A%u4E49%0A%u58F0%u660E%u5728%u51FD%u6570%u4F53%u4E4B%u5916%u7684%u53D8%u91CF%u662F<strong>%u5168%u5C40%u53D8%u91CF</strong>%uFF0C%u4E5F%u79F0%u4E3A<strong>%u5916%u90E8%u5BF9%u8C61</strong>%u3002%0A%60%60%60c%0Aint%20a%3B%09%09%09%09//%u58F0%u660E%0Aa%20%3D%201%3B%09%09%09%09//%u5B9A%u4E49%0Aint%20b%20%3D%201%3B%09%09%09//%u58F0%u660E%u5E76%u5B9A%u4E49%0A%60%60%60%0A%u5982%u679C%u4F7F%u7528%u4E86extern%u5173%u952E%u5B57%uFF0C%u5219%u4EE3%u8868%u8BE5%u53D8%u91CF%u662F%u5176%u4ED6%u5730%u65B9%u5206%u914D%u7684%u3002%0A%60%60%60c%0Aextern%20int%20a%3B%0A%60%60%60%0A%0A%23%23%204.3%20%u547D%u540D%u51B2%u7A81%u4E0Estatic%u4FEE%u9970%u7B26%0A%23%23%23%204.3.1%20%u53D8%u91CF%0Astatic%u4FEE%u9970%u7684%u53D8%u91CF%u53EA%u4F1A%60%60%u521D%u59CB%u5316%u4E00%u6B21%60%60%uFF0C%u5176%u503C%u56FA%u5B9A%u5728%u5185%u5B58%u7A7A%u95F4%u76F4%u81F3%u9500%u6BC1%uFF0C<strong>%u6240%u4EE5%u5982%u679C%u518D%u6B21%u5BF9%u5176%u8FDB%u884C%u8D4B%u503C%u662F%u65E0%u6548%u7684%u3002</strong>%0A%0Astatic%u53D8%u91CF%u53EF%u4EE5%60%u91CD%u540D%60%uFF0C%u4E0D%u4F1A%u53D1%u751F%u51B2%u7A81%0A%60%60%60c%20%0Astatic%20int%20a%3B%0Aint%20a%3B%0A%60%60%60%0A%0A%23%23%23%204.3.2%20%u51FD%u6570%0Astatic%u58F0%u660E%u7684%u51FD%u6570%u53EF%u4EE5%u5728%u5916%u90E8%u4F7F%u7528%uFF0C%u4E00%u822C%u79F0%u5176%u4E3A%60%u9759%u6001%u51FD%u6570%60%u3002%0A%60%60%60c%0Astatic%20int%20g%28int%20x%29%0A%7B%0A….%0A%7D%20%0A%0Avoid%20f%28%29%0A%7B%0A%09b%20%3D%20g%28a%29%3B%0A%7D%0A%60%60%60%0A%0A%23%23%204.4%20%u5F62%u53C2%u3001%u5B9E%u53C2%u4E0E%u8FD4%u56DE%u503C%0A%23%23%23%204.4.1%20%u5F62%u53C2%u5B9E%u53C2%u7684%u533A%u522B%0A%u8001%u751F%u5E38%u8C08%u4E86%uFF0C%u7528%u6BB5%u4EE3%u7801%u6765%u89E3%u91CA%u4E0B%60%u5F62%u53C2%60%u548C%60%u5B9E%u53C2%60%u3002%0A%60%60%60C%0A%23include%3Cstdio.h%3E%0Avoid%20swap%28int%20a%2Cint%20b%29%0A%7B%0A%20%20%20%20int%20c%20%3D%20a%3B%0A%23include%3Cstdio.h%3E%0Avoid%20swap%28int%20a%2Cint%20b%29%09%09//%u4F20%u7684%u5F62%u53C2%0A%7B%20%20%20%0A%20%20%20%20int%20c%20%3D%20a%3B%0A%20%20%20%20a%20%3D%20b%3B%0A%20%20%20%20b%20%3D%20c%3B%0A%7D%0Avoid%20swap1%28int%20*a%2Cint%20*b%29%20%09//%u4F20%u5B9E%u53C2%0A%7B%0A%0A%20%20%20%20int%20c%20%3D%20*a%3B%20%0A%20%20%20%20*a%20%3D%20*b%3B%20%0A%20%20%20%20*b%20%3D%20c%3B%0A%7D%0Aint%20main%28%29%0A%7B%0A%20%20%20%20int%20a%20%3D%201%2Cb%20%3D%202%3B%0A%20%20%20%20swap%28a%2Cb%29%3B%20%20%20//%u6CA1%u6709%u4EA4%u6362%0A%20%20%20%20printf%28%22%25d%20%25d%5Cn%22%2Ca%20%2Cb%29%3B%20%20%20%20%0A%20%20%20%20swap1%28%26a%2C%26b%29%3B%20%20%20//%u4EA4%u6362%u4E86%0A%20%20%20%20printf%28%22%25d%20%25d%5Cn%22%2Ca%20%2C%20b%29%3B%0A%20%20%20%20return%200%20%3B%0A%7D%0A%60%60%60%0A%23%23%23%204.4.2%20%u5F3A%u5236%u8F6C%u6362%0A%u5F53%u51FD%u6570%u6307%u5B9A%u4E86%u53C2%u6570%u7C7B%u578B%uFF0C%u4F1A%u8FDB%u884C%60%u5F3A%u5236%u8F6C%u6362%60%uFF0C%u6BD4%u5982%uFF1A%0A%60%60%60C%0Adouble%20square%28double%29%3B%0Asquare%282%29%3B%20%09%09%09//%u5408%u6CD5%uFF0C%u4F1A%u81EA%u52A8%u8F6C%u6362%u4E3A%u53CC%u7CBE%u5EA6%u7C7B%u578B%0A%60%60%60%0A%23%23%23%204.4.3%20%u8FD4%u56DE%u503C%0A%u51FD%u6570%u9664%u4E86%60%u6784%u9020%u51FD%u6570%60%u548C%60%u6790%u6784%u51FD%u6570%60%u4E4B%u5916%uFF0C%u90FD%u8981%u58F0%u660E%u8FD4%u56DE%u503C%uFF0Cvoid%u6216%u8005%u5176%u4ED6%u7C7B%u578B%u3002%0A%0A%23%23%204.5%20%u68C0%u67E5%u5916%u90E8%u7C7B%u578B%0A%u5728%u5F15%u7528%60%u5916%u90E8%u53D8%u91CF%60%u7684%u65F6%u5019%u8981%u6CE8%u610F%u6700%u597D%u662F%u7C7B%u578B%u4E00%u6837%uFF0C%u6BD4%u5982%uFF1A%0A%60%60%60c%0Achar%20filename%5B%5D%20%3D%20%22/etc/passwd%22%3B%0A%0Aextern%20char<em>%20filename%3B%09//%u5916%u90E8%u5F15%u7528%0A%60%60%60%0A%u867D%u7136%u6307%u9488%u4E0E%u6570%u7EC4%u597D%u50CF%u662F%u4E00%u6837%u7684%uFF0C%u4F46%u662F%60filename%60%u7684%u7C7B%u578B%u662F%u201C%60%u5B57%u7B26%u6570%u7EC4%60%u201D%uFF0C%u800C%u4E0D%u662F%60%u201C%u5B57%u7B26%u6307%u9488%u201D%60%u3002%u5728%u7B2C%u4E8C%u4E2A%u58F0%u660E%u4E2D%uFF0C%60filename%60%u88AB%u786E%u5B9A%u4E3A%u4E00%u4E2A%60%u6307%u9488%60%u3002%u8FD9%u4E24%u4E2A%u5BF9%60filename%60%u7684%u58F0%u660E%u4F7F%u7528%u5B58%u50A8%u7A7A%u95F4%u7684%u65B9%u5F0F%u662F%u4E0D%u540C%u7684%u3002%0A%0A%23%23%23%23%20%u539F%u5185%u5B58%u5E03%u5C40%0A%21%5BAlt%20text%5D%28./1524645704928.png%29%0A%23%23%23%23%20%u73B0%u5185%u5B58%u5E03%u5C40%0A%21%5BAlt%20text%5D%28./1524645774249.png%29%0A%0A%u5E94%u8BE5%u6539%u4E3A%u540C%u6837%u7C7B%u578B%uFF1A%0A%60%60%60C%0Achar%20filename%5B%5D%20%3D%20%22/etc%22%3B%0Aextern%20char%20filename%5B%5D%3B%0A%0Achar</em>%20filename%3D%20%22/etc%22%3B%0Aextern%20char<em>%20filename%3B%0A%60%60%60%0A%0A%23%23%204.6%20%u5934%u6587%u4EF6%0A%u6BCF%u4E2A%u5916%u90E8%u5BF9%u8C61%u5E94%u53EA%u5728%u4E00%u4E2A%60%u5934%u6587%u4EF6%60%u4E2D%u58F0%u660E%uFF0C%u9700%u8981%u7528%u5230%u8BE5%u5916%u90E8%u5BF9%u8C61%u7684%60%u6240%u6709%u6A21%u5757%60%u90FD%u5E94%u8BE5%u5305%u62EC%u8FD9%u4E2A%60%u5934%u6587%u4EF6%60%u3002%u5B9A%u4E49%u8BE5%u5916%u90E8%u5BF9%u8C61%u7684%u6A21%u5757%u4E5F%u5E94%u8BE5%u5305%u62EC%u8FD9%u4E2A%60%u5934%u6587%u4EF6%60%u3002%u6BD4%u5982%uFF1A%0A%0A**public.h*\</em>%0A%60%60%60c%0Aint%20a%20%3D%201%3B%0Achar<em>%20str%20%3D%20%22123%22%3B%0A%60%60%60%0A**main.c*\</em>%0A%60%60%60c%0A%23include%20%3Cstdio.h%3E%0A%23include%20%22public.h%22%0Aextern%20int%20a%3B%0Aextern%20char<em>%20str%3B%0Aint%20main%28%29%0A%7B%0A%09printf%28%22%25d%5Cn%22%2Ca%29%3B%0A%09return%200%3B%0A%7D%0A%60%60%60%0A%23%23%20%u603B%u7ED3%0AC%u8BED%u8A00%u7684%u8FDE%u63A5%u662F%u4E00%u4E2A%u5F88%u5F3A%u5927%u7684%u4E1C%u897F%uFF0C%u5C06%u5C0F%u7684%u6A21%u5757%u7EC4%u6210%u5927%u7684%u6A21%u5757%uFF0C%u6587%u4EF6%u548C%u53D8%u91CF%u4E4B%u95F4%u80FD%u5F88%u597D%u7684%u8FDB%u884C%u4EA4%u4E92%uFF0C%u4ECE%u800C%u8FBE%u5230*</em>%u9AD8%u5185%u805A%u4F4E%u8026%u5408**%u7684%u6548%u679C%u3002%0A%0A</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/24/3-e8-af-ad-e4-b9-89-e9-99-b7-e9-98-b1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/24/3-e8-af-ad-e4-b9-89-e9-99-b7-e9-98-b1/" class="post-title-link" itemprop="url">第三章 语义“陷阱”</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-24 03:19:47" itemprop="dateCreated datePublished" datetime="2018-04-24T03:19:47+08:00">2018-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第三章-语义“陷阱”"><a href="#第三章-语义“陷阱”" class="headerlink" title="第三章 语义“陷阱”"></a>第三章 语义“陷阱”</h1><p><code>《C陷阱与缺陷》学习笔记``指针``数组``posts</code></p>
<ul>
<li><a href="#第三章-语义陷阱">第三章 语义“陷阱”</a><ul>
<li><a href="#31-指针与数组">3.1 指针与数组</a><ul>
<li><a href="#311-数组名的使用">3.1.1 数组名的使用</a></li>
<li><a href="#312-指针的使用">3.1.2 指针的使用</a></li>
<li><a href="#313-二维数组">3.1.3 二维数组</a></li>
<li><a href="#314-二维数组名的使用">3.1.4 二维数组名的使用</a></li>
</ul>
</li>
<li><a href="#32-非数组的指针">3.2 非数组的指针</a></li>
<li><a href="#33-作为参数的数组声明">3.3 作为参数的数组声明</a></li>
<li><a href="#34-避免举隅法">3.4 避免“举隅法”</a><ul>
<li><a href="#341-指针复制问题">3.4.1 指针复制问题</a></li>
</ul>
</li>
<li><a href="#35-空指针并非空字符串">3.5 空指针并非空字符串</a></li>
<li><a href="#36-边界计算与不对称边界">3.6 边界计算与不对称边界</a><ul>
<li><a href="#361-规定编码风格">3.6.1 规定编码风格</a></li>
</ul>
</li>
<li><a href="#37-求值顺序">3.7 求值顺序</a></li>
<li><a href="#38-运算符和">3.8 运算符&amp;&amp;、||和!</a></li>
<li><a href="#39-整数溢出">3.9 整数溢出</a></li>
<li><a href="#310-main函数的返回值">3.10 main函数的返回值</a></li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
</ul>
<h2 id="3-1-指针与数组"><a href="#3-1-指针与数组" class="headerlink" title="3.1 指针与数组"></a>3.1 指针与数组</h2><p>数组其实就是由指针实现的，任何数组下标运算都等同于一个对应的指针运算。</p>
<pre><code>1.int *ip;
2.int i; 
3.ip = &amp;i; //地址赋值，使ip指向了整型变量i
4.*ip = 17; //通过指针修改i的值， </code></pre><h3 id="3-1-1-数组名的使用"><a href="#3-1-1-数组名的使用" class="headerlink" title="3.1.1 数组名的使用"></a>3.1.1 数组名的使用</h3><p>如果直接使用数组名（一维数组），那么数组名就当作指向该数组下标为0的元素的指针。</p>
<pre><code>1.int a[10];
2.int *p;
3.p = a; //p指向了a数组的首地址
4.int num = *p; //*p就是a[0]的值 </code></pre><h3 id="3-1-2-指针的使用"><a href="#3-1-2-指针的使用" class="headerlink" title="3.1.2 指针的使用"></a>3.1.2 指针的使用</h3><p>指针有时候也可以当成数组使用，二者意思相等。</p>
<pre><code>1.int a[10];
2.int *p;
3.p = a + 2; //p指向了a[2]
4.p++; //p指向了a[3]
5. </code></pre><h3 id="3-1-3-二维数组"><a href="#3-1-3-二维数组" class="headerlink" title="3.1.3 二维数组"></a>3.1.3 二维数组</h3><pre><code>1.int calendar[12][31];
2.int *p;
3.int i;
4.p = calendar[4]; //p指向了calender[4]中下标为0的元素
5.//下面三个式子意思一样
6.i = calendar[4][7];
7.i = *(calendar[4] + 7);
8.i = *(*calendar+4) + 7);</code></pre><p>记住解引用的用法，和数组[]符号意思一样。</p>
<h3 id="3-1-4-二维数组名的使用"><a href="#3-1-4-二维数组名的使用" class="headerlink" title="3.1.4 二维数组名的使用"></a>3.1.4 二维数组名的使用</h3><p>一维数组可以直接使用数组名，但是二维数组不行。比如：</p>
<pre><code>1.int calendar[12][31];
2.int *p;
3.p = calendar; //非法，因为p是指向整型变量的指针，calender是指向数组的指针，类型不同</code></pre><p>需要声明一种指向数组的指针的方法，需要类型相同</p>
<pre><code>1.int calendar[12][31];
2.int (*monthp)[31];
3.monthp = calendar; </code></pre><h2 id="3-2-非数组的指针"><a href="#3-2-非数组的指针" class="headerlink" title="3.2 非数组的指针"></a>3.2 非数组的指针</h2><p><strong>任何指针都需要初始化，否则会成为野指针</strong></p>
<blockquote>
<p>野指针指向一个已删除的对象或未申请访问受限内存区域的指针。与空指针不同，野指针无法通过简单地判断是否为 NULL避免，而只能通过养成良好的编程习惯来尽力减少。对野指针进行操作很容易造成程序错误。</p>
</blockquote>
<p>简单归纳如下：</p>
<ul>
<li><p>指针需要初始化，指向NULL或者一块内存区域;</p>
</li>
<li><p>分配的内存使用完后要及时释放;</p>
</li>
<li><p>malloc分配内存的时候应在字符长度的基础上+1，用来存放结束标志。</p>
<p>1.char *r;<br>2.r = malloc(strlen(s) + 1); </p>
</li>
</ul>
<h2 id="3-3-作为参数的数组声明"><a href="#3-3-作为参数的数组声明" class="headerlink" title="3.3 作为参数的数组声明"></a>3.3 作为参数的数组声明</h2><p>将数组作为参数传到函数里，C语言会自动的将作为参数的数组声明转换成相应的指针声明，所以在传数组的时候只需要写数组名，不需要写大小。</p>
<pre><code>1.int strlen(char s[]) 等于 int strlen(char *s) //都是将首地址传了进去 </code></pre><h2 id="3-4-避免“举隅法”"><a href="#3-4-避免“举隅法”" class="headerlink" title="3.4 避免“举隅法”"></a>3.4 避免“举隅法”</h2><p><strong>简单来说就是不要以<code>整体</code>代表<code>部分</code>，或者以<code>部分</code>代表<code>整体</code></strong></p>
<pre><code>1.char *p, *q;
2.p = &quot;xyz&quot;;</code></pre><p>之前可能以为p的值就是字符串<code>“xyz”</code>，其实不然，p是一个指向由<code>&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;\0&#39;</code>，4个字符组成的数组的起始元素的指针。</p>
<h3 id="3-4-1-指针复制问题"><a href="#3-4-1-指针复制问题" class="headerlink" title="3.4.1 指针复制问题"></a>3.4.1 指针复制问题</h3><p>如果直接执行</p>
<pre><code>1.q = p;</code></pre><p>程序并没有想象中的那样所有值都复制了过来，而是都指向同一地址。</p>
<p><strong>需要记住，复制指针并不同时复制指针指向的数据</strong> 而且如果通过<code>q</code>来修改指针内容，那么<code>p</code>的内容也变了</p>
<pre><code>1.q[1] = &apos;Y&apos;;</code></pre><p>这个时候内存变为<code>&quot;xYz&quot;</code>,p[1]也是<code>&#39;Y&#39;</code>。</p>
<h2 id="3-5-空指针并非空字符串"><a href="#3-5-空指针并非空字符串" class="headerlink" title="3.5 空指针并非空字符串"></a>3.5 空指针并非空字符串</h2><p>在C语言中，<code>NULL</code>和<code>0</code>的值都是一样的，但是为了目的和用途以及容易识别的原因，<strong><code>NULL</code>用于指针和对象，<code>0</code>用于数值对与字符串的结尾，使用’\0’</strong> 在不同的系统中，<code>NULL</code>并非总是和<code>0</code>等同，<strong><code>NULL</code>仅仅代表空值，也就是指向一个不被使用的地址</strong></p>
<h2 id="3-6-边界计算与不对称边界"><a href="#3-6-边界计算与不对称边界" class="headerlink" title="3.6 边界计算与不对称边界"></a>3.6 边界计算与不对称边界</h2><p>C语言里边界问题是一个很容易出错的地方，比如：满足边界X&gt;=16且X&lt;=37的整数有多少个？ 按常规思考，会计算出37-16 = 21个数，但是其实是22个。</p>
<h3 id="3-6-1-规定编码风格"><a href="#3-6-1-规定编码风格" class="headerlink" title="3.6.1 规定编码风格"></a>3.6.1 规定编码风格</h3><p><strong><code>入界点</code></strong>在取值范围里，<strong><code>出界点</code></strong>不在取值范围里。这样的操作带来的效果是惊人的：</p>
<ul>
<li><strong>取值范围的大小就是上界与下界之差；</strong>。</li>
<li><strong>如果取值范围为空，那么上界等于下界；</strong></li>
<li><strong>即使取值范围为空，上界也永远不可能小于下界。</strong></li>
</ul>
<h2 id="3-7-求值顺序"><a href="#3-7-求值顺序" class="headerlink" title="3.7 求值顺序"></a>3.7 求值顺序</h2><p>在使用if语句的时候可能会用到多个条件判断，C语言中判断的顺序是从左至右，比如:</p>
<pre><code>1.if(a &gt; b &amp;&amp; a &gt; c) //如果a &gt; b成立才会判断a &gt; c，不会先判断a &gt; c
2.max = a; </code></pre><h2 id="3-8-运算符-amp-amp-、-和"><a href="#3-8-运算符-amp-amp-、-和" class="headerlink" title="3.8 运算符&amp;&amp;、||和!"></a>3.8 运算符&amp;&amp;、||和!</h2><p>这些都是逻辑运算符，用来判断语句的正确性，可以相互组合起来。但是有时候会<code>少写</code>一个，编译器也不会报错，需要十分小心。</p>
<h2 id="3-9-整数溢出"><a href="#3-9-整数溢出" class="headerlink" title="3.9 整数溢出"></a>3.9 整数溢出</h2><p>C语言里有两类整数算术运算</p>
<ul>
<li><code>无符号运算</code></li>
<li><code>有符号运算</code></li>
</ul>
<p>在无符号算术中，没有“溢出”的说法。</p>
<h2 id="3-10-main函数的返回值"><a href="#3-10-main函数的返回值" class="headerlink" title="3.10 main函数的返回值"></a>3.10 main函数的返回值</h2><p>main函数会有返回值，就想我们平时写程序一样：</p>
<pre><code>1.int main()
2.{
3.        ...
4.        return 0;
5.}</code></pre><p>返回值为<code>0</code>代表程序执行成功，返回值<code>非0</code>则表示程序执行失败！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>数组就是由指针实现的，在进行一些数组操作的时候可以当成指针来使用。同理，在对指针进行操作的时候也可以将其当成数组来操作；</li>
<li>函数传指针或者数组，只需要传首地址即可；</li>
<li>数组不要越界，在遍历的时候遵循<strong><code>“满下界，空上界”</code></strong>原则。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/21/e8-af-ad-e6-b3-95-e9-87-8c-e5-b8-b8-e8-a7-81-e7-9a-84-e9-94-99-e8-af-af/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/21/e8-af-ad-e6-b3-95-e9-87-8c-e5-b8-b8-e8-a7-81-e7-9a-84-e9-94-99-e8-af-af/" class="post-title-link" itemprop="url">语法里常见的错误</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-21 03:07:32" itemprop="dateCreated datePublished" datetime="2018-04-21T03:07:32+08:00">2018-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-语句结束符的分号"><a href="#1-语句结束符的分号" class="headerlink" title="1 语句结束符的分号"></a>1 语句结束符的分号</h3><p>如果在写代码的时候少写了分号或者多加了分号，这样的错误带来的后果是很严重的。有时候编译器可能都不会对其进行报错，这样导致你寻找错误的成本大大增加。比如：</p>
<pre><code>if(x[i] &gt; big);
    big = x[i];</code></pre><p>编译器会正常地接收第一行代码中的分号而不会提示任何警告信息，正确的做法应该是：</p>
<pre><code>if(x[i] &gt; big)
    big = x[i];</code></pre><h3 id="2-switch语句"><a href="#2-switch语句" class="headerlink" title="2 switch语句"></a>2 switch语句</h3><p>C语言的switch语句的控制流程能够依次通过并执行各个case部分，这一点是C语言与众不同之处。但是你有时候会忘记写break语句，这样就会造成意想不到的后果，比如：</p>
<pre><code>switch(color){
case 1:printf(&quot;red&quot;);
case 2:printf(&quot;yellow&quot;);
case 3:printf(&quot;blue&quot;);
}</code></pre><p>如果当color的值为2的时候，编译器会输出“yellowblue”。因为程序的控制流程在执行了第二个printf函数的调用之后，会自然而然的顺序执行下去，第三个printf函数调用也会被执行。所以在写switch语句的时候要相当注意，不过有时候你的需求就是不用加break，那么最好在程序里写上你的注释，这样别人就不会以为是忽略的错误。</p>
<pre><code>case SUBTRACT:
            opnd2 = -opnd2;
            //此处没有break语句

case ADD:
            .....</code></pre><h3 id="3-“悬挂”else引发的问题"><a href="#3-“悬挂”else引发的问题" class="headerlink" title="3 “悬挂”else引发的问题"></a>3 “悬挂”else引发的问题</h3><p><strong>else始终会与同一对括号内最近的且未匹配的if结合</strong></p>
<h3 id="练习2-1"><a href="#练习2-1" class="headerlink" title="练习2-1"></a>练习2-1</h3><p>C语言允许初始化列表中出现多余的逗号，例如：</p>
<pre><code>int days[] = { 31, 28 ,31 , 31,};</code></pre><p>为什么这种特性是有用的？答：方便自动化编写代码，不用单独处理。</p>
<p>​</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tanwenbo</p>
  <div class="site-description" itemprop="description">enjoy share</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">114</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">71</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tanwenbo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
