<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="enjoy share">
<meta property="og:type" content="website">
<meta property="og:title" content="hhyvs111">
<meta property="og:url" content="http://yoursite.com/page/9/index.html">
<meta property="og:site_name" content="hhyvs111">
<meta property="og:description" content="enjoy share">
<meta property="article:author" content="tanwenbo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>hhyvs111</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hhyvs111</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Be a great man</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/11/arp-e5-8d-8f-e8-ae-ae/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/11/arp-e5-8d-8f-e8-ae-ae/" class="post-title-link" itemprop="url">ARP协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-11 03:24:01" itemprop="dateCreated datePublished" datetime="2018-05-11T03:24:01+08:00">2018-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h1><p><code>《TCP/IP详解 卷1：协议》``posts</code></p>
<ul>
<li><a href="#arp协议">ARP协议</a><ul>
<li><a href="#1-引言">1 引言</a></li>
<li><a href="#2-arp-帧格式">2 ARP 帧格式</a></li>
<li><a href="#3-arp的位置">3 ARP的位置</a></li>
<li><a href="#4-arp高速缓存">4 ARP高速缓存</a><ul>
<li><a href="#41-定义">4.1 定义</a></li>
<li><a href="#42-arp高速缓存的使用">4.2 ARP高速缓存的使用</a></li>
<li><a href="#43-arp高速缓存的优缺点">4.3 ARP高速缓存的优缺点</a></li>
</ul>
</li>
<li><a href="#5-免费arp">5 免费ARP</a></li>
<li><a href="#6-代理arp">6 代理ARP</a></li>
</ul>
</li>
</ul>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>如果一台主机要将一个帧发送到另一台主机，仅知道这台主机的IP地址是不够的，还需要知道主机在网络中的有<strong>有效硬件地址</strong>。操作系统软件必须知道目的主机的硬件地址，以便直接向它发送数据。对于TCP/IP网络，<strong>地址解析协议（ARP）</strong>提供了一种在<code>IPv4</code>地址和各种网络技术使用的硬件地址之间的<strong>映射</strong>。 ARP用于32为IPv4地址和以太网的48位MAC地址之间的映射。</p>
<h2 id="2-ARP-帧格式"><a href="#2-ARP-帧格式" class="headerlink" title="2 ARP 帧格式"></a>2 ARP 帧格式</h2><p>和TCP等差不多，ARP也有自己的格式。 <img src="http://tanwenbo.top/wp-content/uploads/2018/05/2392a0945708651d67d53f13fbc682a7.png" alt=""></p>
<p>字段</p>
<p>长度</p>
<p>作用</p>
<p>DST</p>
<p>6字节</p>
<p>以太网目的地址</p>
<p>SRC</p>
<p>6字节</p>
<p>以太网源地址</p>
<p>长度或类型</p>
<p>2字节</p>
<p>后面的数据类型，ARP请求和ARP应答这个值为0x0806</p>
<p>硬件类型</p>
<p>2字节</p>
<p>硬件地址不只以太网一种，是以太网类型时此值为1</p>
<p>协议类型</p>
<p>2字节</p>
<p>表示要映射的协议地址的类型，要对IPv4地址进行映射，此值为0x0800</p>
<p>硬件大小</p>
<p>1字节</p>
<p>硬件地址长度，MAC地址占6字节</p>
<p>协议大小</p>
<p>1字节</p>
<p>协议地址长度，IP地址占4字节</p>
<p>op</p>
<p>2字节</p>
<p>值为1，表示进行<code>ARP请求</code>；值为2，表示进行<code>ARP应答</code>；值为3，表示进行<code>RARP请求</code>；值为4，表示进行<code>RARP应答</code></p>
<p>发送端以太网地址</p>
<p>6字节</p>
<p>发送端ARP请求或应答的硬件地址，这里是以太网地址，和字段2相同</p>
<p>发送端IP地址</p>
<p>4字节</p>
<p>发送ARP请求或应答的IP地址</p>
<p>目的以太网地址</p>
<p>6字节</p>
<p>目的端的硬件地址</p>
<p>目的IP地址</p>
<p>4字节</p>
<p>目的端的协议地址</p>
<h2 id="3-ARP的位置"><a href="#3-ARP的位置" class="headerlink" title="3 ARP的位置"></a>3 ARP的位置</h2><p>OSI模型有七层，<code>TCP</code>在<code>第4层传输层</code>，<code>IP</code>在<code>第3层网络层</code>，而<code>ARP</code>在<code>第2层数据链路层</code>。高层对低层是有强依赖的，所以TCP的建立前要进行ARP的请求和应答。</p>
<h2 id="4-ARP高速缓存"><a href="#4-ARP高速缓存" class="headerlink" title="4 ARP高速缓存"></a>4 ARP高速缓存</h2><h3 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h3><p>ARP缓存是一个缓冲区，用来储存IP地址和MAC地址，本质就是<code>&lt;IP地址，MAC地址&gt;</code>的对应表。表中一个条目记录了网络上一个主机的IP地址和其对应的MAC地址。 当地址解析协议被询问一个已知IP地址节点的MAC地址时，先在ARP缓存中查看，若存在，就直接返回与之对应的MAC地址，若不存在，才发送ARP请求向局域网查询。</p>
<h3 id="4-2-ARP高速缓存的使用"><a href="#4-2-ARP高速缓存的使用" class="headerlink" title="4.2 ARP高速缓存的使用"></a>4.2 ARP高速缓存的使用</h3><p>当主机发送一个ARP请求时，先查看ARP高速缓存表，如果存在对应条目，则直接返回MAC地址，否则向局域网发送ARP请求广播。</p>
<h3 id="4-3-ARP高速缓存的优缺点"><a href="#4-3-ARP高速缓存的优缺点" class="headerlink" title="4.3 ARP高速缓存的优缺点"></a>4.3 ARP高速缓存的优缺点</h3><ul>
<li>优点：从ARP高速缓存的使用中可以看到，ARP高速缓存可以减小广播量，进而减小网络通信量，提高计算机之间的通信效率。</li>
<li>缺点：造成安全隐患（参考下面免费ARP的作用）。</li>
</ul>
<h2 id="5-免费ARP"><a href="#5-免费ARP" class="headerlink" title="5 免费ARP"></a>5 免费ARP</h2><p>免费ARP指主机发送ARP查找自己的IP地址，通常发生在系统引导期间进行接口配置时。与标准ARP的区别就是免费ARP分组的目的IP地址字段封装的是自己的IP地址，即向所在网络请求自己的MAC地址。</p>
<h2 id="6-代理ARP"><a href="#6-代理ARP" class="headerlink" title="6 代理ARP"></a>6 代理ARP</h2><p>代理ARP就是通过使用一个主机(通常为router)，来作为指定的设备使用自己的 MAC 地址来对另一设备的ARP请求作出应答。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/07/internet-e5-8d-8f-e8-ae-ae/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/07/internet-e5-8d-8f-e8-ae-ae/" class="post-title-link" itemprop="url">Internet 协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-07 02:32:55" itemprop="dateCreated datePublished" datetime="2018-05-07T02:32:55+08:00">2018-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Internet-协议"><a href="#Internet-协议" class="headerlink" title="Internet 协议"></a>Internet 协议</h1><p><code>《TCP/IP详解 卷1：协议》``TCP``posts</code></p>
<ul>
<li><a href="#internet-协议">Internet 协议</a><ul>
<li><a href="#1-引言">1 引言</a></li>
<li><a href="#2-ip数据报">2 IP数据报</a><ul>
<li><a href="#221-生存期ttl">2.2.1 生存期TTL</a></li>
<li><a href="#222-ip-fragment">2.2.2 IP Fragment</a><ul>
<li><a href="#标识">标识</a></li>
<li><a href="#标志">标志</a></li>
<li><a href="#分片偏移">分片偏移</a></li>
<li><a href="#任何一片数据的丢失需要上层重传整个报文">任何一片数据的丢失需要上层重传整个报文</a></li>
<li><a href="#例子">例子</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>IP是TCP/IP协议族中的核心协议。所有TCP、 UDP、 ICMP和IGMP数据都通过IP数 据报传输。 IP提供了一种尽力而为、无连接的数据报交付服务。 “尽力而为”的含义是不保 证IP数据报能成功到达目的地。虽然IP不是简单丢弃所有不必要流量,但它也不对自已尝 试交付的数据报提供保证。当某些错误发生时,例如一台路由器临时用尽缓冲区, IP提供一 个简单的错误处理方法‥ 丢弃一些数据(通常是最后到达的数据报)。任何可靠性必须由上 层(例如TCP)提供。IPv4和IPv6都使用这种尽力而为的基本交付模式。 接下来我们了解一下IP数据报的组成和其有何作用。</p>
<h2 id="2-IP数据报"><a href="#2-IP数据报" class="headerlink" title="2 IP数据报"></a>2 IP数据报</h2><p>数据报分为<code>IPv4</code>和<code>IPv6</code>，先看看<code>IPv4</code><strong>头部中的字段组成</strong> <img src="http://tanwenbo.top/wp-content/uploads/2018/05/79bb31093672f208d93e7b9ab4332da2.png" alt=""></p>
<p>字段</p>
<p>长度</p>
<p>含义</p>
<p>版本</p>
<p>4比特</p>
<p>包含IP数据报的版本号，IPv4为<code>4</code>，IPv6为<code>6</code></p>
<p>IHL</p>
<p>4比特</p>
<p>Internet头部长度，也就是首部长度由于它是一个4位的字段，所以IPv4头部被限制为最多15个32位字，即64字节（为什么头部又说是20字节？）</p>
<p>DS字段（区分服务）</p>
<p>6比特</p>
<p>本来这里应该是服务类型（TOS）字段，但是它们从未被广泛使用，因此最终这个8位长的字段被划分为2个部分。</p>
<p>ECN</p>
<p>2比特</p>
<p>显式拥塞通知字段或指示位</p>
<p>总长度</p>
<p>16比特</p>
<p>通过这个和IHL字段，我们可以知道数据报的数据部分从哪开始，以及它的长度。最大长度<code>65535字节</code></p>
<p>标识</p>
<p>16比特</p>
<p>IPv4软件在存储器中维持一个计数器，每产生一个数据报，计数器就加<code>1</code>，并将此值赋给标识字段</p>
<p>标志</p>
<p>3比特</p>
<p>目前只有两位有意义。<code>最低位M</code>为<code>1</code>表示后面“<code>还有分配</code>”的数据报，为<code>0</code>表示这已经是最后一个数据偏；<code>中间位</code>为<code>1</code>表示“<code>不能分片</code>”，为<code>0</code>才允许分片</p>
<p>分片偏移</p>
<p>13比特</p>
<p>指出较长的分组在分片后，该片在原分组的相对位置</p>
<p>生存期TTL</p>
<p>8比特</p>
<p>Time To Live，表示数据报在网络中的寿命，功能是“跳数限制”，防止分组在网络中无限期地转发</p>
<p>协议</p>
<p>8比特</p>
<p>指出数据报有效荷载部分的数据类型，最常用的值为<code>17（UDP）</code>和<code>6（TCP）</code></p>
<p>头部校验和</p>
<p>16比特</p>
<p>IPv4独有，数据报每经过一个设备，设备都要重新计算以下头部检验和，若头部未发生变化，则此结果必为0，于是就保留这个数据报。<strong>这个字段只检验数据报的首部，但不包括数据部分</strong></p>
<p>源IP地址</p>
<p>32比特</p>
<p>报文发送方的IPv4地址</p>
<p>目的地址</p>
<p>32比特</p>
<p>报文接收方的IPv4地址</p>
<p>选项</p>
<p>0~40字节</p>
<p>用来支持排错、测量以及安全等措施。在必要的时候插入值为0的填充字节</p>
<p>数据部分</p>
<p>可变</p>
<p>用来填充报文</p>
<h3 id="2-2-1-生存期TTL"><a href="#2-2-1-生存期TTL" class="headerlink" title="2.2.1 生存期TTL"></a>2.2.1 生存期TTL</h3><p>生存时间字段用来标识IP数据报在网络中传输的有效期，以秒来计数，占8位。最初的设计是以秒为单位，没经过一个路由器时，就在TTL（Time To Live）中减去数据报在路由器消耗掉的一段时间。若数据报在路由器消耗的时间小于1s，就把TTL值减1。TTL的建议值是<code>32s</code>，最长是<img src="http://tanwenbo.top/wp-content/uploads/2018/05/984ff4d54b80e3fc4c382edc3a1fb3dd." alt="">−1=<code>255s</code>。现在通常认为这个TTL是指数据报允许经过的路由器数，主要有以下几个功能：</p>
<ul>
<li>防止数据报在网络上回环；</li>
<li>由时间值变为为路由的跳数，跳数限制；</li>
<li>当每经过一个路由，跳数限制减1，当为0时丢弃这个数据报，ICMP Time Exceeded Messages包发送给该数据包的源地址。</li>
</ul>
<h3 id="2-2-2-IP-Fragment"><a href="#2-2-2-IP-Fragment" class="headerlink" title="2.2.2 IP Fragment"></a>2.2.2 IP Fragment</h3><p>IP分片由<strong>标识</strong>、<strong>标志</strong>和<strong>分片位移</strong>组成。</p>
<blockquote>
<p>IP fragmentation is an Internet Protocol (IP) process that breaks datagrams into smaller pieces (fragments), so that packets may be formed that can pass through a link with a smaller maximum transmission unit (MTU) than the original datagram size. The fragments are reassembled by the receiving host. ——来自Wikipedia</p>
</blockquote>
<p>IP分片通过IP协议将数据分成更小的碎片，所以数据包可以由带有最大传输单元的链路形成。 在很多链路层网络（比如以太网）中，携带高层协议PDU的帧大小是有限制的。链路层的这种特征被称为_最大传输单元_（<code>MTU</code>），如果IP需要发送一个数据报，并且这个数据报比链路层MTU大，则IP通过<strong>分片</strong>将数据报分解成较小的部分，使每个分片都小于MTU。</p>
<h4 id="标识"><a href="#标识" class="headerlink" title="标识"></a>标识</h4><p>每个IP包的唯一值，相同的分片标识相同</p>
<h4 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h4><p>0</p>
<p>DF</p>
<p>MF</p>
<ul>
<li>DF：Don’t Fragment<ul>
<li>0，可以分片</li>
<li>1，不可分片，出错时发送ICMP</li>
</ul>
</li>
<li>MF：More Fragmen<ul>
<li>0，最后一个分片</li>
<li>1，还有更多的分片在后面</li>
</ul>
</li>
</ul>
<h4 id="分片偏移"><a href="#分片偏移" class="headerlink" title="分片偏移"></a>分片偏移</h4><p>标识本包在整个数据包中的位置，以8字节为单位。</p>
<h4 id="任何一片数据的丢失需要上层重传整个报文"><a href="#任何一片数据的丢失需要上层重传整个报文" class="headerlink" title="任何一片数据的丢失需要上层重传整个报文"></a>任何一片数据的丢失需要上层重传整个报文</h4><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>假设MTU为1300Bytes，现在有一个数据包为3280Bytes要传输。</p>
<p>MF</p>
<p>Offset</p>
<p>data</p>
<p>0</p>
<p>0</p>
<p>3280B</p>
<p>那么将会切割为3部分：</p>
<p>MF</p>
<p>Offset</p>
<p>data</p>
<p>1</p>
<p>0</p>
<p>1280B</p>
<p>1</p>
<p>160</p>
<p>1280B</p>
<p>0</p>
<p>320</p>
<p>720B</p>
<p>之所以是1280B，因为数据头占20B；MF不解释；Offset因为占8个字节，而<img src="http://tanwenbo.top/wp-content/uploads/2018/05/e6c4b48b54d9485cafde9bfbad242f39." alt="">)，那么下一分片的位移就是<img src="http://tanwenbo.top/wp-content/uploads/2018/05/30b369ac934c184e8cf9ae24d89d27b8." alt="">，依次累加。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/e3-80-8a-e7-bc-96-e7-a0-81checklist-e8-a7-84-e8-8c-83-e3-80-8b-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/02/e3-80-8a-e7-bc-96-e7-a0-81checklist-e8-a7-84-e8-8c-83-e3-80-8b-e5-ad-a6-e4-b9-a0-e7-ac-94-e8-ae-b0/" class="post-title-link" itemprop="url">《编码checklist规范》学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-02 06:45:35" itemprop="dateCreated datePublished" datetime="2018-05-02T06:45:35+08:00">2018-05-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="《编码checklist规范》学习笔记"><a href="#《编码checklist规范》学习笔记" class="headerlink" title="《编码checklist规范》学习笔记"></a>《编码checklist规范》学习笔记</h1><p><code>《编码checklist规范》``posts</code></p>
<ul>
<li><a href="#编码checklist规范学习笔记">《编码checklist规范》学习笔记</a><ul>
<li><a href="#0-前言">0 前言</a></li>
<li><a href="#1-排版">1 排版</a><ul>
<li><a href="#10-总则">1.0 总则</a></li>
<li><a href="#11-缩进">1.1 缩进</a></li>
<li><a href="#12-语句行">1.2 语句行</a></li>
<li><a href="#13-大括号">1.3 大括号</a><ul>
<li><a href="#范例">范例</a></li>
</ul>
</li>
<li><a href="#14-代码行长度">1.4 代码行长度</a></li>
</ul>
</li>
<li><a href="#2-注释">2 注释</a><ul>
<li><a href="#20-总则">2.0 总则</a></li>
<li><a href="#21-声明注释">2.1 声明注释</a></li>
<li><a href="#22-语句注释">2.2 语句注释</a><ul>
<li><a href="#范例-1">范例</a></li>
</ul>
</li>
<li><a href="#23-废弃代码">2.3 废弃代码</a></li>
</ul>
</li>
<li><a href="#3-标识符">3 标识符</a><ul>
<li><a href="#30-总则">3.0 总则</a></li>
<li><a href="#31-命名风格">3.1 命名风格</a></li>
<li><a href="#32-命名要求">3.2 命名要求</a></li>
<li><a href="#33-文件名">3.3 文件名</a></li>
<li><a href="#34-魔数">3.4 魔数</a><ul>
<li><a href="#示例">示例</a></li>
</ul>
</li>
<li><a href="#35-变量名称和用途匹配">3.5 变量名称和用途匹配</a></li>
<li><a href="#36-减小标识符的作用域和可见性">3.6 减小标识符的作用域和可见性：</a><ul>
<li><a href="#示例-1">示例</a></li>
</ul>
</li>
<li><a href="#37-函数声明">3.7 函数声明</a></li>
</ul>
</li>
<li><a href="#4-函数">4 函数</a><ul>
<li><a href="#40-总则">4.0 总则</a></li>
<li><a href="#41-函数规模">4.1 函数规模</a></li>
<li><a href="#42-函数参数">4.2 函数参数</a></li>
<li><a href="#43-返回值">4.3 返回值</a></li>
<li><a href="#44-const使用">4.4 const使用</a></li>
<li><a href="#45-重复代码提炼成函数">4.5 重复代码提炼成函数：</a></li>
<li><a href="#46-格式化字符串的变参函数定义">4.6 格式化字符串的变参函数定义</a></li>
</ul>
</li>
<li><a href="#5-宏定义">5 宏定义</a><ul>
<li><a href="#51-命名">5.1 命名</a></li>
<li><a href="#52-括号使用">5.2 括号使用</a></li>
<li><a href="#53-宏参数">5.3 宏参数</a></li>
<li><a href="#54-减少宏使用">5.4 减少宏使用</a></li>
<li><a href="#55-防止命名冲突">5.5 防止命名冲突</a></li>
</ul>
</li>
<li><a href="#6-结构体">6 结构体</a><ul>
<li><a href="#60-总则">6.0 总则</a></li>
<li><a href="#61-结构体对齐">6.1 结构体对齐</a></li>
<li><a href="#62-保证数据结构在跨平台时的二进制兼容性">6.2 保证数据结构在跨平台时的二进制兼容性：</a></li>
<li><a href="#63-变长结构体">6.3 变长结构体</a></li>
</ul>
</li>
<li><a href="#7语句">7语句</a><ul>
<li><a href="#70-总则">7.0 总则</a></li>
<li><a href="#71-括号使用">7.1 括号使用</a></li>
<li><a href="#72-goto使用限制">7.2 goto使用限制：</a></li>
<li><a href="#73-循环性能优化">7.3 循环性能优化：</a></li>
<li><a href="#74-不使用复杂表达式">7.4 不使用复杂表达式：</a></li>
<li><a href="#75-switchcase语句">7.5 switch/case语句：</a></li>
<li><a href="#76-控制结构ifforwhileswitch等的嵌套">7.6 控制结构(if/for/while/switch等)的嵌套：</a></li>
</ul>
</li>
<li><a href="#8-错误处理">8 错误处理</a><ul>
<li><a href="#80-总则">8.0 总则</a></li>
<li><a href="#81-参数合法性检测">8.1 参数合法性检测</a></li>
<li><a href="#82-数据合法性检查">8.2 数据合法性检查：</a></li>
<li><a href="#83-断言要求">8.3 断言要求：</a></li>
<li><a href="#84-return-返回值检查">8.4 “return - 返回值检查：</a></li>
</ul>
</li>
<li><a href="#9-资源管理">9 资源管理</a><ul>
<li><a href="#90-总则">9.0 总则</a></li>
<li><a href="#91-防止泄露">9.1 防止泄露：</a></li>
<li><a href="#92-使用配套的资源释放函数释放资源重点">9.2 使用配套的资源释放函数释放资源（重点）</a></li>
<li><a href="#93-避免重复释放">9.3 避免重复释放：</a></li>
<li><a href="#94-勿混用内存管理方法">9.4 勿混用内存管理方法：</a></li>
<li><a href="#95-标准输入输出错误的关闭">9.5 标准输入、输出、错误的关闭：</a></li>
</ul>
</li>
<li><a href="#10-内存">10 内存</a><ul>
<li><a href="#100-总则">10.0 总则</a></li>
<li><a href="#101-变量初始化">10.1 变量初始化</a></li>
<li><a href="#102-指针算术">10.2 指针算术：</a></li>
<li><a href="#103-结构体比较">10.3 结构体比较：</a></li>
<li><a href="#104-字符串比较">10.4 字符串比较：</a></li>
<li><a href="#105-防常量字符串修改">10.5 防常量字符串修改：</a></li>
<li><a href="#106-字符串格式化">10.6 字符串格式化：</a></li>
<li><a href="#107-防止字符串缺结束符">10.7 防止字符串缺结束符</a></li>
<li><a href="#108-字符串长度计算">10.8 字符串长度计算：</a></li>
<li><a href="#109-变量大小偏移计算">10.9 变量大小、偏移计算：</a></li>
<li><a href="#1010-c99的变长数组和alloca">10.10 C99的变长数组和alloca：</a></li>
<li><a href="#1011-字符串转整数浮点数">10.11 字符串转整数/浮点数：</a></li>
</ul>
</li>
<li><a href="#11-并发">11 并发</a><ul>
<li><a href="#110-总则">11.0 总则</a></li>
<li><a href="#111-信号处理">11.1 信号处理</a></li>
<li><a href="#112-信号处理函数">11.2 信号处理函数</a></li>
<li><a href="#113-不暴力终止线程">11.3 不暴力终止线程</a></li>
<li><a href="#114-wait-子进程子线程的后事处理">11.4 wait - 子进程/子线程的后事处理</a></li>
<li><a href="#115-互斥锁的使用">11.5 互斥锁的使用</a></li>
<li><a href="#116-锁定区域内睡眠">11.6 锁定区域内睡眠</a></li>
<li><a href="#117-非递归锁的使用">11.7 非递归锁的使用：</a></li>
<li><a href="#118-死锁">11.8 死锁</a></li>
<li><a href="#119-线程创建">11.9 线程创建</a></li>
<li><a href="#1110-需要同步的访问">11.10 需要同步的访问：</a></li>
</ul>
</li>
<li><a href="#12-危险的库特性">12 危险的库特性</a><ul>
<li><a href="#120-总则">12.0 总则：</a></li>
<li><a href="#121-错误号获取">12.1 错误号获取</a></li>
<li><a href="#122-不混用文件机制">12.2 不混用文件机制</a></li>
<li><a href="#123-不使用不安全函数">12.3 不使用不安全函数：</a></li>
</ul>
</li>
<li><a href="#13-危险的语言特性">13 危险的语言特性</a><ul>
<li><a href="#130-总则">13.0 总则</a></li>
<li><a href="#131-自增自减运算">13.1 自增/自减运算：</a></li>
<li><a href="#132-参数顺序依赖性">13.2 参数顺序依赖性：</a></li>
<li><a href="#133-char类型使用">13.3 char类型使用：</a></li>
<li><a href="#134-除0错误预防包括求余运算">13.4 除0错误预防(包括求余运算）：</a></li>
<li><a href="#135-指针转换">13.5 指针转换：</a></li>
<li><a href="#136-移位运算">13.6 移位运算：</a></li>
</ul>
</li>
<li><a href="#14-工具检查">14 工具检查</a><ul>
<li><a href="#140-总则">14.0 总则：</a></li>
<li><a href="#141-cppcheck">14.1 cppcheck：</a></li>
<li><a href="#142-ctest需编译">14.2 c++test(需编译)：</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><p>在学习完《C陷阱与缺陷》后，发现了很多以前没有注意到的错误，比如：字符串与字符的区别，指针函数与函数指针的区别等等。《C陷阱与缺陷》是本值得收藏、反复观看的书籍。 本书《Checklist编码规范》与《C陷阱与缺陷》相辅相成，好的编码规范在编程中能减少很多你难以预料到的BUG，显著提高代码质量。</p>
<blockquote>
<p><strong>文中加粗的部分是我自认为比较重要且以前没有注意的部分。</strong></p>
</blockquote>
<h2 id="1-排版"><a href="#1-排版" class="headerlink" title="1 排版"></a>1 排版</h2><h3 id="1-0-总则"><a href="#1-0-总则" class="headerlink" title="1.0 总则"></a>1.0 总则</h3><p>总则： 统一清晰的排版可以帮助代码阅读者迅速聚焦代码的关键逻辑，迅速定位区块的开始结束位置，大大提高代码阅读的效率。主要注意以下几点：</p>
<ol>
<li>排版风格在同一文件中，必须保持统一；</li>
<li>尽量把关系密切的逻辑集中在一起，保证视线无需漂移即可浏览到整个逻辑单元；</li>
<li>在尚未养成习惯之前，可采用astyle之类的工具软件格式化代码；</li>
</ol>
<h3 id="1-1-缩进"><a href="#1-1-缩进" class="headerlink" title="1.1 缩进"></a>1.1 缩进</h3><blockquote>
<p>代码的缩进可以说是编程的灵魂了，良好的代码缩进阅读起来十分方便，但是如果没有缩进，代码压根不能看！</p>
</blockquote>
<p>程序块要采用统一的缩进和对齐风格编写。整个项目中或者是<code>4</code>个空格，或者是一个<code>TAB</code>。不允许混用这两种。 如果是使用<code>TAB</code>，需保证<code>TAB</code>键的宽度是<code>4</code>个空格（）。 如果是在原有代码上修改（如Linux内核代码），需和原有代码的缩进、对齐方式保持一致。 建议在编辑器设置中将TAB键宽度设置为4（大多数编辑器都有这个设置），建议统一使用空格进行对齐。</p>
<ul>
<li><p>缩进要求：</p>
<ul>
<li>if else case for while语句需要缩进；</li>
<li>case语句与所属的switch语句对齐；</li>
<li>所有{}需要缩进，extern “”C”“, namespace 块除外，case语句除外。</li>
</ul>
</li>
<li><p>空格使用：</p>
<ul>
<li>关键字 if else switch case for while 之后要加空格；</li>
<li>如果<code>，；</code>后面没有立即换行, 即后面有变量或语句时, 要在后面加空格，<strong>类似for循环<code>for(int a = 1; a &lt; 100; a++)</code>每个条件后都加了空格；</strong></li>
<li><strong>小括号内侧不能有空格</strong>, 函数调用(或宏)的名字与括号之间<strong>不能有空格</strong>；</li>
<li><strong>一元</strong>操作符 <code>&amp; * + - ~ ! ++ --</code> 要紧贴对应的<strong>变量</strong>，<strong>不能有空格</strong>；</li>
<li><strong>二元</strong>操作符 <code>= + - * / % &amp; | ^ == != &gt;= &lt;= &gt; &lt; ? :</code> 两侧<strong>要加空格</strong>；</li>
<li>结构体成员操作符 <code>. -&gt;</code> <strong>前后不加空格</strong>。</li>
</ul>
</li>
</ul>
<p>规范示例：</p>
<pre><code>缩进的范例代码：
struct string_t {
    int len;
    char data[0];
};
//注意大括号的写法，但个人习惯这样写。其实大多数IDE都为你设置好了编码风格，但是如果用linux等就要自己注意了。
struct string_t 
{
    int len;
    char data[0];
};
//-----------------------
#ifdef __cplusplus
extern &quot;C&quot; {
#endif

struct string_t *create_string(int max_len);
struct string_t *copy_string(const char *str);
void release_string(struct string_t *str);

#ifdef __cplusplus
}
#endif

struct string_t *copy_string(const char *str)
{
    int len = strlen(str) + sizeof(struct string_t) + 1;

    struct string_t *pstr = (struct string_t *)malloc(len);
    if (!pstr)
        return NULL;

    pstr-&gt;len = len - sizeof(struct string_t) - 1;
    strcpy(pstr-&gt;data, str);
    return pstr;
}

switch (state) {
case STATE_CONNECT:
    ...
    break;
case STATE_LOGIN:
    ...
    break;
case STATE_NORMAL:
    ...
    break;
default:
    break;
}

for (i = 0; i &lt; cnt; ++i) {
    if (arr[i] &gt; value) {
        list_add(list, arr[i]);
    }
} </code></pre><h3 id="1-2-语句行"><a href="#1-2-语句行" class="headerlink" title="1.2 语句行"></a>1.2 语句行</h3><p>一行只写一条语句，不允许把多个短语句写在一行中。大多数以分号<code>；</code>算作一条语句。</p>
<h3 id="1-3-大括号"><a href="#1-3-大括号" class="headerlink" title="1.3 大括号"></a>1.3 大括号</h3><p>大括号是编码中的灵魂，没有大括号就没有作用域。具体规范如下：</p>
<ul>
<li><p><code>}</code> 必须独占一行，有两种例外：</p>
<ul>
<li>如果是在if(…){}else if(…){}else{}中，可与else放同一行；</li>
<li>如果是在do{}while(…)中，可与while放同一行；</li>
</ul>
</li>
<li><p><code>{</code></p>
<p>可以独占一行，且与上一语句的起始位置对齐。 也可以跟在相应的if、for、do、while、switch、class声明、函数声明后面；</p>
</li>
<li><p><code>{</code>,<code>}</code> 的相对位置在整个模块中必须保持一致。 if、for、do、while、switch这几种语句块的<code>{</code>必须保持相对位置一致。 其他语句块的<code>{</code>只要求在同类型之间保持相对位置一致即可。</p>
</li>
</ul>
<h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><p><strong>以下这段代码符合checklist要求：</strong></p>
<pre><code>int find_split(const char* str)
{
    assert(str);
    int len = strlen(str);
    for (int i = 0 ; i &lt; len ; ++i) {
        if (str[i] == &apos;,&apos; || str[i] == &apos;.&apos;) {
            return i;
        }
    }
    return -1;
}</code></pre><p><strong>以下这几段代码不符合checklist要求：</strong></p>
<ul>
<li><p>if语句和for语句的<code>{</code>相对位置不一致<strong>（要统一，不要两种风格并存）</strong></p>
<p>int find_split(const char* str)<br>{</p>
<pre><code>assert(str);
int len = strlen(str);
for (int i = 0 ; i &lt; len ; ++i) {
    if (str[i] == &apos;,&apos; || str[i] == &apos;.&apos;) 
    {
        return i;
    }
}
return -1;</code></pre><p>}</p>
</li>
</ul>
<ul>
<li><p><code>{</code>没有和上一语句的起始位置对齐</p>
<p>int find_split(const char* str)<br>{</p>
<pre><code>assert(str);
int len = strlen(str);
for (int i = 0 ; i &lt; len ; ++i) 
  {
    if (str[i] == &apos;,&apos; || str[i] == &apos;.&apos;) 
      {
        return i;
      }
  }
return -1;</code></pre><p>} </p>
</li>
</ul>
<h3 id="1-4-代码行长度"><a href="#1-4-代码行长度" class="headerlink" title="1.4 代码行长度"></a>1.4 代码行长度</h3><p>每行代码不应超过80列。 如果某些行需要超出80列（比如调用win32 API时，由于API参数过多，往往会超出80列），应该折成多行显示。 <strong>例外条款：</strong></p>
<ul>
<li>注释可以例外；</li>
<li>如果字符串单独占一行仍超出80列，可以例外；</li>
</ul>
<h2 id="2-注释"><a href="#2-注释" class="headerlink" title="2 注释"></a>2 注释</h2><p>注释对代码来说十分重要，可以使阅读代码的人能很好的理解代码。好的注释显得尤其重要，因为若干年后，代码作者可能自己都看不懂自己当年所写的代码是什么意思。</p>
<h3 id="2-0-总则"><a href="#2-0-总则" class="headerlink" title="2.0 总则"></a>2.0 总则</h3><p>注释的目的是提升代码可读性，帮助代码读者更快速的了解代码作者的实际意图。</p>
<ul>
<li><p>注释应重点阐述目的，而非过程；</p>
</li>
<li><p>注释应重点阐述隐性知识，<strong>即代码无法直接反映的意图、原则，如扩展方法，锁策略，内存分配限制等等</strong>；</p>
</li>
<li><p>注释应重点阐述模块/函数之间的关联知识。 即对比分析多个函数才能得到的知识，比如：</p>
<ul>
<li><strong>参数及返回值的含义、约束；</strong></li>
<li><strong>外部数据的含义、取值范围；</strong></li>
<li><strong>函数/模块之间的协作关系；</strong></li>
<li><strong>多个变量/函数之间的相互关系；</strong></li>
<li>……</li>
</ul>
</li>
<li><p><strong>注释应避免描述显而易见的知识，比如：“这是一个构造函数”，“定义一个整型变量”；</strong></p>
</li>
<li><p>注释内容需要和代码实际行为保持一致，不应涉及无关内容，如“今天天气很好”，“checklist规定这里要注释”；</p>
</li>
<li><p>注释需要及时更新，反映代码当前的状态，否则反而误导代码读者； 本条款为阐述、建议性条款；</p>
</li>
</ul>
<h3 id="2-1-声明注释"><a href="#2-1-声明注释" class="headerlink" title="2.1 声明注释"></a>2.1 声明注释</h3><blockquote>
<p>变量的声明很重要，是对变量含义的进一步解释，而不是只是知道其是什么类型。平时自己写注释最多写下函数的作用，一般很少写的那么详细。但是长久来说这是值得的。</p>
</blockquote>
<p>主要注意以下几点：</p>
<ul>
<li><strong>文件头</strong>：在头文件(<em>.h，</em>.hpp，*.inc等）和源文件头部应注释说明该其功能；</li>
<li><strong>函数头</strong>：函数头部应注释说明其功能及各参数、返回值的含义(无参构造函数、析构函数、重载的运算符函数可无需注释)；</li>
<li><strong>全局变量</strong>：全局变量应注释说明其功能；</li>
<li><strong>常量</strong>: 所有常量定义都应注释说明其功能；</li>
<li><strong>类型</strong>：所有类型定义(包括struct,class,enum,union)，都应注释说明其功能；</li>
<li><strong>宏定义</strong>：所有宏定义应注释说明其功能，如果宏有参数，必须说明参数的用法；</li>
</ul>
<p><strong>注释采用doxygen的注释标准。方便根据注释直接生成说明文档。范例请参考:</strong></p>
<ul>
<li><p><strong>文件头注释范例：</strong></p>
<p>/*<br>  功能：本文件定义文件列表的接口，文件列表是个存储文件路径名和文件信</p>
<pre><code>息的列表，本文件提供了文件列表的存储、读取、定位、访问等接口。</code></pre><p>  日期：2011-3-4<br>  作者：zbc<br>*/<br>#ifndef FILELIST_H_<br>#define FILELIST_H_<br>…<br>#endif //FILELIST_H_</p>
</li>
</ul>
<ul>
<li><p><strong>函数头注释范例：</strong></p>
<p>/**</p>
<ul>
<li>发送数据给服务器</li>
<li>@param [in]buf  数据缓冲区指针</li>
<li>@param len   数据长度</li>
<li>@return &lt;0表示失败，否则表示实际发送成功的字节数</li>
<li>@sample</li>
<li>int len = send_buf(buf, buflen);</li>
<li>if (len &lt; 0) {</li>
<li>DUMP(“send failed, errno: %x\n”, len);</li>
<li>return -1;</li>
<li>} else {</li>
<li>DUMP(“send ok, already send %d bytes.\n”, len);</li>
<li>}</li>
<li>/<br>int send_buf(const char* buf, int len);</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>类型定义注释：</strong></p>
<p>/**</p>
<ul>
<li>文件列表类</li>
<li>@remark</li>
<li>可用于记录系统所缓存的所有小文件，该列表可存在磁盘上</li>
<li>@note</li>
<li>/<br>class filelist {<br>…<br>};</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>全局变量注释：</strong></p>
<p>1）<br>char g_log_fname[MAX_PATH]; //日志文件的路径名称，从配置文件中读取得到<br>2）<br>//日志文件的路径名称，从配置文件中读取得到<br>char g_log_fname[MAX_PATH]; </p>
</li>
</ul>
<ul>
<li><p><strong>宏注释：</strong></p>
<p>/**</p>
<ul>
<li>释放内存，并把指针清零，防止重复释放</li>
<li>@param ptr 内存块指针，只允许传入malloc/remalloc/strdup等</li>
<li>C库函数分配的内存块指针</li>
<li>/<br>#define FREE_ZERO(ptr)         <br>do{                            <br>  if (!(ptr)) {              \<pre><code>free(ptr);             \
ptr = NULL;            \</code></pre>  }                          <br>}while(0)</li>
</ul>
<p>//  最大的缓冲区长度<br>#define MAX_BUF_SIZE 200 </p>
</li>
</ul>
<h3 id="2-2-语句注释"><a href="#2-2-语句注释" class="headerlink" title="2.2 语句注释"></a>2.2 语句注释</h3><blockquote>
<p>主要是对控制结构进行注释，因为具体的跳转如果只通过代码就有点难理解</p>
</blockquote>
<p>在下述控制结构处应按要求进行注释。语句块少于5行允许例外。</p>
<ul>
<li>if语句的各个分支，注释说明条件和具体功能；</li>
<li>for/while/do的头部，注释说明循环条件和具体功能；</li>
<li>switch头部，注释说明判断条件和具体功能；</li>
</ul>
<h4 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h4><ul>
<li><p><strong>if 语句注释：</strong></p>
<p>// 将buf中保存的消息发送给CGI进程<br>ret = send(sk, buf, datalen, 0);<br>if (ret &lt; 0) {                // 没有发送成功</p>
<pre><code>LOGDBG(&quot;send failed, errno: %d\n&quot;, errno);</code></pre><p>} else if (ret == 0) {        // 对端关闭</p>
<pre><code>LOGDBG(&quot;send failed, peer shutdown\n&quot;);</code></pre><p>} else {                      // 发送成功</p>
<pre><code>LOGDBG(&quot;send ok, length: %d\n&quot;, ret);</code></pre><p>}</p>
</li>
</ul>
<ul>
<li><p><strong>for 语句注释：</strong></p>
<p>// 遍历文件列表，直到找到名字为filename的文件对象，或列表遍历完毕<br>for (int i = 0 ; i &lt; cnt ; ++i) {</p>
<pre><code>if (strcmp(filename, filelists[i]-&gt;name) == 0)
    return i;</code></pre><p>}</p>
</li>
</ul>
<ul>
<li><p><strong>while/do…while 语句注释：</strong></p>
<p>// 将所有用户配置文件打包<br>pdir = opendir(“/var/sangfor”);<br>if (!pdir) {</p>
<pre><code>...
return -1;</code></pre><p>}<br>// 遍历/var/sangfor目录下所有配置文件(*.conf)，通过tar命令将其打到压缩包<br>while ((pcur = readdir(pdir)) != NULL) {</p>
<pre><code>...</code></pre><p>} </p>
</li>
</ul>
<h3 id="2-3-废弃代码"><a href="#2-3-废弃代码" class="headerlink" title="2.3 废弃代码"></a>2.3 废弃代码</h3><p>确定不适用的功能代码要删除，或者通过注释和<code>#if 0</code>关闭。</p>
<pre><code>#if 0   
    code
#endif</code></pre><p><code>#if</code>适用于较长的代码，且如果想让code生效，只需要把<code>#if 0</code>改为<code>#if 1</code>。但是千万不要把#if 0 来当作块注释使用， #if 1可以让其间的变量成为<code>局部变量</code>。</p>
<h2 id="3-标识符"><a href="#3-标识符" class="headerlink" title="3 标识符"></a>3 标识符</h2><p>变量命名相当重要，对代码的可读性至关重要。如果你写的代码所定义的变量都是<code>a、b、c</code>，那么谁知道其代表什么意思呢？一般的变量命名都是用英文单词，不熟悉英文的会用拼音或者拼音缩写代替。</p>
<h3 id="3-0-总则"><a href="#3-0-总则" class="headerlink" title="3.0 总则"></a>3.0 总则</h3><p>标识符声明的终极目的是达到“代码即文档”的效果。 所谓“代码即文档”，即由代码本身清晰的反映出作者的意图。 其中，最关键的就是利用标识符给一段代码/一段数据打个“标签”，说明这段代码是用来干嘛的，或者这段数据是用来干嘛的。</p>
<ul>
<li><p><strong>标识符的命名应反映目的，而非过程；</strong></p>
</li>
<li><p><strong>作用域越大，影响逻辑越多的标识符，其取名越完整。作用域越小、影响面越小的标识符，其取名越简练。</strong></p>
<ul>
<li><strong>如循环变量可使用无特殊含义的单字符i进行命名；</strong></li>
</ul>
</li>
<li><p>标识符的命名规则应当统一；</p>
</li>
<li><p>命名中不应包含对理解代码意图无帮助的部分，如：个人姓名，无意义字符等；</p>
</li>
</ul>
<h3 id="3-1-命名风格"><a href="#3-1-命名风格" class="headerlink" title="3.1 命名风格"></a>3.1 命名风格</h3><p>命名风格在同一模块中统一。有三种风格可供选择：</p>
<ul>
<li>UNIX的全小写加下划线的风格,如：<strong>create_file</strong>；</li>
<li>匈牙利命名法(大小写混排),如：<strong>CreateFile</strong>；</li>
<li>Java风格，如 <strong>createFile</strong>。</li>
</ul>
<p>就本人而言，一般会匈牙利命名法和java风格混用。</p>
<h3 id="3-2-命名要求"><a href="#3-2-命名要求" class="headerlink" title="3.2 命名要求"></a>3.2 命名要求</h3><p>标识符使用1个或多个英文单词或其缩写进行命名。要求：</p>
<ul>
<li>不使用拼音；</li>
<li>不使用无意义的字母组合；</li>
<li>除循环变量可使用i、j、k，指针变量可使用p之外，不使用单字符的名字；</li>
<li><strong>不使用下划线开头；</strong></li>
<li><strong>非静态全局变量使用<code>g_</code>开头；</strong></li>
<li><strong>静态全局变量使用<code>s_</code>开头；</strong></li>
<li><strong>类成员变量使用<code>m_</code>开头，等同于C结构体的（没成员函数的）可以例外，union可以例外；</strong></li>
<li>局部变量不加前缀；”</li>
</ul>
<p>全局变量的命名学习了，还有类成员的，怪不得经常看到m开头的命名。</p>
<h3 id="3-3-文件名"><a href="#3-3-文件名" class="headerlink" title="3.3 文件名"></a>3.3 文件名</h3><p>使用include包含的文件名全部使用小写。Windows界面相关的代码文件允许例外。</p>
<blockquote>
<p>也就是说头文件定义一般用小写，而不是大写。这个我之前一直用错了。</p>
</blockquote>
<h3 id="3-4-魔数"><a href="#3-4-魔数" class="headerlink" title="3.4 魔数"></a>3.4 魔数</h3><blockquote>
<p>用常量代替数字，比如定义数组长度，用max代表，而不是在需要定义数组长度的时候写数字。</p>
</blockquote>
<p>不允许使用0,1,-1之外的魔数，有需要用到数字的地方，请用命名常量代替。 如果作为标识（比如状态标识）时，0,1,-1也不允许直接使用。 所谓<strong>魔数</strong>，指以字面值形式出现的数值常量（不包括字符串常量），比如3，-4，256，3.14，0.628。 <strong>作为特例，以下情形是允许的：</strong></p>
<ul>
<li>初始化一个变量时允许使用魔数，如<code>int num = 20；timeval tv = {10, 10};</code></li>
<li>定义替代魔数的命名常量时允许使用魔数,如<code>#define PI 3.14；</code></li>
<li>该魔数代表参数个数,且该参数个数无法通过sizeof等方法测量得到；（请参考注释）</li>
<li><code>0、-1</code>如果作为返回值，分别代表正常、出错，是允许的。<code>1、0</code>作为布尔值表示真、假，也是允许的。</li>
<li>作为<strong>位运算</strong>或其他算法的固有参数时，允许使用魔数，但需注释说明；</li>
<li>该魔数只跟当前语句有关(<strong>即无需与模块其它代码保持一致</strong>），且替换为标识符常量后对代码可读性没有明显提升，则允许直接使用魔数；</li>
</ul>
<p>定义标识符常量替代魔数的原则是该标识符必须包含更丰富的信息，以提升代码可读性。 典型的可以指明上下文，指明常量的含义（如：USRCFG_USERNAME_MAXSIZE，指在用户配置中用到的用户名的最大长度） <strong>以下命名方式是常见的误区：</strong></p>
<ul>
<li>直接在标识符常量中出现魔数本身，如：<code>#define BUFSIZE_128 128</code></li>
<li>使用含糊的语义，如：<code>#define LEN 128</code></li>
<li>把字符串常量也当成魔数，如：<code>#define MKDIR_ERROR_STR &quot;&quot;mkdir error, errno(%d):%s\n&quot;&quot;&quot;</code></li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>所谓魔数: 指以字面值形式出现的数值常量。</p>
<ul>
<li><p><strong>不可以这样：</strong></p>
<p>return 2;<br>ouble area = 3.14<em>radius</em>radius;<br>mkdir(usrcfg_fname, 0660);  //创建文件，并指定权限，有时候别人不知道0660是什么意思，具体可看linux文件权限码</p>
</li>
</ul>
<ul>
<li><p><strong>可以这样：</strong></p>
<p>1) 在头文件中有常量的统一定义：</p>
<pre><code>const int EOUTMEM = 2;  或#define EOUTMEM 2</code></pre><p>   使用时引用已经定义好的常量：</p>
<pre><code>return EOUTMEM;</code></pre><p>2) #define PI 3.14</p>
<pre><code>double area = PI*radius*radius;</code></pre><p>3) #define USRCFG_UGO_RW_RW_NONE 0660</p>
<pre><code>mkdir(usrcfg_name, USRCFG_UGO_RW_RW_NONE);</code></pre></li>
</ul>
<ul>
<li><p>作为特例，允许使用魔数的情形：</p>
<ul>
<li>魔数代表参数个数：</li>
</ul>
<p>int ret = sscanf(sz, “%u.%u.%u.%u”, &amp;ip1, &amp;ip2, &amp;ip3, &amp;ip4);<br>if (ret != 4) {</p>
<pre><code>printf(&quot;read ip failed\n&quot;);</code></pre><p>}<br>//该代码中，4代表读取到的参数个数。</p>
<p>int sum(int num, int para1, …);<br>int val = sum(3, num1, num2, num3);</p>
<p>//该代码中，3代表传给sum的待累加的参数的个数。</p>
</li>
</ul>
<ul>
<li><p>魔数代表位运算的固有参数：</p>
<p>ret = (val &gt;&gt; 4) &amp; 0xff; //取val的4到8位<br>size = (size + 3) / 4 * 4; //4字节对齐 </p>
</li>
</ul>
<h3 id="3-5-变量名称和用途匹配"><a href="#3-5-变量名称和用途匹配" class="headerlink" title="3.5 变量名称和用途匹配"></a>3.5 变量名称和用途匹配</h3><p>主要是不要取无意义或无厘头的变量名</p>
<ul>
<li>变量的名字和实际用途相符，不使用和实际用途完全无关或相反的命名；</li>
<li>在变量的作用域内，一个变量不用作多个用途；（请参考注释）</li>
<li>如果变量有多个取值范围，且各取值范围代表不同意思，须保证各个取值范围之间不得有重叠；（请参考注释）</li>
</ul>
<p>1) 完全无关的命名： 比如：<code>count</code>用于表示颜色； 2) 名字和用途相反： 比如：<code>free_cnt</code>用于表示当前存活的对象数目；<strong>应该是当前释放的对象数目</strong> 3) 一个变量多个用途： 一个实际引起了BUG的例子：value既作为入参表示哈希值，又作为出参，表示是否成功。</p>
<pre><code>#define HASH_INSERT(hash_table, node, value, type)  \
    do {                                            \
        node-&gt;pre = NULL;                           \
        node-&gt;pnext = NULL;                         \
        unsigned int h_i_i = value % HASH_SIZE;     \
        if (hash_table[h_i_i] != NULL &amp;&amp;            \
            hash_table[h_i_i]-&gt;key != node-&gt;key) {  \
            ...                                     \
        }else if (hash_table[h_i_i] == NULL) {      \
            hash_table[h_i_i] = node;               \
        } else {                                    \
            value = 0;                              \
        }                                           \
    } while (0);</code></pre><p>4) 同一个用途，多次使用是允许的，如：</p>
<pre><code>int ret = 0;
ret = init_pools();
ret = init_threads();
ret = init_plugins();   
//都表示初始化是否成功</code></pre><p>5) 不同取值范围代表不同意思，比如:</p>
<pre><code>int find_string(const vector&lt;string&gt;&amp; lst, const char* name);</code></pre><p>find_string的功能是从字符串列表中查找是否存在字符串name，当返回值<code>大于0</code>时，表示name在字符串列表lst中的索引，<code>==0</code>表示未找到，<code>&lt;0</code>时查找过程出错，并指示出错类型。 如果0也是列表的合法索引值，则find_string违反了本条款的第3项，即：取值范围有重叠，0既可能是索引值，也可能代表没找到。</p>
<h3 id="3-6-减小标识符的作用域和可见性："><a href="#3-6-减小标识符的作用域和可见性：" class="headerlink" title="3.6 减小标识符的作用域和可见性："></a>3.6 减小标识符的作用域和可见性：</h3><p>1) <strong>不允许在头文件中定义非静态全局变量，仅仅声明除外，例子见批注；</strong> 2) <strong>不被别的编译单元访问的全局变量，必须声明为静态全局变量</strong>（即必须在定义和声明前加static修饰） 3) <strong>不被别的编译单元访问的函数</strong>，必须加上<code>static</code>声明； 4) <strong>不被别的类访问的成员函数</strong>，必须声明为<code>private</code>函数； 5) <strong>只被派生类访问的成员函数</strong>，必须声明为<code>protected</code>函数； 如确有必要违反以上2、3、4、5项条款，注释说明清楚原因后可以例外。</p>
<blockquote>
<p>有时候严格一点效果可能更好，这一段是必须记住的。</p>
</blockquote>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><ul>
<li><p>全局变量定义:</p>
<p>int g_debug;<br>int g_debug = 1;</p>
</li>
</ul>
<ul>
<li><p>全局变量声明：</p>
<p>extern int g_debug;</p>
</li>
</ul>
<ul>
<li><p>静态全局变量：</p>
<p>static int s_debug; </p>
</li>
</ul>
<h3 id="3-7-函数声明"><a href="#3-7-函数声明" class="headerlink" title="3.7 函数声明"></a>3.7 函数声明</h3><blockquote>
<p>在头文件里写声明，在c/cpp里写定义</p>
</blockquote>
<p>1) 函数声明必须和函数定义的保持原型一致； 2) 引用其它模块或<code>.c/.cpp</code>文件提供的有外部链接特性的函数(extern函数)， 应使用include头文件的方式引用其函数声明，不允许自行声明，<strong>不允许在.c/.cpp中直接声明</strong>； 3) 提供给.c文件使用的函数声明，必须放在extern “”C”” {}域内，并通过<strong>宏防止问题</strong>（见注释）；”</p>
<ul>
<li><p>提供给c模块使用的函数原型声明：</p>
<p>#ifdef __cplusplus<br>extern “C” {<br>#endif</p>
<p>void foo(int xxx, int yyy);</p>
<p>#ifdef __cplusplus<br>}<br>#endif </p>
</li>
</ul>
<h2 id="4-函数"><a href="#4-函数" class="headerlink" title="4 函数"></a>4 函数</h2><p>函数定义的好坏直接决定代码的质量，良好的软件设计应遵循<strong>“高内聚，低耦合”</strong>，函数的设计也应遵循此原则。</p>
<h3 id="4-0-总则"><a href="#4-0-总则" class="headerlink" title="4.0 总则"></a>4.0 总则</h3><p>函数是控制代码复杂度的最有效工具。 函数可以隔绝两段代码之间的相互影响，约束两段代码之间只能通过参数/返回值/全局变量来传递影响。 函数通过函数名给一段代码“打标签”，能帮助读者快速了解代码片段的意图，提升代码可读性；</p>
<ul>
<li><strong>使用工具评估代码复杂度</strong>，常用的有SourceMonitor、CCCC等，常用的用于评价函数复杂度的指标有代码行数、圈复杂度等；</li>
<li><strong>降低函数参数个数</strong>，有助于提高函数的易用性，且降低函数实现的复杂度；</li>
<li><strong>减少函数内部相互作用的变量个数</strong>，有助于降低函数的复杂度；</li>
<li><strong>尽可能保证函数功能单一性</strong>，不做完全无关的两件事情，不做和函数名没有关系的事情；</li>
<li><strong>使用统一的错误处理模型</strong>，有助于提高代码易读性，精简代码的同时避免错误；</li>
<li><strong>时刻关注代码的冗余度</strong>，相似代码越多，意味着逻辑抽象程度越差，应想办法将相似逻辑提炼成函数；</li>
</ul>
<h3 id="4-1-函数规模"><a href="#4-1-函数规模" class="headerlink" title="4.1 函数规模"></a>4.1 函数规模</h3><p>一个函数不超过100行，工具自动生成的除外。对既有的第三方代码（比如内核代码）进行修改可例外（新增函数依然不得超过100行）。</p>
<blockquote>
<p>想起了以前自己写的函数，基本上功能丰富一点的都要超过好几百行了吧，应该把一些功能切割开来，实现低耦合！</p>
</blockquote>
<h3 id="4-2-函数参数"><a href="#4-2-函数参数" class="headerlink" title="4.2 函数参数"></a>4.2 函数参数</h3><ul>
<li>函数调用传递大对象（超过8个字节大小，或者其构造函数会分配资源）时不使用按值传递。<strong>返回值允许例外</strong>。（<strong>也就是引用传递，直接引用原来的对象；返回值例外就是在函数里再定义一个对象，然后将其返回</strong>）</li>
<li><strong>不允许在函数参数中使用布尔类型</strong>(包括使用数值类型仿制的布尔类型）。<strong>如有需要用到这类标志性参数，可用枚举代替，或者分拆成多个函数实现</strong>，具体见示例。</li>
<li><strong>函数参数中不得定义数组参数</strong>，应使用指针代替数组。请注意：如果参数是数组的指针不违反本条款。（也就是C缺陷里的数组即指针），如果数组定义没有指定数组长度，也可例外，如：<code>int main(int argc, char *argv[])</code></li>
<li>函数参数个数<code>不超过5</code>个(&lt;=5)。</li>
</ul>
<p><strong>建议：</strong> 建议拆分函数功能，分成多个函数实现，这样每个函数功能更简单，参数更少。 如果内部没有复杂逻辑，可以通过结构体指针传参。 <strong>以下函数声明违反checklist:</strong></p>
<pre><code>1) void func(string name)；
//应该直接用引用，不要按值传递
2) struct record {
    int type;
    int len;
    char data[16];
};
void send_record(record rec);
//这个好像没什么问题啊</code></pre><p>注2： 函数参数中使用布尔类型，会使代码更难以理解，如：</p>
<pre><code>UpdateData(TRUE)
CreateProcess(chPath, &quot;&quot;, NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, &amp;pi)</code></pre><p>如果不是对这些函数非常熟悉，你知道这些TRUE，FALSE代表什么意思吗？</p>
<pre><code>如果改为UpdateData(SAVE_VALIDATE)，CreateProcess(chPath, &quot;&quot;, NULL, NULL, NO_INHERIT_HANDLE, 0, NULL, NULL, &amp;si, &amp;pi)会不会好一点？

改造方法：

UpdateData是MFC函数，原型如下：
BOOL UpdateData(BOOL bSaveAndValidate);

下述修改方法都可以提高UpdateData的可读性：

1）分拆成两个函数实现
BOOL UpdateData();
BOOL UpdateData_SaveAndValidate();

2）将bSaveAndValidate参数改造成枚举
enum SaveAndValidate_e{
    SAVE_VALIDATE,
    NO_SAVE_VALIDATE
};
BOOL UpdateData(enum SaveAndValidate_e eSave);
这样，在调用这个函数时就有一个名字了,可以通过枚举的名字更好的理解这个函数调用的意思，如：UpdateData(SAVE_VALIDATE);</code></pre><p><strong>多使用枚举代替ture和false！</strong></p>
<pre><code>void test_arr_copy(int arr[ARRAY_SIZE])
{
    int buf[ARRAY_SIZE];
    memcpy(buf, arr, sizeof(arr));
}</code></pre><p>以上代码违反子条款3，sizeof(arr)的结果为sizeof(int)，而非sizeof(int)*ARRAY_SIZE 可改为：</p>
<pre><code>void test_arr_copy(int *arr)
{
...
}</code></pre><p>以下函数定义不违反本条款（因为p是指向数组的指针，而非数组）：</p>
<pre><code>void test_arr_copy(int (*p)[ARRAY_SIZE]); </code></pre><h3 id="4-3-返回值"><a href="#4-3-返回值" class="headerlink" title="4.3 返回值"></a>4.3 返回值</h3><blockquote>
<p>一般自己使用返回值都是返回函数里定义的局部变量，原来这是不行的。</p>
</blockquote>
<ul>
<li><strong>不返回本函数内定义的非静态局部变量的地址</strong>（包括以指针或引用形式返回）。也不允许通过出参或全局变量、类成员变量的方式返回；</li>
<li>在linux平台，如果返回值是int/short/long,且用于标识出错，<strong>则统一使用&lt;0表示出错，&gt;=0表示成功。</strong>回调函数等有约束的函数可以例外(比如main的返回值)；</li>
<li>返回值为BOOL类型的函数，只允许返回TRUE和FALSE两种取值；</li>
<li><strong>在函数返回值中使用的函数指针，必须使用typedef定义的别名。</strong>（不容易出现歧义） <strong>比如：</strong></li>
</ul>
<pre><code>typedef int (*PfnScanner)();
PfnScanner get_scanner(const char *name);
//指向返回值为int类型的函数的指针 </code></pre><h3 id="4-4-const使用"><a href="#4-4-const使用" class="headerlink" title="4.4 const使用"></a>4.4 const使用</h3><blockquote>
<p>在使用const的时候要对其十分了解，不然会出现错误。</p>
</blockquote>
<ul>
<li><p>函数参数：</p>
<ul>
<li>对于指针或引用参数，如果函数内部<strong>不改变该参数的值</strong>且<strong>不调用需要该参数为左值（通俗点说就是可以放在赋值运算符左边的变量）的函数</strong>，则<strong>必须在该参数定义前加const修饰</strong>。</li>
<li>钩子函数（回调函数）如果需要和指定的函数原型保持一致可以例外（比如：定时器函数，消息处理函数，qsort的回调函数等）。</li>
</ul>
</li>
</ul>
<blockquote>
<p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>
</blockquote>
<ul>
<li><p>如果该函数需要返回一个依赖某参数的指针，而这个指针可能被其它函数用来改写数据，则认为这个被依赖的参数是个非const参数，不需要const修饰。例子见注释。</p>
</li>
<li><p>非静态成员函数： 对于非静态成员函数，如果<strong>函数内部不修改普通成员变量</strong>（<strong>没有</strong>用<code>static</code>及<code>mutable</code>修饰的成员变量），则必须声明该函数为const成员函数（在参数列表后加const）。 下列情形可以例外：</p>
<ul>
<li>构造、析构、重载操作符函数；</li>
<li>作为钩子或回调函数使用；</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code>void print(const char *buf, size_t len);

//成员函数，如：
int ini::find(const char* name) const;

//返回一个依赖参数的可写指针：
msg_hdr *get_hdr(char *buf)
{
    return (msg_hdr *)buf;
}
void get_hdr(char *buf, msg_hdr **hdr)
{
    *hdr = (msg_hdr *)buf;
} </code></pre><h3 id="4-5-重复代码提炼成函数："><a href="#4-5-重复代码提炼成函数：" class="headerlink" title="4.5 重复代码提炼成函数："></a>4.5 重复代码提炼成函数：</h3><p>超过5行（不算空白行、注释行、只有大括号的行）的重复代码应提炼成<strong>函数</strong>（特殊情况也可提炼为宏）。 如有效率要求，可将函数内联。重复代码，指满足以下所有条件的代码块：</p>
<ul>
<li>出现次数超过2次；</li>
<li>去除分隔符（比如空白符、大括号、注释等）以后，只有变量名字或常量内容不同；”</li>
</ul>
<h3 id="4-6-格式化字符串的变参函数定义"><a href="#4-6-格式化字符串的变参函数定义" class="headerlink" title="4.6 格式化字符串的变参函数定义"></a>4.6 格式化字符串的变参函数定义</h3><p>如果需要定义类似于printf的拥有可变参数列表、能格式化输出字符串的函数，需要在函数声明中加上<strong>检查参数有效性的属性声明</strong>，如下：</p>
<pre><code>void my_print(int fd, const char *fmt, ...) __attribute__((format(printf, 2, 3))); </code></pre><h2 id="5-宏定义"><a href="#5-宏定义" class="headerlink" title="5 宏定义"></a>5 宏定义</h2><h3 id="5-1-命名"><a href="#5-1-命名" class="headerlink" title="5.1 命名"></a>5.1 命名</h3><p>除非有特殊理由，否则宏使用全大写加下划线的方式命名。（有特殊理由的须注释说明原因）</p>
<h3 id="5-2-括号使用"><a href="#5-2-括号使用" class="headerlink" title="5.2 括号使用"></a>5.2 括号使用</h3><blockquote>
<p>因为宏是直接替换代码，所以一定要用括号规避运算符优先级的问题</p>
</blockquote>
<ul>
<li>用宏定义表达式时，要使用完备的括号。保证该宏的所有可能的使用方法(即包含潜在的某些使用方法）都不会发生运算符优先级问题；</li>
<li>如果宏定义中包含多条语句或者包含有if语句，须将这些语句放在大括号中，建议使用do{…}while(0)的形式；</li>
</ul>
<h3 id="5-3-宏参数"><a href="#5-3-宏参数" class="headerlink" title="5.3 宏参数"></a>5.3 宏参数</h3><p>使用宏时，不允许参数中出现会发生副作用（即会改变某些变量的值或程序的运行环境）的表达式。 比如不允许使用<code>MAX(++a, b+=2)</code>。在《C缺陷》里也有讨论到这个问题。</p>
<h3 id="5-4-减少宏使用"><a href="#5-4-减少宏使用" class="headerlink" title="5.4 减少宏使用"></a>5.4 减少宏使用</h3><p>如果能通过下述方式替代宏，且程序功能不会发生变化，则不允许使用宏：</p>
<ul>
<li>C++的常量定义或枚举；（注：C++常量和枚举都可用作编译期常量，用于数组长度定义等需要编译期常量的场合）</li>
<li>函数或内联函数；（注：需要性能保证的多条语句可以封装成内联函数）”</li>
</ul>
<h3 id="5-5-防止命名冲突"><a href="#5-5-防止命名冲突" class="headerlink" title="5.5 防止命名冲突"></a>5.5 防止命名冲突</h3><p>宏内部如果需要定义局部变量,必须防止该变量和上下文中的变量名字冲突，建议加上特殊前缀或后缀。 Gcc编译器开启-Wshadow后对该问题会产生警告，需消除。” 例如：</p>
<pre><code>//遍历列表

#define foreach_list(list, func)                    \
    do {                                            \
        int i;                                      \
        int cnt = list_size(list);                  \
        for (i = 0 ; i &lt; cnt ; ++i) {               \
            func(list, i);                          \
        }                                           \
    } while (0)

//假如调用者用法如下，就可能发生错误：
for (i = 0 ; i &lt; cnt ; ++i) {
    foreach_list(&amp;lists[i], do_print_list);
}

//经过宏替换后，代码如下：
for (i = 0 ; i &lt; cnt ; ++i) {
    do {
        int i;
        int cnt = list_size(&amp;lists[i]);
        for (i = 0 ; i &lt; cnt ; ++i) {
            do_print_list(&amp;lists[i], i);
        }
    } while (0);
}
/*由于内层作用域定义的名字自动屏蔽外层定义的名字，编译器不会报错。
这样一来，原本foreach_list(&amp;lists[i],do_print_list)是想访问外层的i，但经宏替换后实际访问到的i却是内层定义的，张冠李戴，岂不糟糕？*/</code></pre><p>解决办法是－－给宏内部定义的局部变量加特殊前缀或后缀， 如：将<code>int i;int cnt;</code>改为<code>int i_;int cnt_;</code></p>
<h2 id="6-结构体"><a href="#6-结构体" class="headerlink" title="6 结构体"></a>6 结构体</h2><h3 id="6-0-总则"><a href="#6-0-总则" class="headerlink" title="6.0 总则"></a>6.0 总则</h3><p>结构体(struct)和联合体(union)提供一种按名字访问数据块中数据内容的能力。使用结构体/联合体，可以让代码更具可维护性，且有助于让代码跨平台。为了更大的发挥各平台的性能，编译器在排布结构体/联合体中的数据成员时，可能在各变量间插入一些“垫片”数据，使得每个变量都做到对齐访问。这些“隐形”的“垫片”，可能导致访问未初始化数据问题（如memcmp比较两个结构体）。</p>
<h3 id="6-1-结构体对齐"><a href="#6-1-结构体对齐" class="headerlink" title="6.1 结构体对齐"></a>6.1 结构体对齐</h3><blockquote>
<p>结构体对齐的问题在面试中经常会被问道，需要十分注意</p>
</blockquote>
<ul>
<li><p>保证结构体(C++类也一样）至少是4字节对齐的。 长度大等于2的成员的偏移位置必须能被2整除，长度大等于4的成员的偏移位置必须能被4整除。另：如果不强行指定对齐方式，编译器默认会将所有结构体对齐，即可满足本条款；</p>
</li>
<li><p>需要跨进程传递的结构体，必须保证<code>pack(1)</code>和<code>pack(4)</code>编译后是一样的内存结构（即各成员的偏移是一样的）。</p>
<ul>
<li>如果结构体中含有64位(如double,long long)的数据成员，必须保证<strong>pack(1)</strong>和<strong>pack(8)</strong>编译后是一样的内存结构；</li>
<li>有一个技巧可以较容易达到这个要求，<strong>即结构内成员按成员的对齐系数(alignment modulus)从大到小的顺序排列。</strong></li>
<li><strong>结构体类型的成员的对齐系数是该结构体各成员对齐系数的最大值。</strong></li>
</ul>
</li>
</ul>
<p>具体对齐原则可见其他笔记。</p>
<h3 id="6-2-保证数据结构在跨平台时的二进制兼容性："><a href="#6-2-保证数据结构在跨平台时的二进制兼容性：" class="headerlink" title="6.2 保证数据结构在跨平台时的二进制兼容性："></a>6.2 保证数据结构在跨平台时的二进制兼容性：</h3><p>需要在异构平台上传递的结构，不直接使用随平台不一样而导致长度不一的数据类型,如：int,long,unsigned long；</p>
<blockquote>
<p>long在32位是占2个字节，而在64位占4个</p>
</blockquote>
<p>可使用在不同平台保持长度一致的各种类型别名，如：<code>int32_t,U32,WORD</code></p>
<h3 id="6-3-变长结构体"><a href="#6-3-变长结构体" class="headerlink" title="6.3 变长结构体"></a>6.3 变长结构体</h3><p>变长结构体，指那种含有元素个数可变的数组成员的结构体。</p>
<ul>
<li>长度可变的数组成员必须是结构体的最后一个成员；</li>
<li>如果该数组成员的元素个数定义为0，则结构体大小并不包含该数组成员的大小；</li>
<li>该结构体必须使用动态分配，并预留足够的内存空间（该结构体大小加上数组成员的大小）；</li>
<li>该结构体必须是POD（plain old data）类型，具体原因请参考注释；</li>
</ul>
<blockquote>
<p>POD就是C语言自带的变量，而不是string之类的类，是int，short等</p>
</blockquote>
<p>如果结构体不充当变长结构体使用（比如只访问结构体前面固定长度字段），则可以例外。</p>
<ul>
<li><p>变长结构体的大小：</p>
<p>struct port_group{<br>   unsigned int cnt;<br>   unsigned short ports[0];<br>};</p>
</li>
</ul>
<p>上述结构体中，ports成员的大小为0，所以整个结构体的大小<code>sizeof(struct port_group) == sizeof(unsigned int)</code>。</p>
<ul>
<li><p>变长结构体必须动态计算长度和分配内存，直接定义变量是有问题的。如下代码会造成运行时错误：</p>
<p>void fun()<br>{</p>
<pre><code>struct port_group pg;
pg.cnt = 1;
pg.ports[0] = 1;</code></pre><p>}</p>
</li>
</ul>
<ul>
<li><p>变长结构体分配：</p>
<p>struct port_group *create_port_group(size_t port_cnt)<br>{</p>
<pre><code>size_t size = sizeof(struct port_group) + sizeof(unsigned short) * port_cnt;
struct port_group *p = (struct port_group *)calloc(1, size);
if (!p){
    return p;
}
p-&gt;cnt = port_cnt;
return p;</code></pre><p>}</p>
</li>
</ul>
<ul>
<li><p>变长结构体必须是POD（plain old data）类型，以下结构体定义是有问题的:</p>
<p>struct port_group{</p>
<pre><code>std::string name;
unsigned int cnt;
unsigned short ports[0];</code></pre><p>};</p>
</li>
</ul>
<p>因为port_group必须使用类似<code>malloc</code>的方法分配内存，name得不到初始化，需要使用placement new 的方法才能正常初始化，很麻烦。</p>
<h2 id="7语句"><a href="#7语句" class="headerlink" title="7语句"></a>7语句</h2><h3 id="7-0-总则"><a href="#7-0-总则" class="headerlink" title="7.0 总则"></a>7.0 总则</h3><p>对C&amp;C++语句使用的一些约束，主要目的是降低语句复杂度，帮助代码阅读者更容易理解代码的意思。</p>
<h3 id="7-1-括号使用"><a href="#7-1-括号使用" class="headerlink" title="7.1 括号使用"></a>7.1 括号使用</h3><p>括号的使用永远是编码风格必须讨论的东西。 <strong>以下情况必须使用括号明确表达式优先级：</strong></p>
<ol>
<li>同时出现 &amp;、^、| 这三种运算符中的任意两种（或&amp;、^同时出现两次）；</li>
<li>同时出现位运算符（&amp; ^ |）和比较运算符(&lt; &lt;= &gt; &gt;= == !=)</li>
<li>同时出现&amp;&amp;和||；</li>
<li>同时出现移位运算符(&lt;&lt; &gt;&gt;)和比较运算符(&lt; &lt;= &gt; &gt;= == !=)</li>
<li>同时出现比较运算符中(&lt; &lt;= &gt; &gt;= == !=)的任意两种（或一种出现两次）；</li>
<li>同时出现位运算符(&amp; ^ |)和逻辑运算符(&amp;&amp; ||)；</li>
<li>同时出现移位运算符(&lt;&lt; &gt;&gt;)和算术运算符(+ - * / %)</li>
</ol>
<p><strong>如果一个上述运算符没有同时出现在一个操作数（或高优先级表达式）的两边，可以不做要求。</strong> <strong>不符合要求：</strong></p>
<ul>
<li>if (op_bits &amp; OP_READ &amp;&amp; op_bits &amp; OP_WRITE) &amp;和&amp;&amp;同时出现在OP_READ的两边</li>
<li>if (1 &gt; mid != max) &gt;和!=同时出现在mid的两边</li>
<li>ret = op_bits | OP_READ &amp; OP_MASK; |和&amp;同时出现在操作数OP_READ的两边；</li>
<li>ret = op_bits | (g_def_opbits &amp; 0xffff) &amp; OP_MASK; |和&amp;同时出现在高优先级表达式(g_def_opbits&amp;oxffff)的两边；</li>
<li>if (pb == 0 || len == 0 &amp;&amp; pe == 0) ||和&amp;&amp;同时出现在高优先级表达式len == 0的两边；</li>
</ul>
<p><strong>符合要求：</strong></p>
<ul>
<li>if ((op_bits &amp; OP_READ) &amp;&amp; (op_bits &amp; OP_WRITE)) 以上表达式已使用括号明确了优先级</li>
<li>if (mid &gt;= min &amp;&amp; mid &lt; max) 以上表达式中&gt;= 和 &lt;没有同时出现在某个高优先级表达式的两边，中间的&amp;&amp;运算符优先级比较低。</li>
<li>if (p &amp;&amp; p &lt; pEnd &amp;&amp; p &gt; pBegin + 1)</li>
</ul>
<h3 id="7-2-goto使用限制："><a href="#7-2-goto使用限制：" class="headerlink" title="7.2 goto使用限制："></a>7.2 goto使用限制：</h3><ul>
<li>只允许在同一个块作用域内跳转，或者跳转到上层的块作用域。</li>
<li>不得用于跳转到更深的块作用域或者其它平行的块作用域。</li>
<li>不允许使用goto在switch的多个case语句/default语句之间跳转；</li>
</ul>
<blockquote>
<p>迪杰斯特拉说要取消goto，编程这么久了还没用过goto这个语句</p>
</blockquote>
<p>例如：下述代码是不符合要求的。</p>
<pre><code>if (ok)
   goto ready;
func();
while(1){
ready:
//…
} </code></pre><h3 id="7-3-循环性能优化："><a href="#7-3-循环性能优化：" class="headerlink" title="7.3 循环性能优化："></a>7.3 循环性能优化：</h3><p>可以在循环体外进行的耗时计算不放入循环体中。” <strong>反例：</strong></p>
<pre><code>for(int i = 0; i &lt; lst.count(); ++i) {
    printf(&quot;%d&quot;, lst[i]);
}               </code></pre><p>注：lst是虚拟的一个list类，具有链表的含义，有count（利用遍历求链表长度）和operator[]（遍历取指定位置成员）两个成员函数。此例会导致count不必要的重复计算，时间复杂度O(n*n). 类似的还有下面这段代码：</p>
<pre><code>for(int i = 0; i &lt; strlen(str); ++i) {
    if (str[i] == &apos; &apos;) {
        break;
    }
}</code></pre><p><strong>学习了，以后针对这种应该在循环外定义一个变量，只计算一次，减少开销。</strong></p>
<h3 id="7-4-不使用复杂表达式："><a href="#7-4-不使用复杂表达式：" class="headerlink" title="7.4 不使用复杂表达式："></a>7.4 不使用复杂表达式：</h3><p>不使用过于复杂的表达式，如确实有必要这样写须注释说明该表达式的意思。鼓励把复杂表达式分拆成多句书写。虽然能减少代码量，但是生涩难懂对看代码的人来说是种负担</p>
<ul>
<li>所谓过于复杂的表达式，指一个运算数某一边的运算符个数大等于2个。 单目运算符+，-，<em>，!，~，&amp;，sizeof及括号[]，()不计算在内。 如：**</em>stat_poi ++ += 1<strong>；应拆分成*</strong>stat_poi += 1;++stat_poi；**</li>
<li><code>?:</code>运算符不允许嵌套使用，如：ret = a &lt; b ? (a &lt; c ? a : c) : (b &lt; c ? b : c);[2012-9-6]”</li>
</ul>
<h3 id="7-5-switch-case语句："><a href="#7-5-switch-case语句：" class="headerlink" title="7.5 switch/case语句："></a>7.5 switch/case语句：</h3><ul>
<li>每个<code>case</code>语句必须以<code>break</code>语句(或continue/goto/return/longjmp/exit等流程转移语句)结束。 如果不需要<code>break</code>，必须在末尾注释说明。《C陷阱》里也有提到。 如果该<code>case</code>标签后没有任何处理语句可以例外。没有处理语句的多个case标签可以写在一行；</li>
<li>每个switch语句都必须要有default标签；</li>
</ul>
<p>例如：</p>
<pre><code>switch (*pch) {
case &apos;:&apos;: case &apos;-&apos;:
    ...
    break;
case &apos;\0&apos;:
    return;
case &apos;%&apos;:
    ...
    /* no break */
default:
    ++pch;
    break;
} </code></pre><h3 id="7-6-控制结构-if-for-while-switch等-的嵌套："><a href="#7-6-控制结构-if-for-while-switch等-的嵌套：" class="headerlink" title="7.6 控制结构(if/for/while/switch等)的嵌套："></a>7.6 控制结构(if/for/while/switch等)的嵌套：</h3><blockquote>
<p>有时候条件查询又不得不用到多层嵌套，也可以用&amp;&amp;等将其提拉到平级控制</p>
</blockquote>
<ul>
<li>不使用过深的嵌套：循环嵌套不超过3层，总共不超过5层；</li>
<li>如果if子句和else子句行数相差超过3行，须保证else子句比if子句长。 如果该条件语句有多个条件，可以例外（即存在else if子句）。 建议使用短路返回的方法减少嵌套层数；</li>
</ul>
<p><strong>不合格嵌套：</strong></p>
<pre><code>for(int row = 0; row &lt; rowcnt; ++row) {
    for(int col = 0; col &lt; colcnt; ++col) {
        char *pname = g_pool[row][col].name;
        for(int i = 0; i &lt; MAX_NAME_LEN; ++i) {
            char ch = pname[i];
            for(int j = 0; j &lt; PREDEF_TABU_SIZE; ++j) {
                if (ch == g_predef_tabu[j]) {
                    return false;
                }
            }
            ...
        }  
    }
}</code></pre><p><strong>可以改造为：</strong></p>
<pre><code>inline bool is_tabu(char c)
{
    for(int j = 0; j &lt; PREDEF_TABU_SIZE; ++j) {
        if (ch == g_predef_tabu[j]) {
            return true;
        }
    }
    return false;
}
for(int row = 0; row &lt; rowcnt; ++row) {
    for(int col = 0; col &lt; colcnt; ++col) {
        char *pname = g_pool[row][col].name;
        for(int i = 0; i &lt; MAX_NAME_LEN; ++i) {
            char ch = pname[i];
            if (is_tabu(ch))
                return false;
            ...
        }  
    }
}</code></pre><p><strong>短路返回</strong></p>
<pre><code>if (match_condition()) {
    ... ...
    if (...)
        ... ...
} else {
    break;
}</code></pre><p><strong>改为以下语句就是短路返回:</strong></p>
<pre><code>if (!match_condition())
    break;
... ...
if (...)
    ... ... </code></pre><h2 id="8-错误处理"><a href="#8-错误处理" class="headerlink" title="8 错误处理"></a>8 错误处理</h2><h3 id="8-0-总则"><a href="#8-0-总则" class="headerlink" title="8.0 总则"></a>8.0 总则</h3><p>异常，无处不在。异常处理的完善程度，决定了代码的健壮程度。 有些异常需要在设计方案层面善加考虑，有些异常，却仅仅需要局部的关注、处理，就能得到很好的效果。异常是会传播和扩散的，城门失火，殃及池鱼。而且，一些关键信息会在异常传播过程中丢失，导致异常难以定位。所以，异常处理应遵守九字原则：早检查、勤记录、早处理。及早发现异常，记录上下文，处理异常，可以及早定位解决问题，并防止异常造成更大的破坏。 如果严谨的遵守以下checklist条款，在对程序进行逻辑分析时，就可以在局部聚焦正常数据、流程，无需关注其它逻辑引发的异常数据蔓延。也更不容易在代码维护过程中破坏一些假设条件，引入bug。</p>
<h3 id="8-1-参数合法性检测"><a href="#8-1-参数合法性检测" class="headerlink" title="8.1 参数合法性检测"></a>8.1 参数合法性检测</h3><p>主要集中在外部接口和内部函数</p>
<blockquote>
<p>外部接口：指会被其它模块调用的函数； 内部函数：指不会被其他模块调用的函数；</p>
</blockquote>
<ul>
<li><p>外部接口（指函数）在使用参数前需检查参数合法性。</p>
<ul>
<li>不使用该参数或该参数的任何取值都是合法值不会引起程序异常可以例外。</li>
<li>参数有效性检查不要用断言等只在调试版本生效的方法。</li>
<li>应当保证在release版本下检查处理措施依然有效，在发现不合法的参数时执行错误处理(比如返回标识错误的值，抛出异常,执行错误处理流程），保证程序健壮性。</li>
</ul>
</li>
<li><p>所有内部函数的函数入口处必须通过断言检查所有参数的合法性。</p>
<ul>
<li>不使用该参数或该参数的所有取值都是合法值，可以不检查该参数。</li>
</ul>
</li>
<li><p>无论外部接口还是内部函数，发现参数异常都必须输出供错误诊断用的调试信息。</p>
<ul>
<li>断言本身会输出诊断信息，故使用断言检测异常无需额外打印调试信息。”</li>
</ul>
</li>
</ul>
<p><strong>结构体或类对象的合法性可通过专门设计的检查函数或宏来进行。</strong> <strong>结构体的检查方法如：</strong></p>
<pre><code>struct str{
    char *ptr;
    size_t size;
};
#define CHECK_STR(x) ASSERT((x).ptr &amp;&amp; (x).size &lt; 1024)
void foo(struct str *p){
    ASSERT(p);
    CHECK_STR(*p);
    … … 
}</code></pre><p><strong>类对象的检查方法：</strong></p>
<pre><code>class str {
public:
#ifndef NDEBUG
    void assert_valid(){
        ASSERT(m_ptr);     //assert，断言assert的作用是现计算表达式 expression ，如果其值为假（即为0），那么它先向stderr打印一条出错信息。
        ASSERT(m_size &lt; 1024);
        //也就是如果m_ptr为空或者m_size &gt; 1024则报错！
    }
#endif
private:
    char *m_ptr;
    size_t m_size;
};
#define ASSERT_VALID(x) (x).assert_valid()  //直接调用类的
void foo(class str&amp; strs){
    ASSERT_VALID(strs);
    … … 
} </code></pre><h3 id="8-2-数据合法性检查："><a href="#8-2-数据合法性检查：" class="headerlink" title="8.2 数据合法性检查："></a>8.2 数据合法性检查：</h3><p>从外部读取的数据必须检查合法性，不可直接使用，外部数据指通过文件、进程间通讯设施或界面所获取的输入。 不使用该数据或该数据所有取值都是合法值可以例外。 外部数据的检查不应使用断言等仅在调试版本生效的措施。发现数据不满足要求时，必须输出供错误诊断用的调试信息。</p>
<blockquote>
<p>比如用户输入的数据，需要检查其合法性。</p>
</blockquote>
<h3 id="8-3-断言要求："><a href="#8-3-断言要求：" class="headerlink" title="8.3 断言要求："></a>8.3 断言要求：</h3><p>断言中禁止对变量赋值或改变变量的值，如<code>assert (size++ &gt; 100)</code>， 禁止调用有副作用的函数。 有副作用的函数，指函数内会更改变量值、改变系统环境、进行IO。</p>
<blockquote>
<p>和宏定义一样，不要有副作用</p>
</blockquote>
<h3 id="8-4-“return-返回值检查："><a href="#8-4-“return-返回值检查：" class="headerlink" title="8.4 “return - 返回值检查："></a>8.4 “return - 返回值检查：</h3><p>主要集中在API和内部函数里</p>
<ul>
<li><p>API： 对于返回新分配资源（句柄或指针）或者返回出错标识（比如使用FALSE，负数，0指针标识失败）的系统API（<strong>包括标准库、WIN32 API、MFC、ATL、POSIX API，第三方库</strong>），<strong>必须检查并处理失败情况。</strong> 不允许使用只在<code>DEBUG</code>版本生效的检查措施（比如：assert，VERIFY）。release也要检查！ 包括但不限于下述函数：</p>
<ul>
<li><p>malloc/realloc/calloc/new;</p>
</li>
<li><p>open/socket/pipe/epoll_create/pthread_create/fork/dup/popen;</p>
</li>
<li><p>CreateProcess/CreateThread/CreateFile;</p>
</li>
<li><p>fopen/fdopen/freopen;</p>
</li>
<li><p>GetMessage/PeekMessage;</p>
</li>
<li><p>mkdir/findfirst/lstat/recv/send;</p>
</li>
<li><p>sendto, recvfrom, bind, accept, sendmsg, recvmsg, setsockopt, select, poll, epoll_ctl,epoll_wait,connect；</p>
</li>
<li><p>例外：</p>
</li>
<li><p>如果忽略该错误不会影响程序正确性，可以在函数调用前加(void)忽略返回值检查。 建议同时注释说明为什么无需处理返回值；</p>
</li>
<li><p>如果API文档有明确说明，在条件满足时一定不会失败的，且调用该API之前已经保证满足不失败条件， 可以直接使用其返回值，或在函数调用前加(void)忽略返回值检查。例如snprintf,time等。</p>
</li>
</ul>
</li>
<li><p>内部函数： <strong>对于内部函数（非系统API），如果有返回值，且返回值会用于标识失败情况（比如使用FALSE，负数，0指针标识失败），必须检查并处理失败情况。</strong> 如果确认当前调用在用户环境不可能失败，或者该错误可以忽略，允许使用这两种错误处理手段：</p>
<ul>
<li><p>对于不可能失败的情况，可使用只在DEBUG版本生效的检查处理机制（如：assert,VERIFY）；[2010-9-8]</p>
</li>
<li><p><strong>在函数调用前面加(void)</strong>强调该函数不会出错或者错误可以忽略，建议同时注释说明为什么无需处理返回值；</p>
<p>(void)close(fd);        //调用close函数的时候强调void，表示其无返回值</p>
</li>
</ul>
</li>
</ul>
<p><strong>只要会返回失败，都应该应对失败情况。</strong></p>
<ul>
<li><p>对于recv,send一类函数调用来说，几乎不可能避免失败，而且失败的情况很多。必须针对每一种失败都有妥善的处理。允许把若干种失败情况合并起来处理。</p>
</li>
<li><p>对于一些有严格要求的程序来说，即使是<strong>CloseHandle/close</strong>一类的调用，也必须处理失败。比如流缓存、数据库一类的就需要检查CloseHandle/close，判断是否会有磁盘回写失败一类的情况。</p>
</li>
<li><p>对于一些要求没那么严格的程序来说，一般的处理方法是，在这些函数失败的时候打印日志信息，帮助开发者了解其中发生的异常情况。</p>
</li>
<li><p>如果明确不可能失败（比如有些函数资料已经明确说明只有在参数无效时才失败），或者不关注这种失败，可以用(void)CloseHandle(hFile)的方法处理返回值。这种方法可以屏蔽来自PC-LINT一类工具的警告，也可以提示代码阅读者知道作者不关注这个错误；</p>
</li>
</ul>
<h2 id="9-资源管理"><a href="#9-资源管理" class="headerlink" title="9 资源管理"></a>9 资源管理</h2><h3 id="9-0-总则"><a href="#9-0-总则" class="headerlink" title="9.0 总则"></a>9.0 总则</h3><p>资源问题是C/C++/ASM语言中独有的问题，这些语言认为资源管理非常重要，所以应该把资源管理权交给程序员，在语言机制上缺乏垃圾回收机制。 这种理念给了程序员更多的灵活性，能得到更好的性能，但也大大增加了出错的可能性。 最容易出现的资源问题有：</p>
<ul>
<li>资源使用完毕后没有释放；</li>
<li>资源重复释放；</li>
<li><strong>资源被释放后仍然被引用和访问，包括引用了已经被重新分配出去的资源</strong>。 比如：perror之类的函数默认往2号fd输出信息，如果先关闭2号fd，然后open/socket之类的调用会重用2这个fd，导致perror将信息错误输出到其它文件或socket；</li>
<li>使用错误的手段释放资源，比如使用fclose关闭被popen打开的FILE指针；</li>
</ul>
<p><strong>减少资源使用出错，有几个简单有效的原则：</strong></p>
<ul>
<li><p><strong>“配对”原则</strong>，即分配资源的函数出现在哪个函数里，与之配对的释放资源函数就应出现在哪个函数里。 <strong>- “使用前检查，释放后置空”</strong>原则，像这段代码一样的做法：</p>
<p> if (s_fp) { fclose(s_fp); s_fp = NULL;} </p>
</li>
</ul>
<h3 id="9-1-防止泄露："><a href="#9-1-防止泄露：" class="headerlink" title="9.1 防止泄露："></a>9.1 防止泄露：</h3><p>资源的分配和释放必须配对:</p>
<ul>
<li><p><strong>在某函数内分配的资源必须在该函数内释放</strong>；</p>
</li>
<li><p>如果函数分配了资源但不能马上释放，必须：</p>
<ul>
<li>必须有机制供调用者获取新分配的资源（通过返回值、出参、全局变量、类变量等）；</li>
<li>必须提供与之对应的能保证释放资源的函数(或者能通过delete,free等API直接释放)， 并在函数头的注释中说明负责释放的函数名称。 如果需要释放的资源是类的成员且负责释放的函数是析构函数，可不说明。析构函数自动释放资源。</li>
</ul>
</li>
</ul>
<h3 id="9-2-使用配套的资源释放函数释放资源（重点）"><a href="#9-2-使用配套的资源释放函数释放资源（重点）" class="headerlink" title="9.2 使用配套的资源释放函数释放资源（重点）"></a>9.2 使用配套的资源释放函数释放资源（重点）</h3><p>对于各类动态分配得到的资源，必须使用与之配套的释放函数释放。包括但不限于：</p>
<ul>
<li>open/creat/dup/socket/epoll_create分配的描述符由close释放；</li>
<li>fopen/fdopen/fopen分配的文件指针由fclose释放；</li>
<li>CreateFile分配的句柄由CloseHandle释放；</li>
<li>popen分配的文件指针由pclose释放；</li>
<li>new分配的内存由delete释放；</li>
<li><strong>new[]分配的内存由delete[]释放；</strong></li>
<li>malloc/realloc/strdup/calloc分配的内存由free释放；</li>
<li><strong>qdbm_open分配的数据结构由qdbm_close释放；</strong></li>
<li>kmalloc分配的由kfree释放；</li>
<li>vmalloc分配的由vfree释放；</li>
</ul>
<h3 id="9-3-避免重复释放："><a href="#9-3-避免重复释放：" class="headerlink" title="9.3 避免重复释放："></a>9.3 避免重复释放：</h3><ul>
<li><p>句柄或指针在资源释放结束后应置为无效值：</p>
<ul>
<li>delete/free后需要将指针置为0,不使用delete,free释放非堆内存;</li>
<li>close关闭的文件描述符必须置为-1；</li>
<li>fclose,pclose关闭的FILE指针必须置为0;</li>
<li>CloseHandle关闭的句柄必须置为INVALID_HANDLE_VALUE;</li>
<li>其它函数释放的资源必须置为对应的无效标识；</li>
</ul>
<p><strong>例外情况：</strong></p>
<ul>
<li>析构函数中可以例外；</li>
<li>即将退出程序时可以例外；</li>
<li>如果是局部变量且马上退出函数可以例外；</li>
<li>如果释放后马上指向其它有效资源的可以例外；</li>
</ul>
</li>
</ul>
<p><strong>以上例外情况需保证已释放资源不再被引用到。</strong></p>
<ul>
<li>释放资源前需判断句柄/指针的有效性，保证已经置为<strong>无效值的指针</strong>或句柄不会重复释放。能保证资源处于有效状态的可以例外。</li>
<li>如果释放函数本身能保证0指针或无效句柄释放的安全性，也可以例外，比如free(NULL)是安全的，无需if (!p) free(p)。</li>
</ul>
<p><strong>资源的分配和释放必须配对。即：</strong></p>
<ul>
<li>分配和释放应配对出现在同一个函数中，在父函数中分配的资源不应交给子函数释放，具体可参考注释；</li>
<li>一个分配不可对应多个释放操作；</li>
<li>如果封装了资源的分配，就应封装资源的释放，反过来也成立。这两个封装过的资源分配和释放操作应配对出现在同一个函数中。”</li>
</ul>
<p><strong>错误做法：</strong></p>
<pre><code>void child(void *p)
{
    //操作p ...
    free(p);
}

void parent(void)
{
    void *p = malloc(sizeof(int));
    child(p);
    //free(p);
}</code></pre><p>对于全局资源，建议：</p>
<pre><code>static char *s_buf;

int init_buf(void)
{
    if (s_buf)
        return 0;
    s_buf = malloc(BUFSIZ);
    return s_buf ? 0 : -1;
}

void clean_buf(void)
{
    if (!s_buf)
        return;
    free(s_buf);
    s_buf = NULL;
} </code></pre><h3 id="9-4-勿混用内存管理方法："><a href="#9-4-勿混用内存管理方法：" class="headerlink" title="9.4 勿混用内存管理方法："></a>9.4 勿混用内存管理方法：</h3><p>不能根据标识对同一个指针选用不同的内存管理方法（尤其是内存释放）</p>
<blockquote>
<p>delete和free不要混用，怎么声明的就怎么释放</p>
</blockquote>
<p>比如：</p>
<pre><code>void process_message(void *ptr, size_t size, bool bInHelp)
{
    ...
    if(bInHeap)
        free(ptr);
}
void post_send(void *ptr, size_t size, int flags)
{
    ...
    if (flags &amp; CRT_HEAP) {
        free(ptr);
    } else if (flags &amp; SYS_HEAP) {
        HeapFree(ptr);
    } else if (flags &amp; CPP_HEAP) {
        delete[] ptr;
    }
} </code></pre><h3 id="9-5-标准输入、输出、错误的关闭："><a href="#9-5-标准输入、输出、错误的关闭：" class="headerlink" title="9.5 标准输入、输出、错误的关闭："></a>9.5 标准输入、输出、错误的关闭：</h3><p>对于标准输入、标准输出、标准错误输出这三个文件，如果有必要关闭的话，<strong>必须将其重新打开，</strong> 定向到空文件描述符（比如/dev/null）。 <strong>这三个文件在不同平台下分别为：</strong></p>
<ul>
<li><p>linux下： 文件描述符为0，1，2；</p>
</li>
<li><p>windows下： GetStdHandle(STD_INPUT_HANDLE) GetStdHandle(STD_OUTPUT_HANDLE) GetStdhandle(STD_ERROR_HANDLE)</p>
</li>
<li><p>标准C中： stdin,stdout,stderr</p>
</li>
</ul>
<p><strong>将标准输入、标准输出、标准错误输出进行重定向：</strong></p>
<pre><code>close(0);
close(1);
close(2);
fd0 = open(&quot;/dev/null&quot;, O_RDWR);
fd1 = dup(fd0);
fd2 = dup(fd0);
if (fd0 != 0 || fd1 != 1 || fd2 != 2) {
   exit(1);
} </code></pre><h2 id="10-内存"><a href="#10-内存" class="headerlink" title="10 内存"></a>10 内存</h2><h3 id="10-0-总则"><a href="#10-0-总则" class="headerlink" title="10.0 总则"></a>10.0 总则</h3><blockquote>
<p>C语言中内存管理太难是许多人放弃c转向JAVA的主要原因</p>
</blockquote>
<p>内存问题是C/C++/ASM语言中独有的问题。 这些语言要<strong>求程序员自行管理对内存的访问，所以很容易因为程序员的失误引起bug。</strong></p>
<ul>
<li>尽量避免多个逻辑持有同一个内存块的引用/指针（<strong>某个逻辑释放内存块时，其它逻辑继续引用，引起悬挂访问）；</strong></li>
<li>尽量避免指针/引用长时间指向一个内存块的内部（当该内存块释放时可能引起悬挂访问）；</li>
<li><strong>变量总是应该初始化后再使用，尤其是指针</strong>；</li>
<li>对数组进行遍历时应当<strong>提防临界错误</strong>（比如＋1或－1的错误）；</li>
<li>警惕为<code>NULL</code>的指针和长度为<code>0</code>的数组；</li>
</ul>
<h3 id="10-1-变量初始化"><a href="#10-1-变量初始化" class="headerlink" title="10.1 变量初始化"></a>10.1 变量初始化</h3><p>1）<strong>对堆和栈上分配的变量、内存块进行了初始化；</strong> 例外情况：</p>
<ul>
<li>定义处和第一次赋值处相隔不超过5行，这两处之间未访问过该变量，<strong>并且没有出现过任何访问了该变量的控制结构（如if/for/while/switch/do等）。</strong></li>
</ul>
<p><strong>符合的例子：</strong></p>
<pre><code>int foo(const char *name) {
    int ret;
    printf(&quot;[debug] foo(%s) called\n&quot;, name);
    ret = find_hash(name);
    if (ret &lt; 0)
        return ret;
    return insert_hash(name); 
}</code></pre><p><strong>不符合例子：</strong></p>
<pre><code>int foo(const char *name) {
    int ret; 
    if (name &amp;&amp; name[0] != &apos;\0&apos;) {
        ret = find_hash(name);
        if (ret &lt; 0) {
            return ret;
        }
    }
    return insert_hash(name);
}</code></pre><p><strong>后续维护时，如果在insert_hash前加上访问ret的代码（如printf(“%d”, ret)）就会有问题了。</strong></p>
<ul>
<li>效率原因。这种情况须注释说明原因，且保证不出现读未初始化数据的问题。</li>
</ul>
<p>对于结构体、对象、字符串、数组等内存块，可以通过以下几种方法初始化：</p>
<ul>
<li>使用初始化列表，如：char buf[BUFSIZE] = {0};</li>
<li>使用构造函数、拷贝构造函数进行初始化；</li>
<li>使用memset，bzero等可以将内存块设置初始值的函数将整个内存块设置为某个初值， 或者使用memcpy等函数拷贝一块合法内存，保证整个内存块数据都为已初始化数据；</li>
</ul>
<p>使用赋值运算符对结构体和对象类型初始化，如：</p>
<pre><code>struct person customer;
customer = s_default_person;</code></pre><ul>
<li><strong>使用strcpy等能保证该内存块是合法字符串（有’\0’结尾）的函数初始化；</strong></li>
<li>使用分配时即初始化的函数（如calloc）进行内存分配；</li>
<li>使用其它自定义的函数，只要保证该数据块所有成员都已初始化为有效数据，或成为一个合法字符串（即’\0’之后的部分可以无需赋值）；</li>
</ul>
<p>2）作为出参使用的指针参数，必须在返回之前进行赋值。如明确无需赋值，需注释说明。 例子：</p>
<pre><code>void foo(const char *name) {
    char buf[BUFSIZE];  //get_full_name会首先初始化buf
    get_full_name(name, buf);
    printf(&quot;%s\n&quot;, buf);
}</code></pre><p>3）对于<strong>资源句柄</strong>（包括指针，下同），应初始化为一个<strong>无效标识值</strong>，或者通过分配得到的资源句柄，或者确定的可安全引用的资源句柄。 注意: 不要初始化为未获得授权的资源句柄，比如：<strong>把文件描述符直接初始化为0，或者将指针指向了不能安全访问的内存或变量（0除外）。</strong></p>
<h3 id="10-2-指针算术："><a href="#10-2-指针算术：" class="headerlink" title="10.2 指针算术："></a>10.2 指针算术：</h3><p>指针的移动</p>
<ul>
<li><strong>结构体类型的指针如果要指向下一个结构体头部，只要对指针加1，而不是加结构体长度；</strong></li>
<li>如果结构体是不定长的结构体，应该将指针先转换成char*类型，然后加需要偏移的字节长度；”</li>
</ul>
<p>例如:</p>
<pre><code>struct iphdr *iph = ip_hdr(skb);
struct tcphdr *tcph = (struct tcphdr *)(iph + (iph-&gt;ihl &lt;&lt; 2));

/上述代码有很严重的BUG，正确应该是：
struct tcphdr *tcph = (struct tcphdr *)((char *)iph + (iph-&gt;ihl &lt;&lt; 2)); </code></pre><h3 id="10-3-结构体比较："><a href="#10-3-结构体比较：" class="headerlink" title="10.3 结构体比较："></a>10.3 结构体比较：</h3><p>不使用memcmp（或者其它按位比较方法）比较两结构是否相等（C++类也一样）。 确认安全的允许例外，但须在类的注释中说明。”</p>
<blockquote>
<p>主要是注意结构体内存对齐的问题，memcmp比较需要保证结构体字节按1对其，结构体中必须没有空隙。</p>
</blockquote>
<p>比如：</p>
<pre><code>struct strus {
    char m_char;
    int m_int;
} a, b;

//strus占8个字节
a.m_char = 0; 
a.m_int = 0; 
b.m_char = 0;
b.m_int = 0;
if (memcmp(&amp;a, &amp;b, sizeof(a)) == 0) //有问题

if(a == b)  //比较的是a和b的地址

//理想的方法是重载==运算符，一个个比较 </code></pre><h3 id="10-4-字符串比较："><a href="#10-4-字符串比较：" class="headerlink" title="10.4 字符串比较："></a>10.4 字符串比较：</h3><p>禁止把字符串转成整数进行比较。如:</p>
<pre><code>if(*(int*)&quot;&quot;desc&quot;&quot; == *(int*)str)&quot; </code></pre><h3 id="10-5-防常量字符串修改："><a href="#10-5-防常量字符串修改：" class="headerlink" title="10.5 防常量字符串修改："></a>10.5 防常量字符串修改：</h3><p>不可修改常量字符串，比如</p>
<pre><code>char* p = &quot;&quot;NeiCun&quot;&quot;; 
p[0] =&apos;R&apos;; </code></pre><h3 id="10-6-字符串格式化："><a href="#10-6-字符串格式化：" class="headerlink" title="10.6 字符串格式化："></a>10.6 字符串格式化：</h3><ul>
<li>保证fprintf/sprintf/snprintf/printf参数的格式化控制符和实参的一致(gcc可以检查出部分此类问题）</li>
<li>通过外部数据得到的字符串不直接作为格式化参数（系统配置文件中的日志信息可以例外）；</li>
</ul>
<p>即用<code>printf(&quot;%s&quot;, strings)</code>替换掉<code>printf(strings)</code>。</p>
<h3 id="10-7-防止字符串缺结束符"><a href="#10-7-防止字符串缺结束符" class="headerlink" title="10.7 防止字符串缺结束符"></a>10.7 防止字符串缺结束符</h3><blockquote>
<p>这个问题很容易忽略，要相当注意</p>
</blockquote>
<ul>
<li>通过进程间通讯措施（比如：<strong>mmap/read/recv/recvfrom/fread/copy_from_user等</strong>）读取的内存块，</li>
<li>如块尾是一个字符串，需在末尾补’\0’，避免写入端没有写入’\0’结束符导致错误。</li>
</ul>
<p>例如：</p>
<pre><code>char *p = (char *)malloc(msgsize + 1);
int ret = recv(sk, p, msgsize, 0);
if (ret &lt;= 0) {
    …
}
p[msgsize] = &apos;\0&apos;; </code></pre><h3 id="10-8-字符串长度计算："><a href="#10-8-字符串长度计算：" class="headerlink" title="10.8 字符串长度计算："></a>10.8 字符串长度计算：</h3><blockquote>
<p>用strlen而不要用sizeof，后者是计算字符串定义长度</p>
</blockquote>
<ul>
<li>不可直接假定字符串长度，需使用strlen计算得到，分配容纳字符串的缓冲区，必须给’\0’结束符预留空间；</li>
<li>不可通过sizeof计算常量指针指向的字符串的长度； 作为特例：字面值常量的长度允许使用sizeof计算得到（sizeof计算得到的长度已经包含了’\0’结束符）。 如：</li>
</ul>
<pre><code>const char* pstr = &quot;hello&quot;;</code></pre><p><strong>通过<code>sizeof(pstr)</code>计算字符串长度是错误的，但是通过<code>sizeof(&quot;hello&quot;)-1</code>计算字符串长度是允许的。</strong></p>
<h3 id="10-9-变量大小、偏移计算："><a href="#10-9-变量大小、偏移计算：" class="headerlink" title="10.9 变量大小、偏移计算："></a>10.9 变量大小、偏移计算：</h3><ul>
<li>变量大小计算： <strong>计算变量大小，必须使用sizeof，不允许人为假定变量大小。</strong> 只要可能，就应该测量变量的大小，而不是测量类型的大小。（也就是不要测量int的大小，而是测量int a ，sizeof(a)）</li>
<li>成员偏移计算： 计算结构内成员的偏移使用offsetof（或和该宏等价的措施），不许人为假定成员偏移；</li>
</ul>
<p>比如：</p>
<pre><code>int val;

//推荐：
memcpy(buf, &amp;val, sizeof(val));
//不应该使用这两种：
memcpy(buf, &amp;val, 4);
memcpy(buf, &amp;val, sizeof(int));</code></pre><p><strong>对于通过参数传递的数组，无法直接测试数组长度，推荐：</strong></p>
<pre><code>void foo(int arr[ARRAY_SIZE])
{
    memcpy(g_buf, arr, sizeof(int) * ARRAY_SIZE);
}

//错误：
void foo(int arr[ARRAY_SIZE])
{
    memcpy(g_buf, arr, sizeof(arr));
} </code></pre><h3 id="10-10-C99的变长数组和alloca："><a href="#10-10-C99的变长数组和alloca：" class="headerlink" title="10.10 C99的变长数组和alloca："></a>10.10 C99的变长数组和alloca：</h3><ul>
<li>禁止使用C的变长数组；</li>
<li>禁止使用alloca/_alloca分配内存。</li>
</ul>
<p>建议使用std::vector或者malloc替代以上两种用法。 例如: C99的变长数组：</p>
<pre><code>void foo(int n)
{
    int a[n];

    a[0] = 1;
    ...
}</code></pre><p>上述代码在n的值超出范围时，会导致栈溢出。</p>
<h3 id="10-11-字符串转整数-浮点数："><a href="#10-11-字符串转整数-浮点数：" class="headerlink" title="10.11 字符串转整数/浮点数："></a>10.11 字符串转整数/浮点数：</h3><blockquote>
<p>将字符串转换为整数或者浮点数，不要使用ctype里的函数，可能会丢失精度</p>
</blockquote>
<p>不使用atoi,atol读取数字，除非对输入合法性没有要求的场合。 所使用的读取函数必须保证数字不被截断、不丢失精度，不能double变int。 建议：</p>
<ul>
<li>有符号整数建议使用strtol读取；</li>
<li>无符号整数建议使用strtoul读取；</li>
<li>浮点数建议使用strtod读取；</li>
<li>有符号的64位整数建议使用strtoll读取；</li>
<li>无符号的64位整数建议使用strtoull读取；”</li>
</ul>
<p>atoi和strtol函数均是把字符串转换成整数，两者的不同点主要是：</p>
<ul>
<li><p>atoi的返回值无法区分是正常的返回还是错误的返回，如：</p>
<p>int val;<br>val = atoi(“abc”); 与val = atoi(“0”);<br>两者返回的val均为0，因此无法区分哪个是正确parse后的值。</p>
</li>
</ul>
<ul>
<li><p>strtol函数对异常的返回可以设置errno，从而可以发现异常的返回，如：</p>
<p>errno = 0;    /* To distinguish success/failure after call */<br>val = strtol(str, &amp;endptr, base); </p>
</li>
</ul>
<h2 id="11-并发"><a href="#11-并发" class="headerlink" title="11 并发"></a>11 并发</h2><h3 id="11-0-总则"><a href="#11-0-总则" class="headerlink" title="11.0 总则"></a>11.0 总则</h3><p>并发指同一时间运行多个逻辑，<strong>包括使用分时手段运行的“伪”并发。</strong> 使用并发可以充分利用多CPU、多主机的性能，可以同时服务多个用户。 并发逻辑之间的相互影响非常难以分析，引发的缺陷很难重现和定位，所以应当审慎的选用你的并发方案。</p>
<ul>
<li>优先使用隔离能力强的并发手段，比如物理隔离的多台设备，内存空间隔离的多个进程，尽量不使用隔离能力差的多线程并发；</li>
<li>尽量限制并发逻辑之间的信息交互，降低并发逻辑之间的相互影响；</li>
</ul>
<h3 id="11-1-信号处理"><a href="#11-1-信号处理" class="headerlink" title="11.1 信号处理"></a>11.1 信号处理</h3><p>长时间运行的linux程序必须处理信号，必须处理或忽略的信号有SIGTERM，SIGINT，SIGPIPE，SIGBUS，SIGSEGV，SIGABRT。</p>
<ul>
<li>对于SIGPIPE信号，需忽略，或者保证处理之后程序仍能正常运行；</li>
<li>对于SIGBUS、SIGSEGV信号，应打印堆栈，保留现场信息供后续调试；</li>
<li>对于SIGCHLD信号，应保持系统默认行为，即SIG_DFL。</li>
</ul>
<p>如果能保证后续不调用和waitpid相关的函数（如system,pclose），或者程序逻辑不依赖waitpid的返回值，可以例外。 对于库代码，特别注意不要改变SIGCHLD的行为，以免影响库调用者的一些程序逻辑。</p>
<blockquote>
<p>要防止出现僵尸进程和孤儿进程</p>
</blockquote>
<h3 id="11-2-信号处理函数"><a href="#11-2-信号处理函数" class="headerlink" title="11.2 信号处理函数"></a>11.2 信号处理函数</h3><p><strong>信号处理函数中不调用不可重入函数</strong>。不可重入的函数<strong>典型特征</strong>有：</p>
<ul>
<li>内部使用了全局变量/静态变量，如：<code>malloc</code>，<code>printf</code>；</li>
<li>内部使用了可能导致死锁的机制，如：<code>localtime</code>，<code>localtime_r</code>；</li>
<li>调用了其它不可重入函数；</li>
</ul>
<p>建议采用的信号处理方法：<strong>在信号处理函数中仅仅设置信号标识（或计数），在主循环中判断信号标识执行相应的信号处理。</strong>（可以通过这个方法判断子进程）</p>
<blockquote>
<p>信号需要绑定函数，然后信号触发后调用相应的函数。具体信号函数可查资料。</p>
</blockquote>
<h3 id="11-3-不暴力终止线程"><a href="#11-3-不暴力终止线程" class="headerlink" title="11.3 不暴力终止线程"></a>11.3 不暴力终止线程</h3><p><strong>除非程序退出，否则不采用暴力方式终止线程。</strong> 推荐通过在线程函数中return的方式结束线程，但不强制要求，确认安全时使用pthread_exit/ExitThread退出线程也可以。</p>
<blockquote>
<p>一般用信号终止，绑定一个信号函数专门用来结束线程</p>
</blockquote>
<h3 id="11-4-wait-子进程-子线程的后事处理"><a href="#11-4-wait-子进程-子线程的后事处理" class="headerlink" title="11.4 wait - 子进程/子线程的后事处理"></a>11.4 wait - 子进程/子线程的后事处理</h3><p>处理进程的时候要注意：</p>
<ul>
<li>子进程终止后必须通过<code>waitpid/wait</code>等待结束，<strong>避免子进程成为僵尸进程；</strong></li>
<li>子线程必须使用<code>pthread_join</code>等待结束，或者使用<code>pthread_detach</code>使子线程成为detached状态，避免线程资源泄露；</li>
</ul>
<h3 id="11-5-互斥锁的使用"><a href="#11-5-互斥锁的使用" class="headerlink" title="11.5 互斥锁的使用"></a>11.5 互斥锁的使用</h3><blockquote>
<p>互斥是一个很重要的概念，尤其是在多进程/多线程编程中，还有数据库的使用</p>
</blockquote>
<p>主要注意以下几点：</p>
<ul>
<li>使用互斥锁之前，必须对互斥锁的结构体或对象进行初始化，或调用初始化函数；</li>
<li>使用互斥锁之后，必须使用销毁函数对互斥锁的结构体或对象进行销毁。使用<code>PTHREAD_MUTEX_INITIALIZER</code>初始化的可以例外；</li>
</ul>
<h3 id="11-6-锁定区域内睡眠"><a href="#11-6-锁定区域内睡眠" class="headerlink" title="11.6 锁定区域内睡眠"></a>11.6 锁定区域内睡眠</h3><p>在互斥锁锁定区域内<strong>不调用阻塞进程</strong>或者<strong>引发进程睡眠的系统调用</strong>，如果确实需要调用，须注释说明； 比如：</p>
<pre><code>//以下代码可能有问题：
lock();
sleep(1);
unlock();
－－－－－－－－－－－－－－－－
lock();
recv(sk, buf, bufsize, 0);
unlock(); </code></pre><h3 id="11-7-非递归锁的使用："><a href="#11-7-非递归锁的使用：" class="headerlink" title="11.7 非递归锁的使用："></a>11.7 非递归锁的使用：</h3><p>Mutex可以分为<strong>递归锁(recursive mutex)</strong>和<strong>非递归锁(non-recursive mutex)</strong>。可递归锁也可称为可重入锁(reentrant mutex)，非递归锁又叫不可重入锁(non-reentrant mutex)。 二者唯一的区别是：</p>
<ul>
<li>同一个线程可以多次获取同一个递归锁，不会产生死锁。</li>
<li>而如果一个线程多次获取同一个非递归锁，则会产生死锁。</li>
</ul>
<p>需要注意以下几点：</p>
<ul>
<li>非递归锁不用于递归函数；</li>
<li>非递归锁的锁定区域内不调用其它使用相同锁的函数。</li>
</ul>
<blockquote>
<p>(linux下的<code>pthread_mutex_t</code>默认是非递归锁，windows的临界区是递归锁）</p>
</blockquote>
<h3 id="11-8-死锁"><a href="#11-8-死锁" class="headerlink" title="11.8 死锁"></a>11.8 死锁</h3><p>以下情况会出现死锁：</p>
<ul>
<li><p>不解锁返回： 锁定区域内不允许出现不解锁的返回（包括抛出异常）</p>
</li>
<li><p>锁的相互等待： 如果两段代码同时使用<strong>两把相同的锁</strong>，<strong>不允许出现相互等待的现象</strong>。 例如：</p>
<p>//A线程：<br>lockA();<br>lockB();<br>unlockB();<br>unlockA()<br>//B线程：<br>lockB();<br>lockA();<br>unlockA();<br>unlockB() </p>
</li>
</ul>
<h3 id="11-9-线程创建"><a href="#11-9-线程创建" class="headerlink" title="11.9 线程创建"></a>11.9 线程创建</h3><p>线程创建需要注意以下情况：</p>
<ul>
<li><p><strong>失败处理</strong>： <strong>创建线程必须判断并处理失败情况；</strong> 说明：windows下创建线程可通过_beginthread/_beginthreadex/CreateThread/AfxBeginThread/线程类， Linux下创建线程可通过pthread_create。</p>
</li>
<li><p><strong>启动时序控制</strong>： 不可假定线程的执行顺序（除非创建时使用了CREATE_SUSPENDED等控制线程执行顺序的标志）， 不可简单使用sleep/usleep等不可靠方法来控制线程的执行顺序。</p>
</li>
<li><p><strong>Windows平台线程创建方法</strong>：</p>
<ul>
<li>在MFC中，创建界面线程使用AfxBeginThread或线程类，不使用_beginthread/_beginthreadex和CreateThread；</li>
<li>其它情况创建线程使用_beginthreadex（MFC中创建工作线程或非MFC程序），不直接使用CreateThread；</li>
</ul>
</li>
</ul>
<blockquote>
<p>linux的fork是创建进程</p>
</blockquote>
<h3 id="11-10-需要同步的访问："><a href="#11-10-需要同步的访问：" class="headerlink" title="11.10 需要同步的访问："></a>11.10 需要同步的访问：</h3><p>如果多个线程同时访问同一个变量，以下情况需要同步：</p>
<ul>
<li>一个线程线程先读后写，另一个线程有写；</li>
<li>一个线程写，另一个线程写了再读；（这种情况应避免，可以读临时值） 如果多个线程同时访问多个相联系的变量，只要一个线程有写，整个访问区间都应该同步保护，防止数据结构不一致。</li>
</ul>
<p><strong>单变量访问，比如：</strong></p>
<pre><code>//A线程：
if (g_cnt &lt; MAXCNT)
    g_cnt++;
//B线程：
if (g_cnt &gt; 0)
    g_cnt--;</code></pre><p>上述情况需要做同步。 <strong>多变量同时访问这两个变量：</strong></p>
<pre><code>char* buf;
int buf_cnt;
//A线程: 
buf[0] = 0;
buf_cnt = 0;
//B线程：
buf[0] = 10;
buf_cnt = 1;</code></pre><p>如果不做同步，可能造成“明明buf里已经没有数据”，但与之相关的buf_cnt计数却被置为1。</p>
<h2 id="12-危险的库特性"><a href="#12-危险的库特性" class="headerlink" title="12 危险的库特性"></a>12 危险的库特性</h2><h3 id="12-0-总则："><a href="#12-0-总则：" class="headerlink" title="12.0 总则："></a>12.0 总则：</h3><p>C&amp;C++标准库中存在一些不安全的特性或者函数，我们应当尽量避免使用。即使需要使用，也应该以保证安全的形式使用。</p>
<h3 id="12-1-错误号获取"><a href="#12-1-错误号获取" class="headerlink" title="12.1 错误号获取"></a>12.1 错误号获取</h3><p>在以错误号标识错误类型的API调用和错误号获取代码之间，不允许出现其它可能影响错误号的代码。 这些类型的API，包括Win32 API，socket API，标准C库函数。</p>
<blockquote>
<p>errno 是记录系统的最后一次错误代码。代码是一个int型的值，在errno.h中定义。查看错误代码errno是调试程序的一个重要方法。当linux C api函数发生异常时,一般会将errno变量(需include errno.h)赋一个整数值,不同的值表示不同的含义,可以通过查看该值推测出错的原因。在实际编程中用这一招解决了不少原本看来莫名其妙的问题。 比如：</p>
</blockquote>
<pre><code>1)
HANDLE hFile = CreateFile(…);
OnCreateFile(hFile, …);
if (hFile == INVALID_HANDLE_VALUE){
    DWORD err = GetLastError();
    ...
}
2)
HANDLE hFile = CreateFile(…);
if (hFile == INVALID_HANDLE_VALUE){
    WRITELOG(&quot;CreateFile failed\n&quot;);
    if (GetLastError() == XXX)
        ...
} </code></pre><h3 id="12-2-不混用文件机制"><a href="#12-2-不混用文件机制" class="headerlink" title="12.2 不混用文件机制"></a>12.2 不混用文件机制</h3><p>对同一文件或标准io流，不混用这三种机制：</p>
<ul>
<li>标准C库的文件IO（如: printf,fprintf,fseek,fgets）；</li>
<li>POSIX IO（如：open,ftruncate,lseek）；</li>
<li>C++ iostream(如：ostream, istream, fstream）；</li>
</ul>
<blockquote>
<p>主要根据自己写的是什么代码决定</p>
</blockquote>
<p>确定没有问题的可以例外，但需注释说明。</p>
<h3 id="12-3-不使用不安全函数："><a href="#12-3-不使用不安全函数：" class="headerlink" title="12.3 不使用不安全函数："></a>12.3 不使用不安全函数：</h3><p>标准库(或posix)中存在一些历史遗留的不安全函数，这些函数标准库已经提供了对应的安全版本。 对于这类函数，必须使用其安全版本，包括：</p>
<ul>
<li>提供了后缀为_r的替代函数的不可重入函数：<code>strtok,localtime,asctime,ctime,gmtime；</code></li>
<li>不判断输入长度的函数：gets；</li>
</ul>
<blockquote>
<p>VS里有使用后缀为_s的替代函数</p>
</blockquote>
<h2 id="13-危险的语言特性"><a href="#13-危险的语言特性" class="headerlink" title="13 危险的语言特性"></a>13 危险的语言特性</h2><h3 id="13-0-总则"><a href="#13-0-总则" class="headerlink" title="13.0 总则"></a>13.0 总则</h3><p>C&amp;C++语言中存在一些特征，这些特性或者很容易导致缺陷，或者是由实现定义，容易引起可移植性问题。</p>
<ul>
<li>不使用由实现定义的特性，如果确实有必要，<strong>应将这部分代码独立出来</strong>，通过条件编译技术保证各平台上的一致性；</li>
<li><strong>不使用未定义的语言特征，比如访问未初始化数据；</strong></li>
</ul>
<h3 id="13-1-自增-自减运算："><a href="#13-1-自增-自减运算：" class="headerlink" title="13.1 自增/自减运算："></a>13.1 自增/自减运算：</h3><p>表达式计算结果不能依赖于<strong>副作用</strong>计算发生的时机。</p>
<ul>
<li>同一语句中不得对同一变量使用多次自增或自减运算符。比如：*p++ = 2 + *p++;</li>
<li>不允许在一个表达式中既对该变量赋值，又对该变量使用自增/自减运算符。 <strong>比如：it = lst.erase(it++);</strong></li>
</ul>
<h3 id="13-2-参数顺序依赖性："><a href="#13-2-参数顺序依赖性：" class="headerlink" title="13.2 参数顺序依赖性："></a>13.2 参数顺序依赖性：</h3><p>函数调用参数列表中，参数值的计算<strong>不得有顺序依赖性。</strong> 比如：</p>
<pre><code>Call(a = b, ++a);
Call(foo1(), foo2());</code></pre><p>其中foo1和foo2的执行顺序不同会造成不同结果。</p>
<h3 id="13-3-char类型使用："><a href="#13-3-char类型使用：" class="headerlink" title="13.3 char类型使用："></a>13.3 char类型使用：</h3><ul>
<li>不直接使用char类型的变量做数组的索引。char类型既可能是有符号的(值的范围：-128<del>127)，也可能没符号(值的范围：0</del>255)。</li>
<li>需要将char变量当成int等类型使用前，必须先将char类型转化为unsigned char类型。</li>
<li>不使用<code>getch,fgetc,getchar,getc</code>返回的int型变量做数组索引（除非已经确定值大等于0）。”</li>
</ul>
<h3 id="13-4-除0错误预防-包括求余运算）："><a href="#13-4-除0错误预防-包括求余运算）：" class="headerlink" title="13.4 除0错误预防(包括求余运算）："></a>13.4 除0错误预防(包括求余运算）：</h3><ul>
<li>用作除数的变量需保证不为0。</li>
<li>求余运算符的右操作数也需保证不为0。</li>
<li>如果该变量来自不可信的输入（外部输入或者其它模块传递的参数），必须先判断是否为0，为0时不作为除数参与运算。”</li>
</ul>
<p>例如:</p>
<pre><code>size_t unitsize = ini_get(&quot;unitsize&quot;);
if (unitsize == 0)
    unitsize = 1;
size_t unitnum = size / unitsize; </code></pre><h3 id="13-5-指针转换："><a href="#13-5-指针转换：" class="headerlink" title="13.5 指针转换："></a>13.5 指针转换：</h3><p>void*类型的指针和其它类型的指针之间必须使用强制转换；</p>
<h3 id="13-6-移位运算："><a href="#13-6-移位运算：" class="headerlink" title="13.6 移位运算："></a>13.6 移位运算：</h3><p>移位运算的右操作数（即移动位数）必须大等于0并小于左操作数的位数；” &lt; C缺陷里有提到</p>
<h2 id="14-工具检查"><a href="#14-工具检查" class="headerlink" title="14 工具检查"></a>14 工具检查</h2><h3 id="14-0-总则："><a href="#14-0-总则：" class="headerlink" title="14.0 总则："></a>14.0 总则：</h3><p>工欲善其事，必先利其器。 善用代码静态扫描工具，可以找出代码中容易引起问题的不良写法，能找出部分内存访问或逻辑冲突之类的低级错误。</p>
<h3 id="14-1-cppcheck："><a href="#14-1-cppcheck：" class="headerlink" title="14.1 cppcheck："></a>14.1 cppcheck：</h3><p>所有C/C++代码须通过cppcheck检查，检查时须打开所有的检查选项。 除可以明确是误报的以外，不允许出现任何BUG及风格问题。(第三方代码除外）</p>
<blockquote>
<p>Cppcheck是一种C/C++代码缺陷静态检查工具，不同于C/C++编译器及其它分析工具，Cppcheck只检查编译器检查不出来的bug，不检查语法错误。</p>
</blockquote>
<h3 id="14-2-c-test-需编译-："><a href="#14-2-c-test-需编译-：" class="headerlink" title="14.2 c++test(需编译)："></a>14.2 c++test(需编译)：</h3><p>所有C/C++代码须通过C++test检查。除可以明确是误报的以外，不允许出现任何警告及错误(第三方代码除外）。 扫描需使用公司预置选项，如果需要额外关闭某些检查选项，需提前取得RDM书面认可。</p>
<blockquote>
<p>cppcheck是静态，这个需要编译</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/28/e7-ac-ac-e4-b8-83-e7-ab-a0-e5-8f-af-e7-a7-bb-e6-a4-8d-e6-80-a7-e7-bc-ba-e9-99-b7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/28/e7-ac-ac-e4-b8-83-e7-ab-a0-e5-8f-af-e7-a7-bb-e6-a4-8d-e6-80-a7-e7-bc-ba-e9-99-b7/" class="post-title-link" itemprop="url">第七章 可移植性缺陷</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-28 07:27:31" itemprop="dateCreated datePublished" datetime="2018-04-28T07:27:31+08:00">2018-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第七章-可移植性缺陷"><a href="#第七章-可移植性缺陷" class="headerlink" title="第七章 可移植性缺陷"></a>第七章 可移植性缺陷</h1><p><code>《C陷阱与缺陷》学习笔记``posts</code></p>
<ul>
<li><a href="#第七章-可移植性缺陷">第七章 可移植性缺陷</a><ul>
<li><a href="#导读">导读</a></li>
<li><a href="#71-应对c语言标准变更">7.1 应对C语言标准变更</a></li>
<li><a href="#72-标识符名称的限制">7.2 标识符名称的限制</a></li>
<li><a href="#73-整数的大小">7.3 整数的大小</a></li>
<li><a href="#74-字符是有符号整数还是无符号整数">7.4 字符是有符号整数还是无符号整数</a></li>
<li><a href="#75-移位运算符">7.5 移位运算符</a></li>
<li><a href="#76-内存位置0">7.6 内存位置0</a></li>
<li><a href="#77-除法运算时发生的截断">7.7 除法运算时发生的截断</a></li>
<li><a href="#78-随机数的大小">7.8 随机数的大小</a></li>
<li><a href="#79-大小写转换">7.9 大小写转换</a></li>
<li><a href="#710-首先释放然后重新分配">7.10 首先释放，然后重新分配</a></li>
<li><a href="#711-可移植性问题的一个例子">7.11 可移植性问题的一个例子</a></li>
</ul>
</li>
</ul>
<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>C语言编写的程序能够方便地在不同的编程环境中移植。</p>
<h2 id="7-1-应对C语言标准变更"><a href="#7-1-应对C语言标准变更" class="headerlink" title="7.1 应对C语言标准变更"></a>7.1 应对C语言标准变更</h2><p>C语言的标准一直在变化，比如<code>ANSI C</code>标准是现在用的最多的，但是其一直在增加新的特性。有些人如果没有及时升级，那么可能新版本的代码在他的电脑上就不能运行了。 比如函数原型的概念：</p>
<pre><code>1.double
2.square(double x)
3.{
4.        return x*x;
5.}</code></pre><p>这样写是不能通过编译的，很奇怪的写法。一般我们都是这样写：</p>
<pre><code>1.double square(double x)
2.{
3.    return x*x;
4.}
5.main ()
6.{
7.    double a = square(10);
8.}</code></pre><p>这样在square声明中表面x是double类型，而不是其他的。</p>
<h2 id="7-2-标识符名称的限制"><a href="#7-2-标识符名称的限制" class="headerlink" title="7.2 标识符名称的限制"></a>7.2 标识符名称的限制</h2><p>目前的C语言的标识符是对大小写敏感的，但是在以前版本的ANSI C标准所能保证的是，必须能够区别前6个字符不同的外部名称。而且，这个定义中并没有区分大写字母与其对应的小写字母。 <strong>所以编译器禁止使用与库函数同名的标志，即使大小写也不行！</strong></p>
<h2 id="7-3-整数的大小"><a href="#7-3-整数的大小" class="headerlink" title="7.3 整数的大小"></a>7.3 整数的大小</h2><p>C语言中有三种不同长度的整数：</p>
<ul>
<li>short</li>
<li>int</li>
<li>long</li>
</ul>
<p>C语言的定义中对各种不同类型整数的相对长度作了一些规定：</p>
<ul>
<li>3种类型的整数其长度是非递减的。也就是说，<code>short</code>型整数容纳的值肯定能被<code>int</code>型整数容纳；</li>
<li>一个普通（<code>int</code>类型）整数足够大以容纳任何数组下标；</li>
<li>字符长度由硬件特性决定（比如<code>long</code>类型在<code>32</code>位和<code>64</code>位的值可能不同，一个占<code>4</code>字节，一个占<code>8</code>字节）。</li>
</ul>
<h2 id="7-4-字符是有符号整数还是无符号整数"><a href="#7-4-字符是有符号整数还是无符号整数" class="headerlink" title="7.4 字符是有符号整数还是无符号整数"></a>7.4 字符是有符号整数还是无符号整数</h2><p>当要把char类型转到int类型，是要将字符作为有符号数还是应该无符号处理？正确的来说是应该作无符号处理的。但是c在转换为无符号的时候会先被转换成<code>int</code>类型，这样可能得到非预期的效果。 正确的方式是使用语句<code>(unsigned char)c</code>，因为一个unsighed char类型的字符在转换为无符号整数时无需首先转换为int类型，而是直接进行转换。</p>
<h2 id="7-5-移位运算符"><a href="#7-5-移位运算符" class="headerlink" title="7.5 移位运算符"></a>7.5 移位运算符</h2><p>对数进行移位的时候，空出的位会背哦符号位所填充。要注意一个规则：</p>
<blockquote>
<p>如果被移位的对象长度是n位，那么移位计数必须大于或等于0，而严格小于n。</p>
</blockquote>
<p>举例来说，如果一个int型整数是32位，n是一个int型整数，那么<code>n&lt;&lt;31</code>和n<code>&lt;&lt;0</code>这样是合法的，而<code>n&lt;&lt;32</code>和<code>n&lt;&lt;-1</code>是非法的。 且可以用移位运算符代替除法运算符，但要被移位的必须是非负数。</p>
<pre><code>mid = (low + high) &gt;&gt; 1;
mid = (low + high ) / 2;

a=a*4; 
b=b/4; 
//可以改为
a=a&lt;&lt;2; 
b=b&gt;&gt;2; </code></pre><blockquote>
<p>说明： 除2 = 右移1位 乘2 = 左移1位 除4 = 右移2位 乘4 = 左移2位 除8 = 右移3位 乘8 = 左移3位</p>
</blockquote>
<h2 id="7-6-内存位置0"><a href="#7-6-内存位置0" class="headerlink" title="7.6 内存位置0"></a>7.6 内存位置0</h2><p>null指针并不指向任何对象。因此，除非是用于赋值或比较运算，出于其他任何目的使用null指针都是非法的。 不同的编译器有不同的效果，有一些对内存位置0只允许读，不允许写。要检查出这类问题的最简单的办法就是，把程序移到不允许读内存位置0的机器上运行。</p>
<h2 id="7-7-除法运算时发生的截断"><a href="#7-7-除法运算时发生的截断" class="headerlink" title="7.7 除法运算时发生的截断"></a>7.7 除法运算时发生的截断</h2><p>假定我们让a除以b，商为q，余数为r：</p>
<pre><code>1.q= a/b;
2.r= a%b;</code></pre><p>我们希望a、b、q、r之间维持怎样的关系呢？</p>
<ul>
<li>最重要的一点，我们希望q*b+r==a，因为这是定义余数的关系。</li>
<li>如果我们改变a的正负号，我们希望这会改变q的符号，这不会改变q的绝对值。</li>
<li>当b&gt;0时，我们希望保证r&gt;=0且r&lt;b。例如，如果余数用于哈希表的索引，确保它是一个有效的索引值很重要。</li>
</ul>
<p><strong>余数与被除数的正负号要相同</strong>，否则上述条件都不能满足。所以在取余的时候尽量避免被余数为负，最好是为<strong>无符号数</strong>。</p>
<h2 id="7-8-随机数的大小"><a href="#7-8-随机数的大小" class="headerlink" title="7.8 随机数的大小"></a>7.8 随机数的大小</h2><p>随机数其实是伪随机数，有一定规律。现在实现随机数会加上时间种子，根据时间的变化产生相应的随机数。 如果想要一定范围的随机数，可以将其对范围值取余。比如1到100的随机数：</p>
<pre><code>1.b=rand()%100;</code></pre><h2 id="7-9-大小写转换"><a href="#7-9-大小写转换" class="headerlink" title="7.9 大小写转换"></a>7.9 大小写转换</h2><pre><code>1.#define toupper(c) ((c) + &apos;A&apos; - &apos;a&apos;)
2.#define tolower(c) ((c) + &apos;a&apos; - &apos;A&apos;)</code></pre><p>早起的库函数toupper和tolower是这样实现的。但是有不足之处，如果输入的不是字母就会产生其他垃圾信息。</p>
<h2 id="7-10-首先释放，然后重新分配"><a href="#7-10-首先释放，然后重新分配" class="headerlink" title="7.10 首先释放，然后重新分配"></a>7.10 首先释放，然后重新分配</h2><p>大多数c语言实现都为使用者提供了3个内存分配函数：<code>malloc</code>，<code>realloc</code>和<code>free</code>。其他的不说，这个realloc有点陌生。 调用realloc函数时，需要把指针向一块已分配内存的区域指针以及这块内存新的大小作为参数传入，就可以调整这块内存区域为新的大小，这个过程可能涉及到内存的拷贝。</p>
<pre><code>1.free(p);
2.p = realloc (p, newsize);</code></pre><p>先释放再分配是第七版参考手册中所规定的。</p>
<h2 id="7-11-可移植性问题的一个例子"><a href="#7-11-可移植性问题的一个例子" class="headerlink" title="7.11 可移植性问题的一个例子"></a>7.11 可移植性问题的一个例子</h2><p>看不懂（狗头）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/28/e7-ac-ac-e5-85-ad-e7-ab-a0-e9-a2-84-e5-a4-84-e7-90-86-e5-99-a8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/28/e7-ac-ac-e5-85-ad-e7-ab-a0-e9-a2-84-e5-a4-84-e7-90-86-e5-99-a8/" class="post-title-link" itemprop="url">第六章 预处理器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-28 01:28:21" itemprop="dateCreated datePublished" datetime="2018-04-28T01:28:21+08:00">2018-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第六章-预处理器"><a href="#第六章-预处理器" class="headerlink" title="第六章 预处理器"></a>第六章 预处理器</h1><p><code>《C陷阱与缺陷》学习笔记``posts</code></p>
<ul>
<li><a href="#第六章-预处理器">第六章 预处理器</a><ul>
<li><a href="#导读">导读</a></li>
<li><a href="#61-不能忽视宏定义中的空格">6.1 不能忽视宏定义中的空格</a></li>
<li><a href="#62-宏并不是函数">6.2 宏并不是函数</a><ul>
<li><a href="#621-括号预防优先级问题">6.2.1 括号预防优先级问题</a></li>
<li><a href="#622-避免参数副作用">6.2.2 避免参数副作用</a></li>
</ul>
</li>
<li><a href="#63-宏并不是语句">6.3 宏并不是语句</a></li>
<li><a href="#63-宏并不是类型定义">6.3 宏并不是类型定义</a></li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
</ul>
<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>预处理器使得编程者可以简化某些工作，它的重要性可以由两个主要的原因说明。</p>
<ul>
<li>第一，有时候我们希望将某个特定数量（如数据表的大小）在程序中出现的<strong>所有实例</strong>统统加以修改。只要改一个地方，其他所有地方都修改。</li>
<li>第二，C语言函数调用时都会带来巨大的系统开销。因此，我们希望有这样一种程序块，它看上去像一个函数，但却没有函数调用。比如，<code>getchar</code>和<code>putchar</code>经常被实现为宏，</li>
</ul>
<p>宏的作用非常强大，有时候可以使代码看起来更加容易理解，将数字或符号替换为自己熟悉的命名。</p>
<h2 id="6-1-不能忽视宏定义中的空格"><a href="#6-1-不能忽视宏定义中的空格" class="headerlink" title="6.1 不能忽视宏定义中的空格"></a>6.1 不能忽视宏定义中的空格</h2><p>宏也是有参数的，和函数一样。函数有空格无关紧要，但是如果宏定义带了空格意思就不一样了。 比如</p>
<pre><code>#define f (x) ((x) - 1)</code></pre><p>可能观察不仔细的人会以为是将f(x)替换成((x) - 1)，这样编译通过不了！所以必须要像下面这样写：</p>
<pre><code>#define f(x) ((x) - 1)</code></pre><p><strong>这一规则不适用与宏调用，只对宏定义有用。因此，在上面完成宏定义后，f(3)与f (3)求值后都等于2。</strong></p>
<h2 id="6-2-宏并不是函数"><a href="#6-2-宏并不是函数" class="headerlink" title="6.2 宏并不是函数"></a>6.2 宏并不是函数</h2><h3 id="6-2-1-括号预防优先级问题"><a href="#6-2-1-括号预防优先级问题" class="headerlink" title="6.2.1 括号预防优先级问题"></a>6.2.1 括号预防优先级问题</h3><p>宏严格来说并不是函数，但是很多程序员都喜欢把一些简单的函数定义为宏。比如如下写法：</p>
<pre><code>#define abs(x) (((x) &gt;= 0) ? (x) : -(x))
#define max(a,b) ((a) &gt; (b) ? (a) : (b))</code></pre><p>之所以这么多括号是预防引起<code>优先级</code>有关的问题，如果没有括号可能会造成优先级的问题。因为宏不像函数，宏只是起到了一个替换的作用，直接将define的中间替换为后面的表达式。比如</p>
<pre><code>#define abs(x) x&gt;0?x:-x
abs(a-b);       //</code></pre><p>会被展开为 <code>a-b&gt;0?a-b:-a-b</code>，其中的-a-b相当于(-a)-b，而不是想象中的-(a-b)。所以最好用括号括起来。</p>
<h3 id="6-2-2-避免参数副作用"><a href="#6-2-2-避免参数副作用" class="headerlink" title="6.2.2 避免参数副作用"></a>6.2.2 避免参数副作用</h3><p>在用到类似的三元运算符宏定义<code>#define max(a,b) a&gt;b ? a : b</code>时，因避免在三元运算符里对数进行改变而产生<strong>副作用</strong>。比如：</p>
<pre><code>biggest = ((biggest) &gt; (x[i++]) &gt; (biggest) : (x[i++]));</code></pre><p>在上述表达式中，若<code>i</code>为<code>0</code>，那么<code>biggest</code>会与<code>x[0]</code>先比较，然后因为<code>i++</code>的作用，此时<code>i</code>为1，然后再在后面的赋值中又有<code>i++</code>，此时计算完毕<code>i</code>的值已经为<code>2</code>，而不是预料之中的<code>1</code>。 所以要确保<strong>max中的参数没有副作用</strong>。</p>
<h2 id="6-3-宏并不是语句"><a href="#6-3-宏并不是语句" class="headerlink" title="6.3 宏并不是语句"></a>6.3 宏并不是语句</h2><p>有些人会认为宏也是语句，如果单独使用也和语句一样，有分号作终止符，其实大错特错！ 比如assert宏，它的参数是一个表达式，如果该表达式为0，就使程序终止执行并给出一条错误信息。</p>
<pre><code>#define assert(e) if(!e) assert_error(_FILE,_LINE_)

if(x &gt; 0 &amp;&amp; y &gt; 0)
    assert(x &gt; y);
else
    assert(y &gt; x);</code></pre><p>上面的式子通过宏替换后就是这样样子:</p>
<pre><code>if( x &gt; 0 &amp;&amp; y &gt; 0)
    if(!(x &gt; y)) assert_error(&quot;foo.c&quot;,37);
else
    if(!(y &gt; x)) assert_error(&quot;foo.c&quot;,39);</code></pre><p>请注意之前的if-else结合优先级问题，未匹配的<code>else</code>会与其最近的<code>if</code>结合。将代码适当缩排一下：</p>
<pre><code>if( x &gt; 0 &amp;&amp; y &gt; 0)
    if(!(x &gt; y)) 
        assert_error(&quot;foo.c&quot;,37);
    else
        if(!(y &gt; x)) 
            assert_error(&quot;foo.c&quot;,39);</code></pre><p>可以看到实际流程与我们想象中的有所出入，那么如何解决这个问题？ 这样定义assert：</p>
<pre><code>#define assert(e) ((void)((e))||_assert_error(__FILE__,__LINE__)))</code></pre><p>这个定义实际上利用了<code>||</code>运算符对两侧的操作数依次顺序求值的性质。具体的也不是很理解。</p>
<h2 id="6-3-宏并不是类型定义"><a href="#6-3-宏并不是类型定义" class="headerlink" title="6.3 宏并不是类型定义"></a>6.3 宏并不是类型定义</h2><p>宏的一个常见用途是，使多个不同变量的类型可在一个地方说明：</p>
<pre><code>#define FOOTYPE struct foo
FOOTYPE a;
FOOTYPE b,c;</code></pre><p>这样，编程者只需在程序中改动一行代码，即可改变<code>a、b、c</code>的类型，而与<code>a、b、c</code>在程序中的什么地方声明无关。这种用法有一个优点——<strong><code>可移植性</code></strong>。但是我们最好还是使用类型定义：</p>
<pre><code>typedef struct foo FOOTYPE;</code></pre><p>看起来差不多，但是使用起来就会有很大的差别。例如，如下代码：</p>
<pre><code>#define T1 struct foo *
typedef struct foo  *T2;</code></pre><p>从上面看，<code>T1</code>和<code>T2</code>好像完全一样，都是指向结构<code>foo</code>的指针。但是当我们试图用他们来声明多个变量时，问题就来了。</p>
<pre><code>T1 a, b;
T2 a, b;
//第一个声明被扩展为：
struct foo *a, b;</code></pre><p>这个语句中<code>a</code>被定义为一个指向结构的指针，而<code>b</code>却被定义为一个结构。第二个声明则不同，它定义的都是指向结构的指针。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>宏是一个强大的功能，用好了则事半功倍，否则事倍功半！总结以下几点，写代码的时候要十分注意。</p>
<ul>
<li><strong>宏不要随便加空格</strong>，因为<code>define</code>后面的<code>两个式子</code>就是<code>相互替换</code>的关系，如果多了一个空格那么就会变成三个式子；</li>
<li><strong>宏不是函数</strong>，是直接替换内容，要考虑运算符优先级的问题，必要时应该加上空格防止优先级错误；</li>
<li><strong>宏要避免参数副作用</strong>，不要在宏里进行多余的操作，比如<code>++</code>操作；</li>
<li><strong>宏不是语句</strong>，不要想当然的当成语句来处理，需要加分号等结束符；</li>
<li><strong>宏不适用于类型定义</strong>，多重定义的时候会出现歧义。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/26/e7-ac-ac-e4-ba-94-e7-ab-a0-e5-ba-93-e5-87-bd-e6-95-b0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/26/e7-ac-ac-e4-ba-94-e7-ab-a0-e5-ba-93-e5-87-bd-e6-95-b0/" class="post-title-link" itemprop="url">第五章 库函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-26 01:16:41" itemprop="dateCreated datePublished" datetime="2018-04-26T01:16:41+08:00">2018-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第五章-库函数"><a href="#第五章-库函数" class="headerlink" title="第五章 库函数"></a>第五章 库函数</h1><p><code>《C陷阱与缺陷》学习笔记``posts</code></p>
<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>C语言中没有定义输入/输出语句，任何一个有用的C程序都必须调用库函数来完成最基本的输入/输出操作。</p>
<blockquote>
<p>就像内存相关的的函数malloc和free是库函数，但是C++里的new和delete是运算符。</p>
</blockquote>
<p>最好尽量使用系统头文件，因为库文件的编写是经过深思熟虑的，代码的功能都是十分完全的。</p>
<ul>
<li><a href="#第五章-库函数">第五章 库函数</a><ul>
<li><a href="#导读">导读</a></li>
<li><a href="#51-返回整数的getchar函数">5.1 返回整数的getchar函数</a></li>
<li><a href="#52-更新顺序文件">5.2 更新顺序文件</a><ul>
<li><a href="#521-函数理解">5.2.1 函数理解</a></li>
<li><a href="#522-代码解释">5.2.2 代码解释</a></li>
<li><a href="#523-如果不fseek直接fread会发生什么呢">5.2.3 如果不fseek直接fread会发生什么呢？</a></li>
</ul>
</li>
<li><a href="#53-缓冲输出与内存分配">5.3 缓冲输出与内存分配</a><ul>
<li><a href="#531-使用setbuf库函数">5.3.1 使用setbuf库函数</a></li>
</ul>
</li>
<li><a href="#54-使用errno">5.4 使用errno</a></li>
<li><a href="#55-库函数signal">5.5 库函数signal</a></li>
</ul>
</li>
</ul>
<h2 id="5-1-返回整数的getchar函数"><a href="#5-1-返回整数的getchar函数" class="headerlink" title="5.1 返回整数的getchar函数"></a>5.1 返回整数的getchar函数</h2><blockquote>
<p>第一眼看到getchar就想起了缓冲回车符，有时候如果不多加一个getchar来缓冲回车符代码就会出错。因为回车也是一个符号，也会进入缓冲区，getchar就是从缓冲区一个个读字符。getchar() 在键盘输入信息时, 并不是在键盘上敲一个字符，该字符就立即送到计算机中，这些字符暂存在键盘的缓冲区中，只有按了Enter键才会把这些字符一起送到计算机中。</p>
</blockquote>
<p>为什么getchar会返回整数int？先看看下面这个例子：</p>
<pre><code>#include&lt;stdio.h&gt;
main()
{
    char c;
    while((c = getchar()) != EOF )
            putchar(c);
}</code></pre><p>C语言中对getchar的描述为：</p>
<pre><code>int getchar(void);</code></pre><p>按理返回值应用<code>char</code>,但为了包含<code>EOF</code>，<code>EOF</code>是一个整型数，通常值为<code>-1</code>，<code>char</code>就装不下，就用了更大的int来装（ASCII码的取值范围<code>0-127</code>）。 编译器会把<code>EOF</code>做<strong>“截断”</strong>处理，把被<strong>“截断”</strong>的值返回给<code>c</code>。</p>
<h2 id="5-2-更新顺序文件"><a href="#5-2-更新顺序文件" class="headerlink" title="5.2 更新顺序文件"></a>5.2 更新顺序文件</h2><blockquote>
<p>可以看一下这篇问答，讲的很好！<a href="http://www.dewen.net.cn/q/9263/%E8%B0%83%E7%94%A8fread%E5%90%8E%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8fwrite%E5%86%99%E4%B8%8D%E8%BF%9B%E5%8E%BB%EF%BC%8C%E5%8F%8D%E4%B9%8B%E4%B9%9F%E6%98%AF%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F" target="_blank" rel="noopener">调用fread后直接调用fwrite写不进去，反之也是，为什么？</a></p>
</blockquote>
<h3 id="5-2-1-函数理解"><a href="#5-2-1-函数理解" class="headerlink" title="5.2.1 函数理解"></a>5.2.1 函数理解</h3><p>linux下，man fread和fread结果</p>
<ul>
<li><code>size_t</code> fread(void <code>*ptr</code>,size_t <code>size</code>,size_t <code>nmemb</code>,File <code>*stream</code> )定义：</li>
</ul>
<blockquote>
<p>fread是一个函数，它从文件流中读数据，最多读取<code>numeb</code>个项，每个项<code>size</code>个字节，如果调用成功返回实际读取到的项个数（小于或等于<code>nmemb</code>），如果不成功或读到文件末尾返回 0。</p>
</blockquote>
<ul>
<li><code>size_t</code> fwrite(void <code>*ptr</code>, size_t <code>size</code>, size_t <code>nmemb</code>, FILE <code>*stream</code>)定义：</li>
</ul>
<blockquote>
<p>fwrite() 是 C 语言标准库中的一个文件处理函数，功能是向指定的文件中写入若干数据块，如成功执行则返回实际写入的数据块数目。该函数以二进制形式对文件进行操作，不局限于文本文件。</p>
</blockquote>
<ul>
<li><code>int</code> fseek(FILE <code>*stream</code>, long <code>offset</code>, int <code>whence</code>);</li>
</ul>
<blockquote>
<p>文件指针偏移，根据whence偏移起始位置偏移offset个字节。</p>
</blockquote>
<ul>
<li><p>fseek的函数参数列表第三个的数字含义： 偏移起始位置：</p>
<ul>
<li>文件头<code>0</code>(SEEK_SET)；</li>
<li>当前位置<code>1</code>(SEEK_CUR)；</li>
<li>文件尾<code>2</code>(SEEK_END)。</li>
</ul>
</li>
</ul>
<h3 id="5-2-2-代码解释"><a href="#5-2-2-代码解释" class="headerlink" title="5.2.2 代码解释"></a>5.2.2 代码解释</h3><p>那么我们再来看下面这段代码：</p>
<pre><code>FILE * fp;  
struct record rec;  
//... ...  
//从fp读结构体rec，每次读一个
while (fread((char *)&amp;rec, sizeof(rec), 1, fp) == 1) 
{  
    /* 对rec执行某些操作 */  
    if (/* rec 必须被重新写入 */) 
    {  
         fseek(fp, -(long)sizeof(rec), 1); 
         /*因为要重新将rec写入到fp，要对文件指针向前回溯，所以是fseek的第二项是负数，后面的1是文件指针当前位置，表明回溯起点是文件中rec的尾部*/
         fwrite((char *)&amp;rec, sizeof(rec), 1, fp);  
         /*rec写入缓冲区，等待写入。*/
         fseek(fp,0L,1);
         /*之所以要调用fseek，因为fwrite的数据只是写入到了缓冲区，而fseek函数中调用了fflush（因版本而异），这样才将缓冲区的内容输入写进fp。*/
         /*其实这个指令看似什么也做，但是其使得磁盘文件中的数据改变了，并且使文件可以正常读取了*/
    }  
}  </code></pre><p>上述代码之前应该有<code>fopen()</code>操作，这个操作是将文件数据读入缓存区，然后fread从缓存区读数据。 flush除了写入文件外，它还把将<code>file</code>中<code>_ptr</code>（文件缓存的指针）的位置重新设置到缓存的开始处了。 借用上面网址中的一幅图，可以很直观的理解文件操作和为什么要<code>fseek</code>。 <img src="http://tanwenbo.top/wp-content/uploads/2018/05/771203f53a763dd89db9de9bd235b906.png" alt=""> </p>
<h3 id="5-2-3-如果不fseek直接fread会发生什么呢？"><a href="#5-2-3-如果不fseek直接fread会发生什么呢？" class="headerlink" title="5.2.3 如果不fseek直接fread会发生什么呢？"></a>5.2.3 如果不fseek直接fread会发生什么呢？</h3><p><strong>fwrite</strong>将数据写入缓存区，<strong>fread</strong>又从文件读数据到缓存区，缓存区中有2组数据，但是fseek只将文件指针向后偏移了一组数据的偏移量，那么数据后面的就会被覆盖。 小结一下</p>
<ul>
<li>连续的fread不用调用fseek</li>
<li>使用了fwrite后应该及时调用fseek，使文件缓存真正写入磁盘文件中。</li>
</ul>
<h2 id="5-3-缓冲输出与内存分配"><a href="#5-3-缓冲输出与内存分配" class="headerlink" title="5.3 缓冲输出与内存分配"></a>5.3 缓冲输出与内存分配</h2><p>程序输出有两种方式：</p>
<ul>
<li>一种是及时处理方式；</li>
<li>另一种是先暂存起来，然后再大块写入的方式。</li>
</ul>
<p>前者往往造成较高的系统负担。因此，C语言实现通常都允许程序员进行实际的写操作之前控制产生的输出数据量。</p>
<h3 id="5-3-1-使用setbuf库函数"><a href="#5-3-1-使用setbuf库函数" class="headerlink" title="5.3.1 使用setbuf库函数"></a>5.3.1 使用setbuf库函数</h3><p>setbuf(stdout,buf);</p>
<p>语句将通知输入/输出库，所有写入到stdout的输出都应该使用buf作为输出缓冲区，知道buf缓冲区被填满或者程序员直接调用fflush（调用之后缓冲区的内容才被实际的写入该文件）。 如果直接在main函数里声明缓冲数组会出错，因为main函数结束后<code>缓冲数组</code>会被释放。解决的方法就是</p>
<ul>
<li><p>声明静态函数</p>
<p>static char buf[BUFSIZ];</p>
</li>
</ul>
<ul>
<li><p>动态分配缓冲区</p>
<p>char *malloc();<br>setbuf(stdout, malloc(BUFSIZ)); </p>
</li>
</ul>
<h2 id="5-4-使用errno"><a href="#5-4-使用errno" class="headerlink" title="5.4 使用errno"></a>5.4 使用errno</h2><p>很多库函数，特别是那些与操作系统有关的，当执行失败时会通过一个名称为<code>errno</code>的外部变量，通知程序该函数调用失败。</p>
<blockquote>
<p>errno 是记录系统的最后一次错误代码。代码是一个int型的值，在errno.h中定义。查看错误代码errno是调试程序的一个重要方法。当linux C api函数发生异常时,一般会将errno变量(需include errno.h)赋一个整数值,不同的值表示不同的含义,可以通过查看该值推测出错的原因。在实际编程中用这一招解决了不少原本看来莫名其妙的问题。</p>
</blockquote>
<p>在调用库函数时，我们应该首先检测作为错误提示的返回值，确定程序执行已经失败。然后，再检查errno，来搞清楚出错原因：</p>
<pre><code>//调用库函数
if(返回的错误值)
        检查errno </code></pre><h2 id="5-5-库函数signal"><a href="#5-5-库函数signal" class="headerlink" title="5.5 库函数signal"></a>5.5 库函数signal</h2><p>信号函数，作为捕获异步事件的一种方式。</p>
<pre><code>#include&lt;signal.h&gt;
signal(signal type, handler function);</code></pre><p>signal type代表信号中的某些常量，比如（<code>SIGINT</code>）。<code>liunx</code>有<code>64</code>种信号，其中<code>32</code>种是不可靠信号，另外<code>32</code>种是可靠信号。 从安全角度出发，signal不应该调用系统的<code>库函数</code>，也就是<code>function</code>不应该是<code>库函数</code>，应该是自己定义的函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/24/four-link/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/24/four-link/" class="post-title-link" itemprop="url">第四章 连接</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-24 12:05:28" itemprop="dateCreated datePublished" datetime="2018-04-24T12:05:28+08:00">2018-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="http://maxiang.io/#/?provider=evernote&guid=558692fd-8021-498e-a42c-9f3d939845dd&notebook=%E3%80%8AC%E9%99%B7%E9%98%B1%E4%B8%8E%E7%BC%BA%E9%99%B7%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0" target="_blank" rel="noopener">Edit</a></p>
<h1 id="第四章-连接"><a href="#第四章-连接" class="headerlink" title="第四章 连接"></a>第四章 连接</h1><p>《C陷阱与缺陷》学习笔记 形参 实参 static posts</p>
<ul>
<li><a href="#第四章-连接">第四章 连接</a></li>
</ul>
<ul>
<li><p><a href="#41-什么是连接器">4.1 什么是连接器</a></p>
</li>
<li><p><a href="#42-声明和定义">4.2 声明和定义</a></p>
</li>
<li><p><a href="#43-命名冲突与static修饰符">4.3 命名冲突与static修饰符</a></p>
</li>
</ul>
<ul>
<li><p><a href="#431-变量">4.3.1 变量</a></p>
</li>
<li><p><a href="#432-函数">4.3.2 函数</a></p>
</li>
</ul>
<ul>
<li><a href="#44-形参实参与返回值">4.4 形参、实参与返回值</a></li>
</ul>
<ul>
<li><p><a href="#441-形参实参的区别">4.4.1 形参实参的区别</a></p>
</li>
<li><p><a href="#442-强制转换">4.4.2 强制转换</a></p>
</li>
<li><p><a href="#443-返回值">4.4.3 返回值</a></p>
</li>
</ul>
<ul>
<li><a href="#45-检查外部类型">4.5 检查外部类型</a></li>
</ul>
<ul>
<li><p><a href="#原内存布局">原内存布局</a></p>
</li>
<li><p><a href="#现内存布局">现内存布局</a></p>
</li>
</ul>
<ul>
<li><p><a href="#46-头文件">4.6 头文件</a></p>
</li>
<li><p><a href="#总结">总结</a></p>
</li>
</ul>
<h2 id="4-1-什么是连接器"><a href="#4-1-什么是连接器" class="headerlink" title="4.1 什么是连接器"></a>4.1 什么是连接器</h2><blockquote>
<p>在C语言中，一个重要的思想就是分别编译，即若干个源程序可以在不同的时候单独进行编译，然后在恰当的时候整合到一起。但是连接器一般是与C编译器分离的，连接器如何做到把若干个C源程序合并成一个整体呢？</p>
<p>典型的连接器把由编译器或汇编器生成的若干个目标模块，整合成一个被称为载入模块或可执行文件的实体，该实体能够被操作系统直接执行。其中，某些目标模块是直接作为输入提供给连接器的；而另外一些目标模块则是根据连接过程的需要，从包括有类似printf函数的库文件中取得的。</p>
</blockquote>
<p>简而言之，连接器就是用来连接各个编译好的模块，然后将其组成一个模块或者可执行文件。且会检查外部对象是否有重复，重复则报错。因为大多数连接器都进制同一个载入模块中的两个不同对象拥有相同的名称。</p>
<h2 id="4-2-声明和定义"><a href="#4-2-声明和定义" class="headerlink" title="4.2 声明和定义"></a>4.2 声明和定义</h2><p>声明在函数体之外的变量是全局变量，也称为外部对象。</p>
<p>1.int a; //声明</p>
<p>2.a = 1; //定义</p>
<p>3.int b = 1; //声明并定义</p>
<p>如果使用了extern关键字，则代表该变量是其他地方分配的。</p>
<p>1.extern int a;</p>
<h2 id="4-3-命名冲突与static修饰符"><a href="#4-3-命名冲突与static修饰符" class="headerlink" title="4.3 命名冲突与static修饰符"></a>4.3 命名冲突与static修饰符</h2><h3 id="4-3-1-变量"><a href="#4-3-1-变量" class="headerlink" title="4.3.1 变量"></a>4.3.1 变量</h3><p>static修饰的变量只会初始化一次，其值固定在内存空间直至销毁，所以如果再次对其进行赋值是无效的。</p>
<p>static变量可以重名，不会发生冲突</p>
<p>1.static int a;</p>
<p>2.int a;</p>
<h3 id="4-3-2-函数"><a href="#4-3-2-函数" class="headerlink" title="4.3.2 函数"></a>4.3.2 函数</h3><p>static声明的函数可以在外部使用，一般称其为静态函数。</p>
<p>1.static int g(int x)</p>
<p>2.{</p>
<p>3…..</p>
<p>4.}</p>
<p>5.</p>
<p>6.void f()</p>
<p>7.{</p>
<ol start="8">
<li>b = g(a);</li>
</ol>
<p>9.}</p>
<h2 id="4-4-形参、实参与返回值"><a href="#4-4-形参、实参与返回值" class="headerlink" title="4.4 形参、实参与返回值"></a>4.4 形参、实参与返回值</h2><h3 id="4-4-1-形参实参的区别"><a href="#4-4-1-形参实参的区别" class="headerlink" title="4.4.1 形参实参的区别"></a>4.4.1 形参实参的区别</h3><p>老生常谈了，用段代码来解释下形参和实参。</p>
<p>1.#include&lt;stdio.h&gt;</p>
<p>2.void swap(int a,int b)</p>
<p>3.{</p>
<ol start="4">
<li>int c = a;</li>
</ol>
<p>5.#include&lt;stdio.h&gt;</p>
<p>6.void swap(int a,int b) //传的形参</p>
<p>7.{</p>
<ol start="8">
<li><p>int c = a;</p>
</li>
<li><p>a = b;</p>
</li>
<li><p>b = c;</p>
</li>
</ol>
<p>11.}</p>
<p>12.void swap1(int *a,int *b) //传实参</p>
<p>13.{</p>
<p>14.</p>
<ol start="15">
<li><p>int c = *a;</p>
</li>
<li><p>*a = *b;</p>
</li>
<li><p>*b = c;</p>
</li>
</ol>
<p>18.}</p>
<p>19.int main()</p>
<p>20.{</p>
<ol start="21">
<li><p>int a = 1,b = 2;</p>
</li>
<li><p>swap(a,b); //没有交换</p>
</li>
<li><p>printf(“%d %d\n”,a ,b);</p>
</li>
<li><p>swap1(&amp;a,&amp;b); //交换了</p>
</li>
<li><p>printf(“%d %d\n”,a , b);</p>
</li>
<li><p>return 0 ;</p>
</li>
</ol>
<p>27.}</p>
<h3 id="4-4-2-强制转换"><a href="#4-4-2-强制转换" class="headerlink" title="4.4.2 强制转换"></a>4.4.2 强制转换</h3><p>当函数指定了参数类型，会进行强制转换，比如：</p>
<p>1.double square(double);</p>
<p>2.square(2); //合法，会自动转换为双精度类型</p>
<h3 id="4-4-3-返回值"><a href="#4-4-3-返回值" class="headerlink" title="4.4.3 返回值"></a>4.4.3 返回值</h3><p>函数除了构造函数和析构函数之外，都要声明返回值，void或者其他类型。</p>
<h2 id="4-5-检查外部类型"><a href="#4-5-检查外部类型" class="headerlink" title="4.5 检查外部类型"></a>4.5 检查外部类型</h2><p>在引用外部变量的时候要注意最好是类型一样，比如：</p>
<p>1.char filename[] = “/etc/passwd”;</p>
<p>2.</p>
<p>3.extern char* filename; //外部引用</p>
<p>虽然指针与数组好像是一样的，但是filename的类型是“字符数组”，而不是“字符指针”。在第二个声明中，filename被确定为一个指针。这两个对filename的声明使用存储空间的方式是不同的。</p>
<h4 id="原内存布局"><a href="#原内存布局" class="headerlink" title="原内存布局"></a>原内存布局</h4><p><img src="https://tanwenbo.top/wp-content/uploads/2018/06/e98054d288ab979ab00d1b0319cfc674.png" alt=""></p>
<h4 id="现内存布局"><a href="#现内存布局" class="headerlink" title="现内存布局"></a>现内存布局</h4><p><img src="https://tanwenbo.top/wp-content/uploads/2018/06/b8923f18c4555c4870fdfd935f6c55e7.png" alt=""></p>
<p>应该改为同样类型：</p>
<p>1.char filename[] = “/etc”;</p>
<p>2.extern char filename[];</p>
<p>3.</p>
<p>4.char* filename= “/etc”;</p>
<p>5.extern char* filename;</p>
<h2 id="4-6-头文件"><a href="#4-6-头文件" class="headerlink" title="4.6 头文件"></a>4.6 头文件</h2><p>每个外部对象应只在一个头文件中声明，需要用到该外部对象的所有模块都应该包括这个头文件。定义该外部对象的模块也应该包括这个头文件。比如：</p>
<p>public.h</p>
<p>1.int a = 1;</p>
<p>2.char* str = “123”;</p>
<p>main.c</p>
<p>1.#include &lt;stdio.h&gt;</p>
<p>2.#include “public.h”</p>
<p>3.extern int a;</p>
<p>4.extern char* str;</p>
<p>5.int main()</p>
<p>6.{</p>
<ol start="7">
<li><p>printf(“%d\n”,a);</p>
</li>
<li><p>return 0;</p>
</li>
</ol>
<p>9.}</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C语言的连接是一个很强大的东西，将小的模块组成大的模块，文件和变量之间能很好的进行交互，从而达到高内聚低耦合的效果。</p>
<p>%23%u7B2C%u56DB%u7AE0%20%u8FDE%u63A5%0A@%28%u300AC%u9677%u9631%u4E0E%u7F3A%u9677%u300B%u5B66%u4E60%u7B14%u8BB0%29%5B%u5F62%u53C2%7C%u5B9E%u53C2%7Cstatic%7Cposts%5D%0A%0A%5BTOC%5D%0A%0A%23%23%204.1%20%u4EC0%u4E48%u662F%u8FDE%u63A5%u5668%0A%3E%20%u5728C%u8BED%u8A00%u4E2D%uFF0C%u4E00%u4E2A%u91CD%u8981%u7684%u601D%u60F3%u5C31%u662F%u5206%u522B%u7F16%u8BD1%uFF0C%u5373%u82E5%u5E72%u4E2A%u6E90%u7A0B%u5E8F%u53EF%u4EE5%u5728%u4E0D%u540C%u7684%u65F6%u5019%u5355%u72EC%u8FDB%u884C%u7F16%u8BD1%uFF0C%u7136%u540E%u5728%u6070%u5F53%u7684%u65F6%u5019%u6574%u5408%u5230%u4E00%u8D77%u3002%u4F46%u662F%u8FDE%u63A5%u5668%u4E00%u822C%u662F%u4E0EC%u7F16%u8BD1%u5668%u5206%u79BB%u7684%uFF0C%u8FDE%u63A5%u5668%u5982%u4F55%u505A%u5230%u628A%u82E5%u5E72%u4E2AC%u6E90%u7A0B%u5E8F%u5408%u5E76%u6210%u4E00%u4E2A%u6574%u4F53%u5462%uFF1F%0A%3E%20%u5178%u578B%u7684%u8FDE%u63A5%u5668%u628A%u7531%u7F16%u8BD1%u5668%u6216%u6C47%u7F16%u5668%u751F%u6210%u7684%u82E5%u5E72%u4E2A%u76EE%u6807%u6A21%u5757%uFF0C%u6574%u5408%u6210%u4E00%u4E2A%u88AB%u79F0%u4E3A%u8F7D%u5165%u6A21%u5757%u6216%u53EF%u6267%u884C%u6587%u4EF6%u7684%u5B9E%u4F53%uFF0C%u8BE5%u5B9E%u4F53%u80FD%u591F%u88AB%u64CD%u4F5C%u7CFB%u7EDF%u76F4%u63A5%u6267%u884C%u3002%u5176%u4E2D%uFF0C%u67D0%u4E9B%u76EE%u6807%u6A21%u5757%u662F%u76F4%u63A5%u4F5C%u4E3A%u8F93%u5165%u63D0%u4F9B%u7ED9%u8FDE%u63A5%u5668%u7684%uFF1B%u800C%u53E6%u5916%u4E00%u4E9B%u76EE%u6807%u6A21%u5757%u5219%u662F%u6839%u636E%u8FDE%u63A5%u8FC7%u7A0B%u7684%u9700%u8981%uFF0C%u4ECE%u5305%u62EC%u6709%u7C7B%u4F3Cprintf%u51FD%u6570%u7684%u5E93%u6587%u4EF6%u4E2D%u53D6%u5F97%u7684%u3002%0A%0A%u7B80%u800C%u8A00%u4E4B%uFF0C%u8FDE%u63A5%u5668%u5C31%u662F%u7528%u6765%u8FDE%u63A5%u5404%u4E2A%u7F16%u8BD1%u597D%u7684%u6A21%u5757%uFF0C%u7136%u540E%u5C06%u5176%u7EC4%u6210%u4E00%u4E2A%u6A21%u5757%u6216%u8005%u53EF%u6267%u884C%u6587%u4EF6%u3002%u4E14%u4F1A%u68C0%u67E5%u5916%u90E8%u5BF9%u8C61%u662F%u5426%u6709%u91CD%u590D%uFF0C%u91CD%u590D%u5219%u62A5%u9519%u3002%u56E0%u4E3A<strong>%u5927%u591A%u6570%u8FDE%u63A5%u5668%u90FD%u8FDB%u5236%u540C%u4E00%u4E2A%u8F7D%u5165%u6A21%u5757%u4E2D%u7684%u4E24%u4E2A%u4E0D%u540C%u5BF9%u8C61%u62E5%u6709%u76F8%u540C%u7684%u540D%u79F0</strong>%u3002%0A%0A%23%23%204.2%20%u58F0%u660E%u548C%u5B9A%u4E49%0A%u58F0%u660E%u5728%u51FD%u6570%u4F53%u4E4B%u5916%u7684%u53D8%u91CF%u662F<strong>%u5168%u5C40%u53D8%u91CF</strong>%uFF0C%u4E5F%u79F0%u4E3A<strong>%u5916%u90E8%u5BF9%u8C61</strong>%u3002%0A%60%60%60c%0Aint%20a%3B%09%09%09%09//%u58F0%u660E%0Aa%20%3D%201%3B%09%09%09%09//%u5B9A%u4E49%0Aint%20b%20%3D%201%3B%09%09%09//%u58F0%u660E%u5E76%u5B9A%u4E49%0A%60%60%60%0A%u5982%u679C%u4F7F%u7528%u4E86extern%u5173%u952E%u5B57%uFF0C%u5219%u4EE3%u8868%u8BE5%u53D8%u91CF%u662F%u5176%u4ED6%u5730%u65B9%u5206%u914D%u7684%u3002%0A%60%60%60c%0Aextern%20int%20a%3B%0A%60%60%60%0A%0A%23%23%204.3%20%u547D%u540D%u51B2%u7A81%u4E0Estatic%u4FEE%u9970%u7B26%0A%23%23%23%204.3.1%20%u53D8%u91CF%0Astatic%u4FEE%u9970%u7684%u53D8%u91CF%u53EA%u4F1A%60%60%u521D%u59CB%u5316%u4E00%u6B21%60%60%uFF0C%u5176%u503C%u56FA%u5B9A%u5728%u5185%u5B58%u7A7A%u95F4%u76F4%u81F3%u9500%u6BC1%uFF0C<strong>%u6240%u4EE5%u5982%u679C%u518D%u6B21%u5BF9%u5176%u8FDB%u884C%u8D4B%u503C%u662F%u65E0%u6548%u7684%u3002</strong>%0A%0Astatic%u53D8%u91CF%u53EF%u4EE5%60%u91CD%u540D%60%uFF0C%u4E0D%u4F1A%u53D1%u751F%u51B2%u7A81%0A%60%60%60c%20%0Astatic%20int%20a%3B%0Aint%20a%3B%0A%60%60%60%0A%0A%23%23%23%204.3.2%20%u51FD%u6570%0Astatic%u58F0%u660E%u7684%u51FD%u6570%u53EF%u4EE5%u5728%u5916%u90E8%u4F7F%u7528%uFF0C%u4E00%u822C%u79F0%u5176%u4E3A%60%u9759%u6001%u51FD%u6570%60%u3002%0A%60%60%60c%0Astatic%20int%20g%28int%20x%29%0A%7B%0A….%0A%7D%20%0A%0Avoid%20f%28%29%0A%7B%0A%09b%20%3D%20g%28a%29%3B%0A%7D%0A%60%60%60%0A%0A%23%23%204.4%20%u5F62%u53C2%u3001%u5B9E%u53C2%u4E0E%u8FD4%u56DE%u503C%0A%23%23%23%204.4.1%20%u5F62%u53C2%u5B9E%u53C2%u7684%u533A%u522B%0A%u8001%u751F%u5E38%u8C08%u4E86%uFF0C%u7528%u6BB5%u4EE3%u7801%u6765%u89E3%u91CA%u4E0B%60%u5F62%u53C2%60%u548C%60%u5B9E%u53C2%60%u3002%0A%60%60%60C%0A%23include%3Cstdio.h%3E%0Avoid%20swap%28int%20a%2Cint%20b%29%0A%7B%0A%20%20%20%20int%20c%20%3D%20a%3B%0A%23include%3Cstdio.h%3E%0Avoid%20swap%28int%20a%2Cint%20b%29%09%09//%u4F20%u7684%u5F62%u53C2%0A%7B%20%20%20%0A%20%20%20%20int%20c%20%3D%20a%3B%0A%20%20%20%20a%20%3D%20b%3B%0A%20%20%20%20b%20%3D%20c%3B%0A%7D%0Avoid%20swap1%28int%20*a%2Cint%20*b%29%20%09//%u4F20%u5B9E%u53C2%0A%7B%0A%0A%20%20%20%20int%20c%20%3D%20*a%3B%20%0A%20%20%20%20*a%20%3D%20*b%3B%20%0A%20%20%20%20*b%20%3D%20c%3B%0A%7D%0Aint%20main%28%29%0A%7B%0A%20%20%20%20int%20a%20%3D%201%2Cb%20%3D%202%3B%0A%20%20%20%20swap%28a%2Cb%29%3B%20%20%20//%u6CA1%u6709%u4EA4%u6362%0A%20%20%20%20printf%28%22%25d%20%25d%5Cn%22%2Ca%20%2Cb%29%3B%20%20%20%20%0A%20%20%20%20swap1%28%26a%2C%26b%29%3B%20%20%20//%u4EA4%u6362%u4E86%0A%20%20%20%20printf%28%22%25d%20%25d%5Cn%22%2Ca%20%2C%20b%29%3B%0A%20%20%20%20return%200%20%3B%0A%7D%0A%60%60%60%0A%23%23%23%204.4.2%20%u5F3A%u5236%u8F6C%u6362%0A%u5F53%u51FD%u6570%u6307%u5B9A%u4E86%u53C2%u6570%u7C7B%u578B%uFF0C%u4F1A%u8FDB%u884C%60%u5F3A%u5236%u8F6C%u6362%60%uFF0C%u6BD4%u5982%uFF1A%0A%60%60%60C%0Adouble%20square%28double%29%3B%0Asquare%282%29%3B%20%09%09%09//%u5408%u6CD5%uFF0C%u4F1A%u81EA%u52A8%u8F6C%u6362%u4E3A%u53CC%u7CBE%u5EA6%u7C7B%u578B%0A%60%60%60%0A%23%23%23%204.4.3%20%u8FD4%u56DE%u503C%0A%u51FD%u6570%u9664%u4E86%60%u6784%u9020%u51FD%u6570%60%u548C%60%u6790%u6784%u51FD%u6570%60%u4E4B%u5916%uFF0C%u90FD%u8981%u58F0%u660E%u8FD4%u56DE%u503C%uFF0Cvoid%u6216%u8005%u5176%u4ED6%u7C7B%u578B%u3002%0A%0A%23%23%204.5%20%u68C0%u67E5%u5916%u90E8%u7C7B%u578B%0A%u5728%u5F15%u7528%60%u5916%u90E8%u53D8%u91CF%60%u7684%u65F6%u5019%u8981%u6CE8%u610F%u6700%u597D%u662F%u7C7B%u578B%u4E00%u6837%uFF0C%u6BD4%u5982%uFF1A%0A%60%60%60c%0Achar%20filename%5B%5D%20%3D%20%22/etc/passwd%22%3B%0A%0Aextern%20char<em>%20filename%3B%09//%u5916%u90E8%u5F15%u7528%0A%60%60%60%0A%u867D%u7136%u6307%u9488%u4E0E%u6570%u7EC4%u597D%u50CF%u662F%u4E00%u6837%u7684%uFF0C%u4F46%u662F%60filename%60%u7684%u7C7B%u578B%u662F%u201C%60%u5B57%u7B26%u6570%u7EC4%60%u201D%uFF0C%u800C%u4E0D%u662F%60%u201C%u5B57%u7B26%u6307%u9488%u201D%60%u3002%u5728%u7B2C%u4E8C%u4E2A%u58F0%u660E%u4E2D%uFF0C%60filename%60%u88AB%u786E%u5B9A%u4E3A%u4E00%u4E2A%60%u6307%u9488%60%u3002%u8FD9%u4E24%u4E2A%u5BF9%60filename%60%u7684%u58F0%u660E%u4F7F%u7528%u5B58%u50A8%u7A7A%u95F4%u7684%u65B9%u5F0F%u662F%u4E0D%u540C%u7684%u3002%0A%0A%23%23%23%23%20%u539F%u5185%u5B58%u5E03%u5C40%0A%21%5BAlt%20text%5D%28./1524645704928.png%29%0A%23%23%23%23%20%u73B0%u5185%u5B58%u5E03%u5C40%0A%21%5BAlt%20text%5D%28./1524645774249.png%29%0A%0A%u5E94%u8BE5%u6539%u4E3A%u540C%u6837%u7C7B%u578B%uFF1A%0A%60%60%60C%0Achar%20filename%5B%5D%20%3D%20%22/etc%22%3B%0Aextern%20char%20filename%5B%5D%3B%0A%0Achar</em>%20filename%3D%20%22/etc%22%3B%0Aextern%20char<em>%20filename%3B%0A%60%60%60%0A%0A%23%23%204.6%20%u5934%u6587%u4EF6%0A%u6BCF%u4E2A%u5916%u90E8%u5BF9%u8C61%u5E94%u53EA%u5728%u4E00%u4E2A%60%u5934%u6587%u4EF6%60%u4E2D%u58F0%u660E%uFF0C%u9700%u8981%u7528%u5230%u8BE5%u5916%u90E8%u5BF9%u8C61%u7684%60%u6240%u6709%u6A21%u5757%60%u90FD%u5E94%u8BE5%u5305%u62EC%u8FD9%u4E2A%60%u5934%u6587%u4EF6%60%u3002%u5B9A%u4E49%u8BE5%u5916%u90E8%u5BF9%u8C61%u7684%u6A21%u5757%u4E5F%u5E94%u8BE5%u5305%u62EC%u8FD9%u4E2A%60%u5934%u6587%u4EF6%60%u3002%u6BD4%u5982%uFF1A%0A%0A**public.h*\</em>%0A%60%60%60c%0Aint%20a%20%3D%201%3B%0Achar<em>%20str%20%3D%20%22123%22%3B%0A%60%60%60%0A**main.c*\</em>%0A%60%60%60c%0A%23include%20%3Cstdio.h%3E%0A%23include%20%22public.h%22%0Aextern%20int%20a%3B%0Aextern%20char<em>%20str%3B%0Aint%20main%28%29%0A%7B%0A%09printf%28%22%25d%5Cn%22%2Ca%29%3B%0A%09return%200%3B%0A%7D%0A%60%60%60%0A%23%23%20%u603B%u7ED3%0AC%u8BED%u8A00%u7684%u8FDE%u63A5%u662F%u4E00%u4E2A%u5F88%u5F3A%u5927%u7684%u4E1C%u897F%uFF0C%u5C06%u5C0F%u7684%u6A21%u5757%u7EC4%u6210%u5927%u7684%u6A21%u5757%uFF0C%u6587%u4EF6%u548C%u53D8%u91CF%u4E4B%u95F4%u80FD%u5F88%u597D%u7684%u8FDB%u884C%u4EA4%u4E92%uFF0C%u4ECE%u800C%u8FBE%u5230*</em>%u9AD8%u5185%u805A%u4F4E%u8026%u5408**%u7684%u6548%u679C%u3002%0A%0A</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/24/3-e8-af-ad-e4-b9-89-e9-99-b7-e9-98-b1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/24/3-e8-af-ad-e4-b9-89-e9-99-b7-e9-98-b1/" class="post-title-link" itemprop="url">第三章 语义“陷阱”</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-24 03:19:47" itemprop="dateCreated datePublished" datetime="2018-04-24T03:19:47+08:00">2018-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第三章-语义“陷阱”"><a href="#第三章-语义“陷阱”" class="headerlink" title="第三章 语义“陷阱”"></a>第三章 语义“陷阱”</h1><p><code>《C陷阱与缺陷》学习笔记``指针``数组``posts</code></p>
<ul>
<li><a href="#第三章-语义陷阱">第三章 语义“陷阱”</a><ul>
<li><a href="#31-指针与数组">3.1 指针与数组</a><ul>
<li><a href="#311-数组名的使用">3.1.1 数组名的使用</a></li>
<li><a href="#312-指针的使用">3.1.2 指针的使用</a></li>
<li><a href="#313-二维数组">3.1.3 二维数组</a></li>
<li><a href="#314-二维数组名的使用">3.1.4 二维数组名的使用</a></li>
</ul>
</li>
<li><a href="#32-非数组的指针">3.2 非数组的指针</a></li>
<li><a href="#33-作为参数的数组声明">3.3 作为参数的数组声明</a></li>
<li><a href="#34-避免举隅法">3.4 避免“举隅法”</a><ul>
<li><a href="#341-指针复制问题">3.4.1 指针复制问题</a></li>
</ul>
</li>
<li><a href="#35-空指针并非空字符串">3.5 空指针并非空字符串</a></li>
<li><a href="#36-边界计算与不对称边界">3.6 边界计算与不对称边界</a><ul>
<li><a href="#361-规定编码风格">3.6.1 规定编码风格</a></li>
</ul>
</li>
<li><a href="#37-求值顺序">3.7 求值顺序</a></li>
<li><a href="#38-运算符和">3.8 运算符&amp;&amp;、||和!</a></li>
<li><a href="#39-整数溢出">3.9 整数溢出</a></li>
<li><a href="#310-main函数的返回值">3.10 main函数的返回值</a></li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
</ul>
<h2 id="3-1-指针与数组"><a href="#3-1-指针与数组" class="headerlink" title="3.1 指针与数组"></a>3.1 指针与数组</h2><p>数组其实就是由指针实现的，任何数组下标运算都等同于一个对应的指针运算。</p>
<pre><code>1.int *ip;
2.int i; 
3.ip = &amp;i; //地址赋值，使ip指向了整型变量i
4.*ip = 17; //通过指针修改i的值， </code></pre><h3 id="3-1-1-数组名的使用"><a href="#3-1-1-数组名的使用" class="headerlink" title="3.1.1 数组名的使用"></a>3.1.1 数组名的使用</h3><p>如果直接使用数组名（一维数组），那么数组名就当作指向该数组下标为0的元素的指针。</p>
<pre><code>1.int a[10];
2.int *p;
3.p = a; //p指向了a数组的首地址
4.int num = *p; //*p就是a[0]的值 </code></pre><h3 id="3-1-2-指针的使用"><a href="#3-1-2-指针的使用" class="headerlink" title="3.1.2 指针的使用"></a>3.1.2 指针的使用</h3><p>指针有时候也可以当成数组使用，二者意思相等。</p>
<pre><code>1.int a[10];
2.int *p;
3.p = a + 2; //p指向了a[2]
4.p++; //p指向了a[3]
5. </code></pre><h3 id="3-1-3-二维数组"><a href="#3-1-3-二维数组" class="headerlink" title="3.1.3 二维数组"></a>3.1.3 二维数组</h3><pre><code>1.int calendar[12][31];
2.int *p;
3.int i;
4.p = calendar[4]; //p指向了calender[4]中下标为0的元素
5.//下面三个式子意思一样
6.i = calendar[4][7];
7.i = *(calendar[4] + 7);
8.i = *(*calendar+4) + 7);</code></pre><p>记住解引用的用法，和数组[]符号意思一样。</p>
<h3 id="3-1-4-二维数组名的使用"><a href="#3-1-4-二维数组名的使用" class="headerlink" title="3.1.4 二维数组名的使用"></a>3.1.4 二维数组名的使用</h3><p>一维数组可以直接使用数组名，但是二维数组不行。比如：</p>
<pre><code>1.int calendar[12][31];
2.int *p;
3.p = calendar; //非法，因为p是指向整型变量的指针，calender是指向数组的指针，类型不同</code></pre><p>需要声明一种指向数组的指针的方法，需要类型相同</p>
<pre><code>1.int calendar[12][31];
2.int (*monthp)[31];
3.monthp = calendar; </code></pre><h2 id="3-2-非数组的指针"><a href="#3-2-非数组的指针" class="headerlink" title="3.2 非数组的指针"></a>3.2 非数组的指针</h2><p><strong>任何指针都需要初始化，否则会成为野指针</strong></p>
<blockquote>
<p>野指针指向一个已删除的对象或未申请访问受限内存区域的指针。与空指针不同，野指针无法通过简单地判断是否为 NULL避免，而只能通过养成良好的编程习惯来尽力减少。对野指针进行操作很容易造成程序错误。</p>
</blockquote>
<p>简单归纳如下：</p>
<ul>
<li><p>指针需要初始化，指向NULL或者一块内存区域;</p>
</li>
<li><p>分配的内存使用完后要及时释放;</p>
</li>
<li><p>malloc分配内存的时候应在字符长度的基础上+1，用来存放结束标志。</p>
<p>1.char *r;<br>2.r = malloc(strlen(s) + 1); </p>
</li>
</ul>
<h2 id="3-3-作为参数的数组声明"><a href="#3-3-作为参数的数组声明" class="headerlink" title="3.3 作为参数的数组声明"></a>3.3 作为参数的数组声明</h2><p>将数组作为参数传到函数里，C语言会自动的将作为参数的数组声明转换成相应的指针声明，所以在传数组的时候只需要写数组名，不需要写大小。</p>
<pre><code>1.int strlen(char s[]) 等于 int strlen(char *s) //都是将首地址传了进去 </code></pre><h2 id="3-4-避免“举隅法”"><a href="#3-4-避免“举隅法”" class="headerlink" title="3.4 避免“举隅法”"></a>3.4 避免“举隅法”</h2><p><strong>简单来说就是不要以<code>整体</code>代表<code>部分</code>，或者以<code>部分</code>代表<code>整体</code></strong></p>
<pre><code>1.char *p, *q;
2.p = &quot;xyz&quot;;</code></pre><p>之前可能以为p的值就是字符串<code>“xyz”</code>，其实不然，p是一个指向由<code>&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;\0&#39;</code>，4个字符组成的数组的起始元素的指针。</p>
<h3 id="3-4-1-指针复制问题"><a href="#3-4-1-指针复制问题" class="headerlink" title="3.4.1 指针复制问题"></a>3.4.1 指针复制问题</h3><p>如果直接执行</p>
<pre><code>1.q = p;</code></pre><p>程序并没有想象中的那样所有值都复制了过来，而是都指向同一地址。</p>
<p><strong>需要记住，复制指针并不同时复制指针指向的数据</strong> 而且如果通过<code>q</code>来修改指针内容，那么<code>p</code>的内容也变了</p>
<pre><code>1.q[1] = &apos;Y&apos;;</code></pre><p>这个时候内存变为<code>&quot;xYz&quot;</code>,p[1]也是<code>&#39;Y&#39;</code>。</p>
<h2 id="3-5-空指针并非空字符串"><a href="#3-5-空指针并非空字符串" class="headerlink" title="3.5 空指针并非空字符串"></a>3.5 空指针并非空字符串</h2><p>在C语言中，<code>NULL</code>和<code>0</code>的值都是一样的，但是为了目的和用途以及容易识别的原因，<strong><code>NULL</code>用于指针和对象，<code>0</code>用于数值对与字符串的结尾，使用’\0’</strong> 在不同的系统中，<code>NULL</code>并非总是和<code>0</code>等同，<strong><code>NULL</code>仅仅代表空值，也就是指向一个不被使用的地址</strong></p>
<h2 id="3-6-边界计算与不对称边界"><a href="#3-6-边界计算与不对称边界" class="headerlink" title="3.6 边界计算与不对称边界"></a>3.6 边界计算与不对称边界</h2><p>C语言里边界问题是一个很容易出错的地方，比如：满足边界X&gt;=16且X&lt;=37的整数有多少个？ 按常规思考，会计算出37-16 = 21个数，但是其实是22个。</p>
<h3 id="3-6-1-规定编码风格"><a href="#3-6-1-规定编码风格" class="headerlink" title="3.6.1 规定编码风格"></a>3.6.1 规定编码风格</h3><p><strong><code>入界点</code></strong>在取值范围里，<strong><code>出界点</code></strong>不在取值范围里。这样的操作带来的效果是惊人的：</p>
<ul>
<li><strong>取值范围的大小就是上界与下界之差；</strong>。</li>
<li><strong>如果取值范围为空，那么上界等于下界；</strong></li>
<li><strong>即使取值范围为空，上界也永远不可能小于下界。</strong></li>
</ul>
<h2 id="3-7-求值顺序"><a href="#3-7-求值顺序" class="headerlink" title="3.7 求值顺序"></a>3.7 求值顺序</h2><p>在使用if语句的时候可能会用到多个条件判断，C语言中判断的顺序是从左至右，比如:</p>
<pre><code>1.if(a &gt; b &amp;&amp; a &gt; c) //如果a &gt; b成立才会判断a &gt; c，不会先判断a &gt; c
2.max = a; </code></pre><h2 id="3-8-运算符-amp-amp-、-和"><a href="#3-8-运算符-amp-amp-、-和" class="headerlink" title="3.8 运算符&amp;&amp;、||和!"></a>3.8 运算符&amp;&amp;、||和!</h2><p>这些都是逻辑运算符，用来判断语句的正确性，可以相互组合起来。但是有时候会<code>少写</code>一个，编译器也不会报错，需要十分小心。</p>
<h2 id="3-9-整数溢出"><a href="#3-9-整数溢出" class="headerlink" title="3.9 整数溢出"></a>3.9 整数溢出</h2><p>C语言里有两类整数算术运算</p>
<ul>
<li><code>无符号运算</code></li>
<li><code>有符号运算</code></li>
</ul>
<p>在无符号算术中，没有“溢出”的说法。</p>
<h2 id="3-10-main函数的返回值"><a href="#3-10-main函数的返回值" class="headerlink" title="3.10 main函数的返回值"></a>3.10 main函数的返回值</h2><p>main函数会有返回值，就想我们平时写程序一样：</p>
<pre><code>1.int main()
2.{
3.        ...
4.        return 0;
5.}</code></pre><p>返回值为<code>0</code>代表程序执行成功，返回值<code>非0</code>则表示程序执行失败！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>数组就是由指针实现的，在进行一些数组操作的时候可以当成指针来使用。同理，在对指针进行操作的时候也可以将其当成数组来操作；</li>
<li>函数传指针或者数组，只需要传首地址即可；</li>
<li>数组不要越界，在遍历的时候遵循<strong><code>“满下界，空上界”</code></strong>原则。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/21/e8-af-ad-e6-b3-95-e9-87-8c-e5-b8-b8-e8-a7-81-e7-9a-84-e9-94-99-e8-af-af/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/21/e8-af-ad-e6-b3-95-e9-87-8c-e5-b8-b8-e8-a7-81-e7-9a-84-e9-94-99-e8-af-af/" class="post-title-link" itemprop="url">语法里常见的错误</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-21 03:07:32" itemprop="dateCreated datePublished" datetime="2018-04-21T03:07:32+08:00">2018-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-语句结束符的分号"><a href="#1-语句结束符的分号" class="headerlink" title="1 语句结束符的分号"></a>1 语句结束符的分号</h3><p>如果在写代码的时候少写了分号或者多加了分号，这样的错误带来的后果是很严重的。有时候编译器可能都不会对其进行报错，这样导致你寻找错误的成本大大增加。比如：</p>
<pre><code>if(x[i] &gt; big);
    big = x[i];</code></pre><p>编译器会正常地接收第一行代码中的分号而不会提示任何警告信息，正确的做法应该是：</p>
<pre><code>if(x[i] &gt; big)
    big = x[i];</code></pre><h3 id="2-switch语句"><a href="#2-switch语句" class="headerlink" title="2 switch语句"></a>2 switch语句</h3><p>C语言的switch语句的控制流程能够依次通过并执行各个case部分，这一点是C语言与众不同之处。但是你有时候会忘记写break语句，这样就会造成意想不到的后果，比如：</p>
<pre><code>switch(color){
case 1:printf(&quot;red&quot;);
case 2:printf(&quot;yellow&quot;);
case 3:printf(&quot;blue&quot;);
}</code></pre><p>如果当color的值为2的时候，编译器会输出“yellowblue”。因为程序的控制流程在执行了第二个printf函数的调用之后，会自然而然的顺序执行下去，第三个printf函数调用也会被执行。所以在写switch语句的时候要相当注意，不过有时候你的需求就是不用加break，那么最好在程序里写上你的注释，这样别人就不会以为是忽略的错误。</p>
<pre><code>case SUBTRACT:
            opnd2 = -opnd2;
            //此处没有break语句

case ADD:
            .....</code></pre><h3 id="3-“悬挂”else引发的问题"><a href="#3-“悬挂”else引发的问题" class="headerlink" title="3 “悬挂”else引发的问题"></a>3 “悬挂”else引发的问题</h3><p><strong>else始终会与同一对括号内最近的且未匹配的if结合</strong></p>
<h3 id="练习2-1"><a href="#练习2-1" class="headerlink" title="练习2-1"></a>练习2-1</h3><p>C语言允许初始化列表中出现多余的逗号，例如：</p>
<pre><code>int days[] = { 31, 28 ,31 , 31,};</code></pre><p>为什么这种特性是有用的？答：方便自动化编写代码，不用单独处理。</p>
<p>​</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/20/e8-bf-90-e7-ae-97-e7-ac-a6-e4-bc-98-e5-85-88-e7-ba-a7-e7-9a-84-e9-97-ae-e9-a2-98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/20/e8-bf-90-e7-ae-97-e7-ac-a6-e4-bc-98-e5-85-88-e7-ba-a7-e7-9a-84-e9-97-ae-e9-a2-98/" class="post-title-link" itemprop="url">运算符优先级的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-20 12:03:07" itemprop="dateCreated datePublished" datetime="2018-04-20T12:03:07+08:00">2018-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="http://47.100.160.51/wordpress/wp-content/uploads/2018/04/1edd33fbc74d915b8ddfe9c96af8aaa1.png" alt=""></p>
<h3 id="结合性的理解"><a href="#结合性的理解" class="headerlink" title="结合性的理解"></a>结合性的理解</h3><p><strong>自左向右</strong>，比如成员运算符‘.’，a.b.c的含义是(a.b).c，而不是a.(b.c)。就是从左到右依次结合。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>优先级依次递减</p>
<h4 id="单目运算符"><a href="#单目运算符" class="headerlink" title="单目运算符"></a>单目运算符</h4><p>运算所需变量为<strong>1个</strong>的运算符（并不是之前理解的一个字符就是单目运算符），又称一元运算符，其中有</p>
<ul>
<li>!（逻辑非运算符）</li>
<li>~（按位取反运算符)</li>
<li>++（自增运算符）</li>
<li>—（自减运算符）</li>
</ul>
<p>它们的结合性是<strong>从右到左</strong>，比如*p++会被编译器解释成*(p++)，即取指针p所指向的对象，然后将p递增1；而不是(*p)++，即取指针p所指向的对象，然后将该对象递增1。</p>
<h4 id="双目运算符"><a href="#双目运算符" class="headerlink" title="双目运算符"></a>双目运算符</h4><p>顾名思义，需要2个变量的运算符。</p>
<h5 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h5><p>比如加减乘除操作，但是乘除的优先级大于加减，+ - * /。</p>
<h5 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h5><p>&lt;&lt;和&gt;&gt;，不是cout里的输出流运算符，而是移位。比如:</p>
<ul>
<li><p>&lt;&lt;是左移运算符，i&lt;&lt;4,是按位左移4位，例如：</p>
<p>i=8;</p>
<p>i&lt;&lt;4位后，，变成：</p>
<p>0000 0000 0000 1000 =8</p>
<p>0000 0000 1000 0000 =128</p>
</li>
</ul>
<h5 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h5><p>大于小于，大于等于，大于小于。不多解释</p>
<p>以上的结合性都是<strong>从左至右</strong></p>
<h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><p>需要三个变量的运算符，<strong>?:</strong>，比如：</p>
<pre><code>tax_rate = income&gt;40000 &amp;&amp; residency&lt;5 ? 3.5 : 2.0;</code></pre><p>上述代码的意思是：如果income大于40000且residency小于5，那么tax_rate的值为3.5否则为2.0;</p>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>=，+=等等赋值运算符，结合性为<strong>从右至左</strong></p>
<pre><code>home_score = visitor_score = 0;</code></pre><p>和下面的语句是一样的意思:</p>
<pre><code>visitor_score = 0;
home_score = visitor_score;</code></pre><p>​</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tanwenbo</p>
  <div class="site-description" itemprop="description">enjoy share</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">113</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tanwenbo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
