<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="enjoy share">
<meta property="og:type" content="website">
<meta property="og:title" content="hhyvs111">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="hhyvs111">
<meta property="og:description" content="enjoy share">
<meta property="article:author" content="tanwenbo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>hhyvs111</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hhyvs111</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Be a great man</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/24/glfwgetkey/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/24/glfwgetkey/" class="post-title-link" itemprop="url">glfwGetKey多次触发的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-24 09:58:46" itemprop="dateCreated datePublished" datetime="2018-10-24T09:58:46+08:00">2018-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/" itemprop="url" rel="index"><span itemprop="name">OpenGL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近写程序的时候用到了glfwGetKey，在里面写了一些相关的触发函数。但是奇怪的发现，我只按了一次触发键，却引起了多次调用。不知道是为什么，一开始没发现导致我踩了很多坑。</p>
<pre><code>if (glfwGetKey(window, GLFW_KEY_F1) == GLFW_PRESS)
{
    function();
}</code></pre><p>比如说你绑定了<code>F1</code>为某个功能键，你会发现你按了一下，却多次触发了function。目前原因不明，我的解决方法是加一个全局变量开关。</p>
<pre><code>if (glfwGetKey(window, GLFW_KEY_F1) == GLFW_PRESS)
{
    if(!functionOpen)
    {
        function();
        functionOpen = true;
    }
}</code></pre><p>不是完美的解决方法但是还是可以用的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/11/opengl-learn-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/11/opengl-learn-6/" class="post-title-link" itemprop="url">OpenGL学习笔记第6篇——变换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-11 10:21:52" itemprop="dateCreated datePublished" datetime="2018-09-11T10:21:52+08:00">2018-09-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/" itemprop="url" rel="index"><span itemprop="name">OpenGL</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">教程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这一章主要讲的是向量和矩阵，简单概括一下，很多内容都是线性代数里的东西。</p>
<h2 id="1-向量"><a href="#1-向量" class="headerlink" title="1 向量"></a>1 向量</h2><p>向量的基本概念就不用说了，就是一个三元组xyz，然后有一些加减乘除之类的东西。</p>
<h3 id="1-1-向量相乘"><a href="#1-1-向量相乘" class="headerlink" title="1.1 向量相乘"></a>1.1 向量相乘</h3><p>这个概念需要记一下，其他的就不用记了。</p>
<h4 id="点乘"><a href="#点乘" class="headerlink" title="点乘"></a>点乘</h4><p>两个向量的点乘等于它们的数乘结果乘以两个向量之间夹角的余弦值。<br><img src="https://tanwenbo.top/wp-content/uploads/2018/09/15366329703913.jpg" alt="">￼</p>
<p>余弦值公式：<br><img src="https://tanwenbo.top/wp-content/uploads/2018/09/15366330978971.jpg" alt="">￼</p>
<h4 id="叉乘"><a href="#叉乘" class="headerlink" title="叉乘"></a>叉乘</h4><p>叉乘只在3D空间中有定义，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量。<br><img src="https://tanwenbo.top/wp-content/uploads/2018/09/15366331299961.jpg" alt="">￼</p>
<h2 id="2-矩阵"><a href="#2-矩阵" class="headerlink" title="2 矩阵"></a>2 矩阵</h2><p>这个应该大家很熟悉，基本的加减乘除也不用说了。其在图形学中的主要用途就是<strong>坐标变换</strong>等之类的功能。</p>
<p>比如一个<strong>向量</strong>通过乘以某个矩阵可以改变大小或改变其角度。</p>
<h3 id="2-1-缩放"><a href="#2-1-缩放" class="headerlink" title="2.1 缩放"></a>2.1 缩放</h3><p>一个向量可以乘以一个<strong>缩放矩阵</strong>，然后可以将向量缩放指定的3倍。</p>
<pre><code>glm::scale</code></pre><p><img src="https://tanwenbo.top/wp-content/uploads/2018/09/15366334973996.jpg" alt="">￼</p>
<h3 id="2-2-位移"><a href="#2-2-位移" class="headerlink" title="2.2 位移"></a>2.2 位移</h3><p>位移(Translation)是在原始向量的基础上加上另一个向量从而获得一个在不同位置的新向量的过程，从而在位移向量基础上移动了原始向量。</p>
<pre><code>glm::translate</code></pre><p><img src="https://tanwenbo.top/wp-content/uploads/2018/09/15366339940573.jpg" alt="">￼</p>
<h3 id="2-3-旋转"><a href="#2-3-旋转" class="headerlink" title="2.3 旋转"></a>2.3 旋转</h3><p>主要是向量乘以角度，然后就能达到旋转的效果。</p>
<pre><code>glm::rotate</code></pre><p><img src="https://tanwenbo.top/wp-content/uploads/2018/09/15366340991061.jpg" alt="">￼</p>
<h2 id="3-应用"><a href="#3-应用" class="headerlink" title="3 应用"></a>3 应用</h2><h3 id="3-1-GLM"><a href="#3-1-GLM" class="headerlink" title="3.1 GLM"></a>3.1 GLM</h3><p>GLM是OpenGL Mathematics的缩写，它是一个只有头文件的库，一般我们用到的矩阵操作都通过该库来操作。<br>把一个向量(1, 0, 0)位移(1, 1, 0)个单位（注意，我们把它定义为一个glm::vec4类型的值，齐次坐标设定为1.0）：</p>
<pre><code>glm::vec4 vec(1.0f, 0.0f, 0.0f, 1.0f);
// 译注：下面就是矩阵初始化的一个例子，如果使用的是0.9.9及以上版本
// 下面这行代码就需要改为:
// glm::mat4 trans = glm::mat4(1.0f)
// 之后将不再进行提示
glm::mat4 trans;
//位移1，1，0个单位
trans = glm::translate(trans, glm::vec3(1.0f, 1.0f, 0.0f));
vec = trans * vec;
std::cout &lt;&lt; vec.x &lt;&lt; vec.y &lt;&lt; vec.z &lt;&lt; std::endl;</code></pre><h3 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2 实现"></a>3.2 实现</h3><p>一个比较重要的问题：如何把矩阵传递给着色器？我们在前面简单提到过GLSL里也有一个mat4类型。所以我们将修改顶点着色器让其接收一个mat4的uniform变量，然后再用矩阵uniform乘以位置向量：</p>
<pre><code>#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aTexCoord;

out vec2 TexCoord;

uniform mat4 transform;

void main()
{
    gl_Position = transform * vec4(aPos, 1.0f);
    TexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);
}</code></pre><h2 id="4-效果"><a href="#4-效果" class="headerlink" title="4 效果"></a>4 效果</h2><p><a href="https://learnopengl-cn.github.io/img/01/07/transformations.mp4" target="_blank" rel="noopener">https://learnopengl-cn.github.io/img/01/07/transformations.mp4</a><br>具体的效果可以看该视频，就是一个图像在旋转。</p>
<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h2><p>该章节算是一个比较重要的，引入了矩阵的概念，对以后的三维图像制作很有帮助！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/10/opengl-learn-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/10/opengl-learn-5/" class="post-title-link" itemprop="url">OpenGL学习笔记第5篇——纹理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-10 09:39:38" itemprop="dateCreated datePublished" datetime="2018-09-10T09:39:38+08:00">2018-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/" itemprop="url" rel="index"><span itemprop="name">OpenGL</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">教程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>个人感觉这篇比较重要，纹理能直观的反映图形的形状。</p>
</blockquote>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><p><code>纹理</code>(Texture)基于顶点，如果要图片看起来更逼真那么就必须要有足够多的顶点。纹理就像是墙纸一样，能贴合到你造的墙（画的图形）上。</p>
<h2 id="1-纹理原理"><a href="#1-纹理原理" class="headerlink" title="1 纹理原理"></a>1 纹理原理</h2><p>比如这里我们用之前画的三角形做一个纹理：<br><img src="https://tanwenbo.top/wp-content/uploads/2018/09/15365624430350.jpg" alt="">￼</p>
<blockquote>
<p>为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个<strong>纹理坐标</strong>(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。</p>
</blockquote>
<h3 id="1-1-纹理坐标"><a href="#1-1-纹理坐标" class="headerlink" title="1.1 纹理坐标"></a>1.1 纹理坐标</h3><p>其实就是另一种画图，只要指定了范围后就会进行插值。<br><img src="https://tanwenbo.top/wp-content/uploads/2018/09/15365629414088.jpg" alt="">￼</p>
<p>只要将这几个坐标传给<strong>顶点着色器</strong>后就会自动进行插值。</p>
<p>纹理坐标看起来就像这样：</p>
<pre><code>float texCoords[] = {
    0.0f, 0.0f, // 左下角
    1.0f, 0.0f, // 右下角
    0.5f, 1.0f // 上中
};</code></pre><h3 id="1-2-纹理环绕方式"><a href="#1-2-纹理环绕方式" class="headerlink" title="1.2 纹理环绕方式"></a>1.2 纹理环绕方式</h3><p>和office里图片环绕方式有点类似，纹理也有其环绕方式。</p>
<p>主要是以下几种：</p>
<p>环绕方式</p>
<p>描述</p>
<p>GL_REPEAT</p>
<p>对纹理的默认行为。重复纹理图像。</p>
<p>GL_MIRRORED_REPEAT</p>
<p>和GL_REPEAT一样，但每次重复图片是镜像放置的。</p>
<p>GL_CLAMP_TO_EDGE</p>
<p>纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。</p>
<p>GL_CLAMP_TO_BORDER</p>
<p>超出的坐标为用户指定的边缘颜色。</p>
<p><img src="https://tanwenbo.top/wp-content/uploads/2018/09/15365635936148.jpg" alt="">￼</p>
<h2 id="2-纹理过滤"><a href="#2-纹理过滤" class="headerlink" title="2 纹理过滤"></a>2 纹理过滤</h2><p>纹理坐标不依赖于分辨率，所以OpenGL需要知道怎样将纹理像素(Texture Pixel，也叫Texel，译注1)映射到纹理坐标。当你有一个很大的物体但是纹理的分辨率很低的时候这就变得很重要了。</p>
<blockquote>
<p>想必大家都知道像素这个东西，当你放大一张图片后你回发现图片是由一些小方块组成的。</p>
</blockquote>
<p>主要是有两种纹理过滤方式</p>
<h3 id="2-1-邻近过滤"><a href="#2-1-邻近过滤" class="headerlink" title="2.1 邻近过滤"></a>2.1 邻近过滤</h3><p>简而言之就是OpenGL会选择最接近纹理坐标值的像素，然后将整块纹理渲染成最接近的那块。<br><img src="https://tanwenbo.top/wp-content/uploads/2018/09/15365642046108.jpg" alt="">￼</p>
<h3 id="2-2-线性过滤"><a href="#2-2-线性过滤" class="headerlink" title="2.2 线性过滤"></a>2.2 线性过滤</h3><p>它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色：</p>
<p><img src="https://tanwenbo.top/wp-content/uploads/2018/09/15365646950479.jpg" alt="">￼</p>
<h4 id="两种过滤对比"><a href="#两种过滤对比" class="headerlink" title="两种过滤对比"></a>两种过滤对比</h4><p><img src="https://tanwenbo.top/wp-content/uploads/2018/09/15365647862179.jpg" alt="">￼<br>可以看到虽然<code>GL_NEAREST</code>有锯齿，但是总体来说还是比较清晰的。</p>
<blockquote>
<p>一般游戏里可能就是<code>GL_NEAREST</code>这种，然后再用抗锯齿来消除锯齿。</p>
</blockquote>
<h2 id="3-加载纹理"><a href="#3-加载纹理" class="headerlink" title="3 加载纹理"></a>3 加载纹理</h2><p>这里也是用现成的工具库加载。</p>
<h3 id="3-1-stb-image-h"><a href="#3-1-stb-image-h" class="headerlink" title="3.1 stb_image.h"></a>3.1 stb_image.h</h3><p>stb_image.h是Sean Barrett的一个非常流行的单头文件图像加载库，它能够加载大部分流行的文件格式，并且能够很简单得整合到你的工程之中。stb_image.h可以在<a href="https://github.com/nothings/stb/blob/master/stb_image.h" target="_blank" rel="noopener">这里</a>下载。下载这一个头文件，将它以stb_image.h的名字加入你的工程，并另创建一个新的C++文件，输入以下代码：</p>
<pre><code>#define STB_IMAGE_IMPLEMENTATION
#include &quot;stb_image.h&quot;</code></pre><h3 id="3-2-加载图片"><a href="#3-2-加载图片" class="headerlink" title="3.2 加载图片"></a>3.2 加载图片</h3><p>使用一张<a href="https://learnopengl-cn.github.io/img/01/06/container.jpg" target="_blank" rel="noopener">木箱</a>的图片。要使用stb_image.h加载图片，我们需要使用它的stbi_load函数：</p>
<pre><code>int width, height, nrChannels;
unsigned char *data = stbi_load(&quot;container.jpg&quot;, &amp;width, &amp;height, &amp;nrChannels, 0);</code></pre><h2 id="4-生成纹理"><a href="#4-生成纹理" class="headerlink" title="4 生成纹理"></a>4 生成纹理</h2><p>和之前生成的OpenGL对象一样，纹理也是使用<strong>ID</strong>引用的。让我们来创建一个：</p>
<pre><code>unsigned int texture;
glGenTextures(1, &amp;texture);</code></pre><blockquote>
<p>这个是比较重要的概念。</p>
</blockquote>
<pre><code>生成一个纹理的过程应该看起来像这样：

unsigned int texture;
glGenTextures(1, &amp;texture);
glBindTexture(GL_TEXTURE_2D, texture);
// 为当前绑定的纹理对象设置环绕、过滤方式
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
// 加载并生成纹理
int width, height, nrChannels;
unsigned char *data = stbi_load(&quot;container.jpg&quot;, &amp;width, &amp;height, &amp;nrChannels, 0);
if (data)
{
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);
    glGenerateMipmap(GL_TEXTURE_2D);
}
else
{
    std::cout &lt;&lt; &quot;Failed to load texture&quot; &lt;&lt; std::endl;
}
//用完图片后释放
stbi_image_free(data);</code></pre><h2 id="5-应用纹理"><a href="#5-应用纹理" class="headerlink" title="5 应用纹理"></a>5 应用纹理</h2><pre><code>glBindTexture(GL_TEXTURE_2D, texture);
glBindVertexArray(VAO);
glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</code></pre><p>其他的是一些设置顶点。</p>
<h2 id="6-效果"><a href="#6-效果" class="headerlink" title="6 效果"></a>6 效果</h2><p><img src="https://tanwenbo.top/wp-content/uploads/2018/09/15365819082294.jpg" alt="">￼</p>
<h2 id="7-键值绑定"><a href="#7-键值绑定" class="headerlink" title="7 键值绑定"></a>7 键值绑定</h2><pre><code>if (glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS)
{
    mixValue += 0.001f; // change this value accordingly (might be too slow or too fast based on system hardware)
    if(mixValue &gt;= 1.0f)
        mixValue = 1.0f;
}
if (glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS)
{
    mixValue -= 0.001f; // change this value accordingly (might be too slow or too fast based on system hardware)
    if (mixValue &lt;= 0.0f)
        mixValue = 0.0f;
}</code></pre><p>这个东西有点意思，可以绑定相关的键然后进行相关操作。</p>
<h2 id="8-小结"><a href="#8-小结" class="headerlink" title="8 小结"></a>8 小结</h2><p>一开始还自己写代码然后一个个改，但是发现实在是效率太低了，需要加快速度了。所以直接clone了作者的代码，也可以正常运行和修改。</p>
<blockquote>
<p>OpenGL只是为了毕业，不需要学那么精了。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/09/opengl-learn-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/09/opengl-learn-4/" class="post-title-link" itemprop="url">OpenGL学习笔记第4篇——着色器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-09 10:04:42" itemprop="dateCreated datePublished" datetime="2018-09-09T10:04:42+08:00">2018-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/" itemprop="url" rel="index"><span itemprop="name">OpenGL</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">教程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>前面学的着色器只是一点皮毛，感觉自己还是不需要学这么细，主要是为了完成论文。</p>
</blockquote>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><p>之前定义的两个着色器：</p>
<ul>
<li>顶点着色器；</li>
<li>片段着色器。</li>
</ul>
<p>在代码里的具体实现是：</p>
<pre><code>//定义一个顶点着色器
const char *vertexShaderSource = &quot;#version 330 core\n&quot;
                                 &quot;layout (location = 0) in vec3 aPos;\n&quot;
                                 &quot;void main()\n&quot;
                                 &quot;{\n&quot;
                                 &quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;
                                 &quot;}\0&quot;;

//定义一个片段着色器
//这里可以改变颜色
const char *fragmentShaderSource = &quot;#version 330 core\n&quot;
                                   &quot;out vec4 FragColor;\n&quot;
                                   &quot;void main()\n&quot;
                                   &quot;{\n&quot;
                                   &quot;   FragColor = vec4(0.5f, 0.5f, 0.2f, 1.0f);\n&quot;
                                   &quot;}\n\0&quot;;</code></pre><p>第一次看到还觉得很奇怪，还可以这样定义一个变量。下面可以了解为什么这样定义！</p>
<h2 id="1-GLSL"><a href="#1-GLSL" class="headerlink" title="1 GLSL"></a>1 GLSL</h2><p>着色器是使用一种叫GLSL的<code>类C语言</code>写成的，是为图形学计算量身定做的。</p>
<blockquote>
<p>使用 GLSL 有如下好处：</p>
<ul>
<li>具有跨平台的相容性，包括 Macintosh、Windows 和 Linux 等操作系统。</li>
<li>所有支援 OpenGL 着色语言的绘图卡，都可以用来编写着色器。</li>
<li>允许厂商为特定的绘图卡产生最佳化的代码。</li>
</ul>
</blockquote>
<h3 id="1-1-着色器典型结构"><a href="#1-1-着色器典型结构" class="headerlink" title="1.1 着色器典型结构"></a>1.1 着色器典型结构</h3><pre><code>#version version_number
in type in_variable_name;
in type in_variable_name;

out type out_variable_name;

uniform type uniform_name;

int main()
{
  // 处理输入并进行一些图形操作
  ...
  // 输出处理过的结果到输出变量
  out_variable_name = weird_stuff_we_processed;
}</code></pre><p>主要关注的是<code>IN</code>、<code>uniform</code>和<code>OUT</code>，</p>
<ul>
<li>IN就是着色器的<strong>输入</strong>；</li>
<li>OUT就是着色器的<strong>输出</strong>；</li>
<li>uniform<strong>全局变量</strong>。</li>
</ul>
<h3 id="1-2-uniform"><a href="#1-2-uniform" class="headerlink" title="1.2 uniform"></a>1.2 uniform</h3><p>Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。</p>
<h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2 数据类型"></a>2 数据类型</h2><p>主要的数据类型就是向量，一般是包含4个以内分量的容器，由数字和字母组成(n代表分量的数量）。</p>
<p>类型</p>
<p>含义</p>
<p>vecn</p>
<p>包含n个float分量的默认向量</p>
<p>bvecn</p>
<p>包含n个bool分量的向量</p>
<p>ivecn</p>
<p>包含n个int分量的向量</p>
<p>大多数用vecn，因为<code>float</code>足够满足大多数要求了。</p>
<p>一个向量的分量可以通过vec.x这种方式获取，这里x是指这个向量的第一个分量。你可以分别使用.x、.y、.z和.w来获取它们的第1、2、3、4个分量。</p>
<blockquote>
<p>太尼玛难了，从入门到放弃！</p>
</blockquote>
<h2 id="3-着色器类"><a href="#3-着色器类" class="headerlink" title="3 着色器类"></a>3 着色器类</h2><p>可以自己写一个类，然后读取着色器文件，这样就不用一直在cpp的开头定义了。</p>
<h3 id="3-1-类开头"><a href="#3-1-类开头" class="headerlink" title="3.1 类开头"></a>3.1 类开头</h3><p>主要是一些文件处理，读取定义的着色器文件。</p>
<pre><code>Shader(const char* vertexPath, const char* fragmentPath)
{
    // 1. 从文件路径中获取顶点/片段着色器
    std::string vertexCode;
    std::string fragmentCode;
    std::ifstream vShaderFile;
    std::ifstream fShaderFile;
    // 保证ifstream对象可以抛出异常：
    vShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit);
    fShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit);
    try 
    {
        // 打开文件
        vShaderFile.open(vertexPath);
        fShaderFile.open(fragmentPath);
        std::stringstream vShaderStream, fShaderStream;
        // 读取文件的缓冲内容到数据流中
        vShaderStream &lt;&lt; vShaderFile.rdbuf();
        fShaderStream &lt;&lt; fShaderFile.rdbuf();       
        // 关闭文件处理器
        vShaderFile.close();
        fShaderFile.close();
        // 转换数据流到string
        vertexCode   = vShaderStream.str();
        fragmentCode = fShaderStream.str();     
    }
    catch(std::ifstream::failure e)
    {
        std::cout &lt;&lt; &quot;ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ&quot; &lt;&lt; std::endl;
    }
    const char* vShaderCode = vertexCode.c_str();
    const char* fShaderCode = fragmentCode.c_str();
    [...]</code></pre><h3 id="3-2-编译着色器"><a href="#3-2-编译着色器" class="headerlink" title="3.2 编译着色器"></a>3.2 编译着色器</h3><p>一些编译的过程，直接集中到类里去了。</p>
<pre><code>// 2. 编译着色器
unsigned int vertex, fragment;
int success;
char infoLog[512];

// 顶点着色器
vertex = glCreateShader(GL_VERTEX_SHADER);
glShaderSource(vertex, 1, &amp;vShaderCode, NULL);
glCompileShader(vertex);
// 打印编译错误（如果有的话）
glGetShaderiv(vertex, GL_COMPILE_STATUS, &amp;success);
if(!success)
{
    glGetShaderInfoLog(vertex, 512, NULL, infoLog);
    std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;
};

// 片段着色器也类似
[...]

// 着色器程序
ID = glCreateProgram();
glAttachShader(ID, vertex);
glAttachShader(ID, fragment);
glLinkProgram(ID);
// 打印连接错误（如果有的话）
glGetProgramiv(ID, GL_LINK_STATUS, &amp;success);
if(!success)
{
    glGetProgramInfoLog(ID, 512, NULL, infoLog);
    std::cout &lt;&lt; &quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;
}

// 删除着色器，它们已经链接到我们的程序中了，已经不再需要了
glDeleteShader(vertex);
glDeleteShader(fragment);</code></pre><h3 id="3-3-使用着色器"><a href="#3-3-使用着色器" class="headerlink" title="3.3 使用着色器"></a>3.3 使用着色器</h3><p>这里的直接把<code>glUseProgram</code>做成<code>Use</code>方法。</p>
<pre><code>void use() 
{ 
    glUseProgram(ID);
}</code></pre><h3 id="3-4-文件"><a href="#3-4-文件" class="headerlink" title="3.4 文件"></a>3.4 文件</h3><p>创建2个文件命名为<code>shader.vs</code>和<code>shader.fs</code>，vs和fs就是后缀。</p>
<h4 id="shader-vs"><a href="#shader-vs" class="headerlink" title="shader.vs"></a>shader.vs</h4><pre><code>#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aColor;

out vec3 ourColor;

void main()
{
    gl_Position = vec4(aPos, 1.0);
    ourColor = aColor;
}</code></pre><h4 id="shader-fs"><a href="#shader-fs" class="headerlink" title="shader.fs"></a>shader.fs</h4><pre><code>#version 330 core
out vec4 FragColor;

in vec3 ourColor;

void main()
{
    FragColor = vec4(ourColor, 1.0f);
}</code></pre><h3 id="3-5-使用"><a href="#3-5-使用" class="headerlink" title="3.5 使用"></a>3.5 使用</h3><p>使用的时候很简单，如果运行了没有显示那么记得加上文件的绝对路径。</p>
<pre><code>Shader ourShader(&quot;path/to/shaders/shader.vs&quot;, &quot;path/to/shaders/shader.fs&quot;);
...
while(...)
{
    ourShader.use();
    ourShader.setFloat(&quot;someUniform&quot;, 1.0f);
    DrawStuff();
}</code></pre><h2 id="4-运行"><a href="#4-运行" class="headerlink" title="4 运行"></a>4 运行</h2><p><img src="https://tanwenbo.top/wp-content/uploads/2018/09/15364905127795.jpg" alt="">￼</p>
<p>教程地址：<a href="https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/#_5" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/#_5</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/08/opengl-learn-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/08/opengl-learn-3/" class="post-title-link" itemprop="url">OpenGL学习笔记第3篇——三角形</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-08 15:46:59" itemprop="dateCreated datePublished" datetime="2018-09-08T15:46:59+08:00">2018-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/" itemprop="url" rel="index"><span itemprop="name">OpenGL</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">教程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>这一节有点难，看了半天，需要一些计算机图形学的知识才能看懂。<br>本笔记尽量简洁通俗的记录。</p>
</blockquote>
<h2 id="0-准备"><a href="#0-准备" class="headerlink" title="0 准备"></a>0 准备</h2><p>学习之前先记几个单词：</p>
<ul>
<li>顶点数组对象：Vertex Array Object，VAO</li>
<li>顶点缓冲对象：Vertex Buffer Object，VBO</li>
<li>索引缓冲对象：Element Buffer Object，EBO或Index Buffer Object，IBO</li>
</ul>
<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><p>在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。</p>
<blockquote>
<p>看到这里有点惊讶啊，还有这样的操作。</p>
</blockquote>
<h3 id="1-1-图形渲染管线"><a href="#1-1-图形渲染管线" class="headerlink" title="1.1 图形渲染管线"></a>1.1 图形渲染管线</h3><p>3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline）管理的。<br>主要是两个过程组成：</p>
<ul>
<li>3D坐标转为2D坐标；</li>
<li>2D坐标转换为实际的有颜色的像素。</li>
</ul>
<p>这些过程已经封装好了，所以不用过多去关注。且有并行执行的特性，也就是说如果GPU核心数越多，渲染的过程也就更快。</p>
<h3 id="1-2-着色器"><a href="#1-2-着色器" class="headerlink" title="1.2 着色器"></a>1.2 着色器</h3><p>显卡上一般都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。</p>
<h2 id="2-渲染"><a href="#2-渲染" class="headerlink" title="2 渲染"></a>2 渲染</h2><p>渲染过程的抽象展示，蓝色部分代表的是我们可以自定义着色器的部分。<br><img src="https://tanwenbo.top/wp-content/uploads/2018/09/15363950059078.jpg" alt="">￼</p>
<p>图形渲染管线包含很多部分，每个部分都将在转换顶点数据到最终像素这一过程中处理各自特定的阶段。对于大多数场合，我们只需要配置<strong>顶点着色器</strong>和<strong>片段着色器</strong>就行了。<strong>几何着色器</strong>是可选的，通常使用它默认的着色器就行了。</p>
<h2 id="3-图元"><a href="#3-图元" class="headerlink" title="3 图元"></a>3 图元</h2><p>OpenGL里存在图元（Primitive）的概念，也就是<code>点</code>，<code>线</code>和<code>多边形</code>。一切图形都是由多个图元组成。</p>
<p>且任何一个绘制指令的调用都将把图元传递给OpenGL。</p>
<h3 id="3-1-常见图元"><a href="#3-1-常见图元" class="headerlink" title="3.1 常见图元"></a>3.1 常见图元</h3><p>类型</p>
<p>说明</p>
<p>GL_POINTS</p>
<p>单个顶点集</p>
<p>GL_LINES</p>
<p>多组双顶点线段</p>
<p>GL_POLYGON</p>
<p>单个简单填充凸多边形</p>
<p>GL_TRAINGLES</p>
<p>多组独立填充三角形</p>
<p>GL_QUADS</p>
<p>多组独立填充四边形</p>
<p>GL_LINE_STRIP</p>
<p>不闭合折线</p>
<p>GL_LINE_LOOP</p>
<p>闭合折线</p>
<p>GL_TRAINGLE_STRIP</p>
<p>线型连续填充三角形串</p>
<p>GL_TRAINGLE_FAN</p>
<p>扇形连续填充三角形串</p>
<p>GL_QUAD_STRIP</p>
<p>连续填充四边形串</p>
<h2 id="4-顶点输入"><a href="#4-顶点输入" class="headerlink" title="4 顶点输入"></a>4 顶点输入</h2><p>前面有说过OpenGL的数据都是3D的，所以其指定的所有坐标都是三维坐标（xyz），若要显示2D图形则将<code>z轴</code>的数据置为<code>0</code>。</p>
<p>OpenGL不是简单地把所有的3D坐标变换为屏幕上的2D像素；OpenGL仅当3D坐标在3个轴（x、y和z）上都为-1.0到1.0的范围内时才处理它。</p>
<p>我们希望渲染一个三角形，我们一共要指定三个顶点，每个顶点都有一个3D位置。我们会将它们以标准化设备坐标的形式（OpenGL的可见区域）定义为一个float数组。</p>
<pre><code>float vertices[] = {
    -0.5f, -0.5f, 0.0f,
     0.5f, -0.5f, 0.0f,
     0.0f,  0.5f, 0.0f
};</code></pre><h3 id="4-1-缓存"><a href="#4-1-缓存" class="headerlink" title="4.1 缓存"></a>4.1 缓存</h3><p>前面有说着色器运行的速度基于显卡，顶点缓冲对象(Vertex Buffer Objects, <code>VBO</code>)用于存储我们定义的顶点数据。<code>VBO</code>会在GPU内存（显存）中储存大量顶点，然后在需要的时候一次性的发送一大批数据到显卡上。</p>
<blockquote>
<p>所以显存是显卡性能中十分重要的一个部分，显存越大发送的数据越多。</p>
</blockquote>
<p>当数据发送至显存中后，顶点着色器能立即访问顶点。</p>
<p>OpenGL中的其它对象一样，这个缓冲有一个独一无二的ID，所以我们可以使用glGenBuffers函数和一个缓冲ID<strong>生成一个VBO对象</strong>：</p>
<pre><code>unsigned int VBO;
glGenBuffers(1, &amp;VBO);</code></pre><p>将新建的缓冲绑定到<code>GL_ARRAY_BUFFER</code>目标上：</p>
<pre><code>glBindBuffer(GL_ARRAY_BUFFER, VBO);  </code></pre><p>然后我们可以调用glBufferData函数，它会把之前定义的顶点数据复制到缓冲的内存中：</p>
<pre><code>glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</code></pre><p>主要是了解一下第四个参数，其指定了我们希望显卡如何管理给定的数据。有三种形式：</p>
<ul>
<li>GL_STATIC_DRAW ：数据不会或几乎不会改变。</li>
<li>GL_DYNAMIC_DRAW：数据会被改变很多。</li>
<li>GL_STREAM_DRAW ：数据每次绘制时都会改变。</li>
</ul>
<h2 id="5-着色器"><a href="#5-着色器" class="headerlink" title="5 着色器"></a>5 着色器</h2><p>现在具体介绍一下3种我们需要处理的着色器</p>
<h3 id="5-1-顶点着色器"><a href="#5-1-顶点着色器" class="headerlink" title="5.1 顶点着色器"></a>5.1 顶点着色器</h3><p>如果要渲染的话必须要写一个顶点着色器和片段着色器，那么就需要用着色器语言<code>GLSL</code>(OpenGL Shading Language)编写顶点着色器，然后就可以在程序中使用它了！</p>
<pre><code>#version 330 core
layout (location = 0) in vec3 aPos;

void main()
{
    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
}</code></pre><p>这是一个非常基础的GLSL着色器源码。</p>
<p>这里引入了另一个重要的概念：向量（Vector）</p>
<blockquote>
<p>向量(Vector)</p>
<p>在图形编程中我们经常会使用向量这个数学概念，因为它简明地表达了任意空间中的位置和方向，并且它有非常有用的数学属性。在GLSL中一个向量有最多4个分量，每个分量值都代表空间中的一个坐标，它们可以通过vec.x、vec.y、vec.z和vec.w来获取。注意vec.w分量不是用作表达空间中的位置的（我们处理的是3D不是4D），而是用在所谓透视除法(Perspective Division)上。我们会在后面的教程中更详细地讨论向量。</p>
</blockquote>
<h3 id="5-2-编译着色器"><a href="#5-2-编译着色器" class="headerlink" title="5.2 编译着色器"></a>5.2 编译着色器</h3><p>上面已经写了一个顶点着色器（存储在C的字符串中），为了OpenGL能使用它，必须在运行时动态编译它的源码。</p>
<h4 id="创建着色器"><a href="#创建着色器" class="headerlink" title="创建着色器"></a>创建着色器</h4><pre><code>unsigned int vertexShader;
vertexShader = glCreateShader(GL_VERTEX_SHADER);</code></pre><h4 id="添加着色器"><a href="#添加着色器" class="headerlink" title="添加着色器"></a>添加着色器</h4><pre><code>glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);
glCompileShader(vertexShader);</code></pre><p>加入source后再编译。</p>
<p>如果编译的时候没有检测到任何错误，顶点着色器就被编译成功了。</p>
<h3 id="5-3-片段着色器"><a href="#5-3-片段着色器" class="headerlink" title="5.3 片段着色器"></a>5.3 片段着色器</h3><p>片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。</p>
<blockquote>
<p>在计算机图形中颜色被表示为有4个元素的数组：红色、绿色、蓝色和alpha(透明度)分量，通常缩写为RGBA。当在OpenGL或GLSL中定义一个颜色的时候，我们把颜色每个分量的强度设置在0.0到1.0之间。比如说我们设置红为1.0f，绿为1.0f，我们会得到两个颜色的混合色，即黄色。这三种颜色分量的不同调配可以生成超过1600万种不同的颜色！</p>
</blockquote>
<p>简单来说片段着色器就是设置渲染的颜色的，也没什么特别的东西。</p>
<p>设置颜色的RGBA。</p>
<pre><code>#version 330 core
out vec4 FragColor;

void main()
{
    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);
} </code></pre><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>与顶点不一样的是用<code>GL_FRAGMENT_SHADER</code>作为着色器类型（顶点着色器<code>GL_VERTEX_SHADER</code>）。</p>
<pre><code>unsigned int fragmentShader;
fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);
glCompileShader(fragmentShader);</code></pre><h2 id="6-顶点数组对象"><a href="#6-顶点数组对象" class="headerlink" title="6 顶点数组对象"></a>6 顶点数组对象</h2><p>前面有提到的三个名词，上面的内容一直在介绍VBO（顶点缓冲对象），现在来了解一下VAO（顶点数组对象）。</p>
<p><img src="https://tanwenbo.top/wp-content/uploads/2018/09/15364101061568.jpg" alt="">￼</p>
<p>可以看到VAO就是VBO的集合。</p>
<h2 id="7-索引缓冲对象"><a href="#7-索引缓冲对象" class="headerlink" title="7 索引缓冲对象"></a>7 索引缓冲对象</h2><p>索引缓冲对象(Element Buffer Object，EBO)，和顶点缓冲对象一样，EBO也是一个缓冲，专门用来储存索引。</p>
<p>也就是VAO的索引：<br><img src="https://tanwenbo.top/wp-content/uploads/2018/09/15364104063147.jpg" alt="">￼</p>
<blockquote>
<p>具体代码就不贴了，可以看原文教程。</p>
</blockquote>
<h2 id="8-运行"><a href="#8-运行" class="headerlink" title="8 运行"></a>8 运行</h2><p>题目是三角形，那么运行一下。<br><img src="https://tanwenbo.top/wp-content/uploads/2018/09/15364579404714.jpg" alt="">￼</p>
<p>三角形看起来不错，很平滑。</p>
<h2 id="9-完整代码"><a href="#9-完整代码" class="headerlink" title="9 完整代码"></a>9 完整代码</h2><pre><code>#include &lt;glad/glad.h&gt;
#include &lt;GLFW/glfw3.h&gt;

#include &lt;iostream&gt;

void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void processInput(GLFWwindow *window);

// settings
const unsigned int SCR_WIDTH = 800;
const unsigned int SCR_HEIGHT = 600;

const char *vertexShaderSource = &quot;#version 330 core\n&quot;
    &quot;layout (location = 0) in vec3 aPos;\n&quot;
    &quot;void main()\n&quot;
    &quot;{\n&quot;
    &quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;
    &quot;}\0&quot;;
const char *fragmentShaderSource = &quot;#version 330 core\n&quot;
    &quot;out vec4 FragColor;\n&quot;
    &quot;void main()\n&quot;
    &quot;{\n&quot;
    &quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;
    &quot;}\n\0&quot;;

int main()
{
    // glfw: initialize and configure
    // ------------------------------
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

#ifdef __APPLE__
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // uncomment this statement to fix compilation on OS X
#endif

    // glfw window creation
    // --------------------
    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, &quot;LearnOpenGL&quot;, NULL, NULL);
    if (window == NULL)
    {
        std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl;
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

    // glad: load all OpenGL function pointers
    // ---------------------------------------
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    {
        std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl;
        return -1;
    }


    // build and compile our shader program
    // ------------------------------------
    // vertex shader
    int vertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);
    glCompileShader(vertexShader);
    // check for shader compile errors
    int success;
    char infoLog[512];
    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);
    if (!success)
    {
        glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
        std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;
    }
    // fragment shader
    int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);
    glCompileShader(fragmentShader);
    // check for shader compile errors
    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success);
    if (!success)
    {
        glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);
        std::cout &lt;&lt; &quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;
    }
    // link shaders
    int shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram, vertexShader);
    glAttachShader(shaderProgram, fragmentShader);
    glLinkProgram(shaderProgram);
    // check for linking errors
    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);
    if (!success) {
        glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
        std::cout &lt;&lt; &quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;
    }
    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);

    // set up vertex data (and buffer(s)) and configure vertex attributes
    // ------------------------------------------------------------------
    float vertices[] = {
        -0.5f, -0.5f, 0.0f, // left  
         0.5f, -0.5f, 0.0f, // right 
         0.0f,  0.5f, 0.0f  // top   
    }; 

    unsigned int VBO, VAO;
    glGenVertexArrays(1, &amp;VAO);
    glGenBuffers(1, &amp;VBO);
    // bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).
    glBindVertexArray(VAO);

    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);

    // note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute&apos;s bound vertex buffer object so afterwards we can safely unbind
    glBindBuffer(GL_ARRAY_BUFFER, 0); 

    // You can unbind the VAO afterwards so other VAO calls won&apos;t accidentally modify this VAO, but this rarely happens. Modifying other
    // VAOs requires a call to glBindVertexArray anyways so we generally don&apos;t unbind VAOs (nor VBOs) when it&apos;s not directly necessary.
    glBindVertexArray(0); 


    // uncomment this call to draw in wireframe polygons.
    //glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);

    // render loop
    // -----------
    while (!glfwWindowShouldClose(window))
    {
        // input
        // -----
        processInput(window);

        // render
        // ------
        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);

        // draw our first triangle
        glUseProgram(shaderProgram);
        glBindVertexArray(VAO); // seeing as we only have a single VAO there&apos;s no need to bind it every time, but we&apos;ll do so to keep things a bit more organized
        glDrawArrays(GL_TRIANGLES, 0, 3);
        // glBindVertexArray(0); // no need to unbind it every time 

        // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)
        // -------------------------------------------------------------------------------
        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    // optional: de-allocate all resources once they&apos;ve outlived their purpose:
    // ------------------------------------------------------------------------
    glDeleteVertexArrays(1, &amp;VAO);
    glDeleteBuffers(1, &amp;VBO);

    // glfw: terminate, clearing all previously allocated GLFW resources.
    // ------------------------------------------------------------------
    glfwTerminate();
    return 0;
}

// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly
// ---------------------------------------------------------------------------------------------------------
void processInput(GLFWwindow *window)
{
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
        glfwSetWindowShouldClose(window, true);
}

// glfw: whenever the window size changed (by OS or user resize) this callback function executes
// ---------------------------------------------------------------------------------------------
void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
    // make sure the viewport matches the new window dimensions; note that width and 
    // height will be significantly larger than specified on retina displays.
    glViewport(0, 0, width, height);
}</code></pre><h2 id="10-小结"><a href="#10-小结" class="headerlink" title="10 小结"></a>10 小结</h2><p>这一章对初学者来说还是有点难度的，很多名词都没听过。但是个人而言，学习了这一章的知识后对计算机<strong>显卡</strong>等方面的知识方面了解不少，也知道一个图形是怎么显示到屏幕上。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/08/mac-shi-yongclion-pei-zhiopenglglewgladglfw/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/08/mac-shi-yongclion-pei-zhiopenglglewgladglfw/" class="post-title-link" itemprop="url">Mac使用Clion配置OpenGL(glew,glad,glfw)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-08 14:19:14" itemprop="dateCreated datePublished" datetime="2018-09-08T14:19:14+08:00">2018-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/" itemprop="url" rel="index"><span itemprop="name">OpenGL</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">教程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>转载来自：<a href="https://www.cnblogs.com/fanghao/p/8027627.html" target="_blank" rel="noopener">https://www.cnblogs.com/fanghao/p/8027627.html</a><br>主要是改了几个错误的地方，其他的可以参考该博主的。然后glew和glad可以自己选一个，推荐的是glad。</p>
</blockquote>
<p>之前博主是用Xcode配置的openGL，但后来因为要与非Mac队友合作，于是大家决定统一使用Clion，博主于是再次配置开发环境，这里记录一下</p>
<h3 id="预先准备"><a href="#预先准备" class="headerlink" title="预先准备"></a>预先准备</h3><p>Mac系统自带了OpenGL和GLUT，但博主想使用较为新的GLEW和GLFW。<br>安装homebrew</p>
<pre><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre><h4 id="安装GLEW和GLFW"><a href="#安装GLEW和GLFW" class="headerlink" title="安装GLEW和GLFW"></a>安装GLEW和GLFW</h4><pre><code>brew install glew
brew install glfw</code></pre><p>brew安装的目录在/usr/local/Cellar下，后面会使用到路径。</p>
<h4 id="安装GLAD"><a href="#安装GLAD" class="headerlink" title="安装GLAD"></a>安装GLAD</h4><p>GLAD是一个开源的库，它能解决我们上面提到的那个繁琐的问题。GLAD的配置与大多数的开源库有些许的不同，GLAD使用了一个在线服务。在这里我们能够告诉GLAD需要定义的OpenGL版本，并且根据这个版本加载所有相关的OpenGL函数。</p>
<p>打开GLAD的<a href="http://glad.dav1d.de/" target="_blank" rel="noopener">在线服务</a>，将语言(Language)设置为C/C++，在API选项中，选择3.3以上的OpenGL(gl)版本。之后将模式(Profile)设置为Core，并且保证生成加载器(Generate a loader)的选项是选中的。现在可以先（暂时）忽略拓展(Extensions)中的内容。都选择完之后，点击生成(Generate)按钮来生成库文件。</p>
<p><img src="https://tanwenbo.top/wp-content/uploads/2018/09/15363877738992.jpg" alt="">￼</p>
<h4 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h4><p><img src="https://tanwenbo.top/wp-content/uploads/2018/09/15363878164832.jpg" alt="">￼</p>
<p>GLAD现在应该提供给你了一个zip压缩文件，包含两个头文件目录，和一个glad.c文件。将两个头文件目录（glad和KHR）复制到你的Include文件夹中（或者增加一个额外的项目指向这些目录），并添加glad.c文件到你的工程中。</p>
<h4 id="用Clion创建工程"><a href="#用Clion创建工程" class="headerlink" title="用Clion创建工程"></a>用Clion创建工程</h4><p>Clion工程管理是通过CMake的，第三方库可以通过修改CMakeLists.txt完成<br>以下是博主参考了资料后配置成功的文件</p>
<pre><code>cmake_minimum_required(VERSION 3.12)
project(Learn-OpenGL)

set(CMAKE_CXX_STANDARD 14)
# 添加头文件
set(GLEW_H /usr/local/Cellar/glew/2.1.0/include/GL)
set(GLFW_H /usr/local/Cellar/glfw/3.2.1/include/GLFW)
set(GLAD_H /usr/local/include/glad)
include_directories(${GLEW_H} ${GLFW_H} ${GLAD_H})

# 添加目标链接
set(GLEW_LINK /usr/local/Cellar/glew/2.1.0/lib/libGLEW.2.1.dylib)
set(GLFW_LINK /usr/local/Cellar/glfw/3.2.1/lib/libglfw.3.dylib)
link_libraries(${OPENGL} ${GLEW_LINK} ${GLFW_LINK})

# 执行编译命令
# 这个glad.c随意你放在哪，要注意路径就好
set(SOURCE_FILES &quot;src/glad.c&quot; &quot;main.c&quot;)
add_executable(Learn-OpenGL ${SOURCE_FILES})
if (APPLE)
    target_link_libraries(Learn-OpenGL &quot;-framework OpenGL&quot;)
    target_link_libraries(Learn-OpenGL &quot;-framework GLUT&quot;)
endif()</code></pre><p>测试<br>main.cpp还是使用之前的的代码测试</p>
<blockquote>
<p>你可以选择用glew和glad，除了头文件要替换，一些函数声明也需要替换。<br>这里还是参考博主的用的glew。</p>
</blockquote>
<pre><code>#include &lt;GL/glew.h&gt;
#include &lt;GLFW/glfw3.h&gt;
#include &lt;iostream&gt;
using namespace std;

void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)
{
    //如果按下ESC，把windowShouldClose设置为True，外面的循环会关闭应用
    if(key==GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)
        glfwSetWindowShouldClose(window, GL_TRUE);
    std::cout&lt;&lt;&quot;ESC&quot;&lt;&lt;mode;
}

int main(void)
{
    //初始化GLFW库
    if(!glfwInit())
        return -1;
    //创建窗口以及上下文
    GLFWwindow* window = glfwCreateWindow(640, 480, &quot;hello world&quot;, NULL, NULL);
    if(!window)
    {
        //创建失败会返回NULL
        glfwTerminate();
    }
    //建立当前窗口的上下文
    glfwMakeContextCurrent(window);

    glfwSetKeyCallback(window, key_callback); //注册回调函数
    //循环，直到用户关闭窗口
    while(!glfwWindowShouldClose(window))
    {
        /*******轮询事件*******/
        glfwPollEvents();

        /*******渲染*******/
        //选择清空的颜色RGBA
        glClearColor(0.2, 0.3, 0.3, 1);
        glClear(GL_COLOR_BUFFER_BIT);

        //开始画一个三角形
        glBegin(GL_TRIANGLES);
        glColor3f(1, 0, 0); //Red
        glVertex3f(0, 1, 1);

        glColor3f(0, 1, 0); //Green
        glVertex3f(-1, -1, 0);

        glColor3f(0, 0, 1); //Blue
        glVertex3f(1, -1, 0);
        //结束一个画图步骤
        glEnd();

        glBegin(GL_POLYGON);
        //再画个梯形，需要注意笔顺
        glColor3f(0.5, 0.5, 0.5); //Grey
        glVertex2d(0.5, 0.5);
        glVertex2d(1, 1);
        glVertex2d(1, 0);
        glVertex2d(0.5, 0);
        glEnd();


        /******交换缓冲区，更新window上的内容******/
        glfwSwapBuffers(window);
    }
    glfwTerminate();
    return 0;
}</code></pre><p>运行结果<br><img src="https://tanwenbo.top/wp-content/uploads/2018/09/15363879777641.jpg" alt="">￼</p>
<p>再次成功！可以愉快地和队友写大程了~</p>
<h2 id="错误的地方"><a href="#错误的地方" class="headerlink" title="错误的地方"></a>错误的地方</h2><p>主要是改了几个地方，原来该博主的文章和代码不能直接运行，会报以下错误！</p>
<pre><code>Undefined symbols for architecture x86_64:
  &quot;_glBegin&quot;, referenced from:
      _main in main.cpp.o
  &quot;_glClear&quot;, referenced from:
      _main in main.cpp.o
  &quot;_glClearColor&quot;, referenced from:
      _main in main.cpp.o
  &quot;_glColor3f&quot;, referenced from:
      _main in main.cpp.o
  &quot;_glEnd&quot;, referenced from:
      _main in main.cpp.o
  &quot;_glVertex2d&quot;, referenced from:
      _main in main.cpp.o
  &quot;_glVertex3f&quot;, referenced from:
      _main in main.cpp.o
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
make[3]: *** [OpenGL_Demo] Error 1
make[2]: *** [CMakeFiles/OpenGL_Demo.dir/all] Error 2
make[1]: *** [CMakeFiles/OpenGL_Demo.dir/rule] Error 2</code></pre><p>需要在CMakeLists.txt上加入上面那个：</p>
<pre><code>if (APPLE)
    target_link_libraries(OpenGL_Demo &quot;-framework OpenGL&quot;)
endif()</code></pre><p>还有头文件也有问题，原来的是：</p>
<pre><code>#include&lt;GLEW/glew.h&gt;</code></pre><p>应该改为：</p>
<pre><code>#include &lt;GL/glew.h&gt;</code></pre><p>不得不说，这个cmake比xcode配置容易多了，学习cmake十分有必要！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/08/opengl-learn-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/08/opengl-learn-2/" class="post-title-link" itemprop="url">OpenGL学习笔记第2篇——开始</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-08 10:25:06" itemprop="dateCreated datePublished" datetime="2018-09-08T10:25:06+08:00">2018-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/" itemprop="url" rel="index"><span itemprop="name">OpenGL</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">教程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>昨天搞了一下这个基本准备，现在开始写第一个Demo。<br>因为我用的是glew，所以和网站上的代码还是有点不一样的。</p>
<h2 id="0-代码结构"><a href="#0-代码结构" class="headerlink" title="0 代码结构"></a>0 代码结构</h2><p>既然是跟着课程学习的，那么必要的规范还是要做的，比如这个代码可以根据目录来分类，然后依次做好层次关系。</p>
<p><img src="https://tanwenbo.top/wp-content/uploads/2018/09/15363736319358.jpg" alt="">￼</p>
<p>主要是这个目录，但是这个main函数的调用有点问题，需要单独处理一下。</p>
<blockquote>
<p>直接在source那里去除就好了，只留下一个main</p>
<pre><code>set(SOURCE_FILES &quot;src/1.start/1.1.helloWindow/helloWindow.cpp&quot;)</code></pre></blockquote>
<h2 id="1-Demo"><a href="#1-Demo" class="headerlink" title="1 Demo"></a>1 Demo</h2><p>教程上的第一个Demo，要注意头文件的包含，一定要glew在glfw之前。</p>
<blockquote>
<p>书上的是glad在glfw之前。<br>还是用glad吧，跟着潮流走。<br>具体配置可见<a href="https://tanwenbo.top/course/mac-shi-yongclion-pei-zhiopenglglewgladglfw.html" target="_blank" rel="noopener">Mac使用Clion配置OpenGL(glew,glad,glfw)</a></p>
</blockquote>
<pre><code>int main()
{
    //初始化
    glfwInit();
    //配置GLFW，第一个参数代表选项的名称，第二个是设置的值。
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    //苹果系统需要去除这个注释
#ifdef __APPLE__
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // uncomment this statement to fix compilation on OS X
#endif
    return 0;
}</code></pre><p>一些基本的东西，需要注意一些差别。</p>
<blockquote>
<p>感觉和QT有点像啊，都是一些窗口绑定的操作。</p>
</blockquote>
<h2 id="2-创建窗口"><a href="#2-创建窗口" class="headerlink" title="2 创建窗口"></a>2 创建窗口</h2><pre><code>GLFWwindow* window = glfwCreateWindow(800, 600, &quot;LearnOpenGL&quot;, NULL, NULL);
if (window == NULL)
{
    std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl;
    glfwTerminate();
    return -1;
}
glfwMakeContextCurrent(window);</code></pre><p>就是初始化一个window，然后设置它的长宽和标题。然后glfw调用这个window</p>
<h2 id="3-GLAD"><a href="#3-GLAD" class="headerlink" title="3 GLAD"></a>3 GLAD</h2><p>一开始有说如果需要调用OpenGL的函数需要定义函数原型，然后找到正确的函数并赋值给函数指针，这个时候才可以调用函数。</p>
<pre><code>// 定义函数原型
typedef void (*GL_GENBUFFERS) (GLsizei, GLuint*);
// 找到正确的函数并赋值给函数指针
GL_GENBUFFERS glGenBuffers  = (GL_GENBUFFERS)wglGetProcAddress(&quot;glGenBuffers&quot;);
// 现在函数可以被正常调用了
GLuint buffer;
glGenBuffers(1, &amp;buffer);</code></pre><p>这个时候调用十分复杂，有点像之前C陷阱里的定义void函数返回类型。</p>
<h2 id="4-视角"><a href="#4-视角" class="headerlink" title="4 视角"></a>4 视角</h2><p>在渲染的时候需要告诉OpenGL窗口的尺寸大小，不设置的话当你拉伸这个窗口大小的时候坐标不会对应变大，因为在定义的时候被固定了大小。</p>
<p>调用<code>glViewport</code>函数来设置窗口的维度（Dimension）</p>
<pre><code>glViewport(0, 0, 800, 600);</code></pre><h2 id="5-回调函数"><a href="#5-回调函数" class="headerlink" title="5 回调函数"></a>5 回调函数</h2><p>那么怎么动态调整呢？这里用到了<a href="https://baike.baidu.com/item/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">回调函数</a>，将窗口和回调函数绑定，当窗口变化的时候自动调用回调函数。</p>
<pre><code>void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
    glViewport(0, 0, width, height);
}</code></pre><p>我们还需要注册这个函数，告诉GLFW我们希望每当窗口调整大小的时候调用这个函数：</p>
<pre><code>glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</code></pre><blockquote>
<p>有点像qt的信号槽，估计信号槽也就是一种回调函数。</p>
</blockquote>
<h3 id="5-1-注册函数"><a href="#5-1-注册函数" class="headerlink" title="5.1 注册函数"></a>5.1 注册函数</h3><p>可以看一下具体的实现，GLFW源码：</p>
<pre><code>GLFWAPI GLFWframebuffersizefun glfwSetFramebufferSizeCallback(GLFWwindow* handle,
                                                              GLFWframebuffersizefun cbfun)
{
    _GLFWwindow* window = (_GLFWwindow*) handle;
    assert(window != NULL);

    _GLFW_REQUIRE_INIT_OR_RETURN(NULL);
    _GLFW_SWAP_POINTERS(window-&gt;callbacks.fbsize, cbfun);
    return cbfun;
}</code></pre><p>可以看到传入和返回的函数都是同一种类型，该函数的主要功能就是交换了window指针的fbsize功能，替换为了我们注册的<code>cbfun</code>。</p>
<pre><code>_GLFW_SWAP_POINTERS(window-&gt;callbacks.fbsize, cbfun);</code></pre><h3 id="5-2-封装"><a href="#5-2-封装" class="headerlink" title="5.2 封装"></a>5.2 封装</h3><pre><code>void _glfwInputFramebufferSize(_GLFWwindow* window, int width, int height)
{
    if (window-&gt;callbacks.fbsize)
        window-&gt;callbacks.fbsize((GLFWwindow*) window, width, height);
}</code></pre><p>这里简单地封装了一下，调用了<code>window-&gt;callbacks.fbsize</code>所指向的函数，这里也就是我们的<code>framebuffer_size_callback()</code>。</p>
<h3 id="5-3-调用"><a href="#5-3-调用" class="headerlink" title="5.3 调用"></a>5.3 调用</h3><pre><code>_glfwInputFramebufferSize(window, LOWORD(lParam), HIWORD(lParam));</code></pre><p>当检测到窗口产生了大小变化时，调用了<code>_glfwInputFramebufferSize()</code>，将对应窗口宽高的参数传了进去。</p>
<blockquote>
<p>以上内容来自评论。</p>
</blockquote>
<h2 id="6-循环"><a href="#6-循环" class="headerlink" title="6 循环"></a>6 循环</h2><p>没有加入循环的代码就像一般的控制台程序，运行完结果后就直接关闭了。那么为了直观的观察绘制出来的程序，我们需要在主动关闭其之前不断绘制图像并能够接受用户输入。</p>
<p>因此，我们需要在程序中添加一个while循环，我们可以把它称之为渲染循环(Render Loop)，它能在我们让GLFW退出前一直保持运行。下面几行的代码就实现了一个简单的渲染循环：</p>
<pre><code>while(!glfwWindowShouldClose(window))
{
    glfwSwapBuffers(window);
    glfwPollEvents();    
}</code></pre><ul>
<li><code>glfwWindowShouldClose</code>函数在我们每次循环的开始前检查一次GLFW是否被要求退出，如果是的话该函数返回true然后渲染循环便结束了，之后为我们就可以关闭应用程序了。</li>
<li><code>glfwPollEvents</code>函数检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数（可以通过回调方法手动设置）。</li>
<li><code>glfwSwapBuffers</code>函数会交换颜色缓冲（它是一个储存着GLFW窗口每一个像素颜色值的大缓冲），它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。</li>
</ul>
<h2 id="7-释放"><a href="#7-释放" class="headerlink" title="7 释放"></a>7 释放</h2><p>和分配内存一样，渲染结束后应该正确释放之前分配的所有资源，在main函数的最后调用<code>glfwTerminate</code>函数来完成。</p>
<pre><code>glfwTerminate();
return 0; </code></pre><h2 id="8-运行"><a href="#8-运行" class="headerlink" title="8 运行"></a>8 运行</h2><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code>// Created by 谭文波 on 2018/9/8.
#include &lt;glad/glad.h&gt;
#include &lt;GLFW/glfw3.h&gt;

#include &lt;iostream&gt;

void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void processInput(GLFWwindow *window);

// settings
const unsigned int SCR_WIDTH = 800;
const unsigned int SCR_HEIGHT = 600;

int main()
{
    // glfw: initialize and configure
    // ------------------------------
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

#ifdef __APPLE__
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // uncomment this statement to fix compilation on OS X
#endif

    // glfw window creation
    // --------------------
    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, &quot;LearnOpenGL&quot;, NULL, NULL);
    if (window == NULL)
    {
        std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl;
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

    // glad: load all OpenGL function pointers
    // ---------------------------------------
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    {
        std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl;
        return -1;
    }

    // render loop
    // -----------
    while (!glfwWindowShouldClose(window))
    {
        // input
        // -----
        processInput(window);

        // render
        // ------
        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);

        // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)
        // -------------------------------------------------------------------------------
        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    // glfw: terminate, clearing all previously allocated GLFW resources.
    // ------------------------------------------------------------------
    glfwTerminate();
    return 0;
}

// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly
// ---------------------------------------------------------------------------------------------------------
void processInput(GLFWwindow *window)
{
    //退出键esc关闭窗口
    if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
        glfwSetWindowShouldClose(window, true);
}

// glfw: whenever the window size changed (by OS or user resize) this callback function executes
// ---------------------------------------------------------------------------------------------
//回调函数
void framebuffer_size_callback(GLFWwindow* wind
ow, int width, int height)
{
    // make sure the viewport matches the new window dimensions; note that width and
    // height will be significantly larger than specified on retina displays.
    glViewport(0, 0, width, height);
}</code></pre><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://tanwenbo.top/wp-content/uploads/2018/09/15363906099951.jpg" alt="">￼</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/07/opengl-glew-glfw/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/07/opengl-glew-glfw/" class="post-title-link" itemprop="url">OpenGL中的GLEW和GLFW简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-07 19:21:47" itemprop="dateCreated datePublished" datetime="2018-09-07T19:21:47+08:00">2018-09-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/" itemprop="url" rel="index"><span itemprop="name">OpenGL</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">教程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><p>最近在用Mac下编译OpenGL相关的Demo，但是很多麻烦。比如这个glut的库在Mac OS 10.9版本已经废弃，然后很多老代码都编译不了用不了。</p>
<p>后来发现了这个glew和glfw这两个库，说是可以代替这个glut和gl，但是看资料看了半天也不知道这两个库到底是干嘛的。在搜索了一些相关资料后，决定自己整理一下。</p>
<p>目前需要解决的几个难点：</p>
<h4 id="老代码迁移"><a href="#老代码迁移" class="headerlink" title="老代码迁移"></a>老代码迁移</h4><p>以前用glut写的代码如何用glew和glfw迁移，是不能直接换函数名的，有些函数不是一一对应的。</p>
<p>比如这种：</p>
<p><img src="https://tanwenbo.top/wp-content/uploads/2018/09/15363203630682.jpg" alt="">￼</p>
<blockquote>
<p>编译器用的是Mac下的CLion。</p>
</blockquote>
<p>有些函数是不存在的，那么现在需要将其替换成glew和glfw里的函数。</p>
<h2 id="1-GLEW"><a href="#1-GLEW" class="headerlink" title="1 GLEW"></a>1 GLEW</h2><p>主要介绍一下这个库的作用以及相关函数。</p>
<h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><blockquote>
<p>OpenGL扩展库是个简单的工具，用于帮助C/C++开发者初始化扩展（OpenGL扩展功能）并书写可移植的应用程序。GLEW当前支持各种各样的操作系统，包含Windows，Linux，Darwin，Irix与Solaris。</p>
<p>from 百度百科</p>
</blockquote>
<p>可以看到这个库主要是实现可移植性，因为不同平台的OpenGL库函数可能不一样，然后该库提供了一个功能：</p>
<p><strong>能自动识别当前平台所支持的全部OpenGL高级扩展涵数。只要包含glew.h头文件，就能使用gl,glu,glext,wgl,glx的全部函数。</strong></p>
<p>也就是说只要用这个库，然后你写的代码在不同平台就能直接编译，不需要再做特殊处理。</p>
<blockquote>
<p>具体是不是以后有待验证。</p>
</blockquote>
<h2 id="2-GLFW"><a href="#2-GLFW" class="headerlink" title="2 GLFW"></a>2 GLFW</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><blockquote>
<p><strong>GLFW</strong> 是配合 <a href="https://zh.wikipedia.org/wiki/OpenGL" target="_blank" rel="noopener">OpenGL</a> 使用的轻量级工具程序库，缩写自 <strong>G</strong>raphics <strong>L</strong>ibrary <strong>F</strong>rame<strong>w</strong>ork（图形库框架）。GLFW 的主要功能是创建并管理窗口和 OpenGL 上下文，同时还提供了处理<a href="https://zh.wikipedia.org/wiki/%E6%89%8B%E6%9F%84" target="_blank" rel="noopener">手柄</a>、<a href="https://zh.wikipedia.org/wiki/%E9%94%AE%E7%9B%98" target="_blank" rel="noopener">键盘</a>、<a href="https://zh.wikipedia.org/wiki/%E9%BC%A0%E6%A0%87" target="_blank" rel="noopener">鼠标</a>输入的功能。</p>
<p>from wiki</p>
</blockquote>
<p>看起来好像是一个框架，与上面的GLEW相辅相成。这个库也算是GLUT的新版本，这两个库之间的区别之一就在于 GLFW 更加先进而且有活力，但是GLUT则显得比较老旧，而且它的开发维护现在也基本上停滞了。所以可以直接用GLFW<strong>代替</strong>GLUT。</p>
<h3 id="2-2-区别"><a href="#2-2-区别" class="headerlink" title="2.2 区别"></a>2.2 区别</h3><p>有些区别和GLUT不一样的地方，比如这个初始化。</p>
<h4 id="GLUT"><a href="#GLUT" class="headerlink" title="GLUT"></a>GLUT</h4><pre><code>glutInit(&amp;argc, argv);      </code></pre><h4 id="GLFW"><a href="#GLFW" class="headerlink" title="GLFW"></a>GLFW</h4><pre><code>glfwInit();</code></pre><p>其实就是少了参数，其他的差别就不一一列举了。​</p>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><p>总的来说学习OpenGL使用这两个库足以满足所有需求，且可移植性也很强！</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://wiki.jikexueyuan.com/project/modern-opengl-tutorial/tutorial44.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/modern-opengl-tutorial/tutorial44.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/07/opengl-learn-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/07/opengl-learn-1/" class="post-title-link" itemprop="url">OpenGL学习笔记第1篇——准备</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-07 16:38:26" itemprop="dateCreated datePublished" datetime="2018-09-07T16:38:26+08:00">2018-09-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenGL/" itemprop="url" rel="index"><span itemprop="name">OpenGL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>为了自己的论文现在需要从头开始学习一下OpenGL，发现了一个很好的网站<a href="https://learnopengl-cn.github.io/" target="_blank" rel="noopener">LearnOpenGL中文版</a>，其原版就是<a href="https://learnopengl.com/" target="_blank" rel="noopener">LearnOpenGL</a>。为了进度，还是选择看中文版（太菜）。</p>
</blockquote>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h2><p>基本的概念就不说了，做笔记也不是做教程，只写一下自己需要的东西。</p>
<h2 id="1-对象"><a href="#1-对象" class="headerlink" title="1 对象"></a>1 对象</h2><p>这个东西有点意思，因为本来OpenGL就是用C语言写的，但是也会有个<strong>对象</strong>的概念。</p>
<p>在OpenGL中一个对象是指一些选项的集合，它代表OpenGL状态的一个子集。比如，我们可以用一个对象来代表绘图窗口的设置，之后我们就可以设置它的大小、支持的颜色位数等等。可以把对象看做一个C风格的结构体(Struct)：</p>
<pre><code>struct object_name {
    float  option1;
    int    option2;
    char[] name;
};</code></pre><p>然后有一些绑定对象的操作：</p>
<pre><code>// 创建对象
unsigned int objectId = 0;
glGenObject(1, &amp;objectId);
// 绑定对象至上下文
glBindObject(GL_WINDOW_TARGET, objectId);
// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项
glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, 800);
glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600);
// 将上下文对象设回默认
glBindObject(GL_WINDOW_TARGET, 0);</code></pre><p>这一小段代码展现了你以后使用OpenGL时常见的工作流。我们首先创建一个对象，然后用一个id保存它的引用（实际数据被储存在后台）。然后我们将对象绑定至上下文的目标位置（例子中窗口对象目标的位置被定义成GL_WINDOW_TARGET）。接下来我们设置窗口的选项。最后我们将目标位置的对象id设回0，解绑这个对象。设置的选项将被保存在objectId所引用的对象中，一旦我们重新绑定这个对象到GL_WINDOW_TARGET位置，这些选项就会重新生效。</p>
<h2 id="2-GLAD"><a href="#2-GLAD" class="headerlink" title="2 GLAD"></a>2 GLAD</h2><blockquote>
<p>跟着这个网站学习的原因主要是其用的东西都是比较先进的，比如GLFW和CMake等工具，但是也有一些特别的工具。</p>
</blockquote>
<p>这里用到了一个工具<code>GLAD</code>，好像没听过啊，只听过GLFW和GLEW。</p>
<p>GLAD用来解决函数位置无法再编译时确定的问题，不同驱动的位置无法确定，所以需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。</p>
<blockquote>
<p>具体来说就是不同的显卡驱动有不同的OpenGL实现，所以需要用GLAD来隐藏这些差别，达到无差别使用体验。</p>
</blockquote>
<p>而且这是一个<a href="https://glad.dav1d.de/" target="_blank" rel="noopener">在线服务</a>，也就是说需要在网上去生成，感觉有点鸡肋啊。</p>
<h2 id="3-其他准备"><a href="#3-其他准备" class="headerlink" title="3 其他准备"></a>3 其他准备</h2><p>如果你是Mac用户，那么可以参考一下使用GLFW和GLEW的组合，再配合CLion来学习OpenGL。具体的可以参考我的博文<a href="https://tanwenbo.top/course/mac%E4%BD%BF%E7%94%A8clion%E9%85%8D%E7%BD%AEopengl-2.html" target="_blank" rel="noopener">Mac使用CLion配置OpenGL</a>。</p>
<p>之所以不推荐用xcode，个人觉得配置过于复杂且可移植性很差。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/25/mac-e9-85-8d-e7-bd-aeiterm2-e5-ae-9e-e7-8e-b0mosh-e8-87-aa-e5-8a-a8-e8-bf-9c-e7-a8-8b-e8-bf-9e-e6-8e-a5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/25/mac-e9-85-8d-e7-bd-aeiterm2-e5-ae-9e-e7-8e-b0mosh-e8-87-aa-e5-8a-a8-e8-bf-9c-e7-a8-8b-e8-bf-9e-e6-8e-a5/" class="post-title-link" itemprop="url">Mac配置iTerm2实现mosh自动远程连接</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-25 01:43:20" itemprop="dateCreated datePublished" datetime="2018-08-25T01:43:20+08:00">2018-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">教程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>其实网上教程也挺多的，但是用起来总是不那么方便，还遇到了一些bug。现在就总结几个问题再输出一下！</p>
</blockquote>
<h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1 准备"></a>1 准备</h2><p>首先创建一个ssh秘钥是最方便的，这样就不用输入密码，不过用了该功能也没必要了，直接用就是的。</p>
<h3 id="1-1-安装expect"><a href="#1-1-安装expect" class="headerlink" title="1.1 安装expect"></a>1.1 安装expect</h3><p>首先确保你的mac安装了expect，这个是一个自动化执行脚本，可以输入一些普通shell脚本做不到的东西，需要人工操作的。比如<code>回车确认</code>等等。</p>
<pre><code>brew install expect</code></pre><p>如果你brew都没装那可以出门右转了。</p>
<h3 id="1-2-安装mosh"><a href="#1-2-安装mosh" class="headerlink" title="1.2 安装mosh"></a>1.2 安装mosh</h3><blockquote>
<p>你也可以不装，只使用ssh连接，那么直接跳过这里。</p>
</blockquote>
<p>这个是什么呢？就是用来解决ssh卡顿的，因为默认的是键盘每输入一个字符就要向服务器发送一个字节，这样就会大大增加传输次数，也会增加延迟。</p>
<blockquote>
<p>mosh 是一个替代SSH的免费软件，它最大的特点是支持网络漫游和间歇性连接。</p>
<ul>
<li>会话的中断不会导致当前正在前端执行的命令中断，相当于你所有的操作都是在screen命令中一样在后台执行</li>
<li>会话在中断过后，不会立刻退出，而是启用一个计时器，当网络恢复后会自动重新连接，同时会延续之前的会话，不会重新开启一个</li>
</ul>
</blockquote>
<pre><code>brew install mosh</code></pre><p>目前只是客户端mac安装了，服务器端也要安装。如果是Ubuntu的话用如下命令：</p>
<pre><code>sudo apt-get install mosh</code></pre><blockquote>
<p>看到这里你可能觉得有点复杂，但是一劳永逸，亲测延迟要降低很多！</p>
</blockquote>
<p>然后运行<code>mosh-server</code></p>
<pre><code>mosh-server</code></pre><p>这个时候<code>mosh-server</code>可能绑定的是<code>60001</code>端口，可以自己看一下</p>
<pre><code>netstat -anp | grep mosh</code></pre><p><img src="https://tanwenbo.top/wp-content/uploads/2018/08/ede2d90db1e0d03d5731a8f07f113a16.png" alt="">像我是阿里云的服务器，可能就要到安全组里开通60001的udp端口，具体怎么设置相信你可以百度得到。</p>
<p>如果提示错误：</p>
<pre><code>The locale requested by LC_ALL=zh_CN.UTF-8 isn&apos;t available here.Running `locale-gen zh_CN.UTF-8&apos; may be necessary.mosh-server needs a UTF-8 native locale to run.Unfortunately, the local environment (LC_ALL=zh_CN.UTF-8) specifiesthe character set &quot;US-ASCII&quot;,The client-supplied environment ([no charset variables]) specifiesthe character set &quot;US-ASCII&quot;.LANG=LANGUAGE=LC_CTYPE=&quot;POSIX&quot;LC_NUMERIC=&quot;POSIX&quot;LC_TIME=&quot;POSIX&quot;LC_COLLATE=&quot;POSIX&quot;LC_MONETARY=&quot;POSIX&quot;LC_MESSAGES=&quot;POSIX&quot;LC_PAPER=&quot;POSIX&quot;LC_NAME=&quot;POSIX&quot;LC_ADDRESS=&quot;POSIX&quot;LC_TELEPHONE=&quot;POSIX&quot;LC_MEASUREMENT=&quot;POSIX&quot;LC_IDENTIFICATION=&quot;POSIX&quot;LC_ALL=</code></pre><p>那么可能是你的服务器没有设置中文的utf-8，执行以下命令：</p>
<pre><code>sudo apt-get -y install language-pack-zh-hans</code></pre><p>如果弹出</p>
<pre><code>MOSH CONNECT 60001 /tnUTZ/3MIU0uF1Qlk0K6Amosh-server (mosh 1.2.5) [build mosh 1.2.5]Copyright 2012 Keith Winstein &lt;mosh-devel@mit.edu&gt;License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;.This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.</code></pre><p>那么就意味着运行成功了。</p>
<h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2 配置"></a>2 配置</h2><p>准备操作已完成，那么就进行配置了。</p>
<h3 id="2-1-脚本"><a href="#2-1-脚本" class="headerlink" title="2.1 脚本"></a>2.1 脚本</h3><p>首先利用expect在<code>/usr/local/bin/</code>下面写一个脚本login.exp，并加上执行权限：</p>
<pre><code>chmod +x login.exp</code></pre><p>login.exp</p>
<h4 id="使用mosh"><a href="#使用mosh" class="headerlink" title="使用mosh"></a>使用mosh</h4><pre><code>#!/usr/bin/expectset timeout 30spawn mosh -p 60001 [lindex $argv 0]@[lindex $argv 1]expect {    &quot;(yes/no)?&quot;    {send &quot;yes\n&quot;;exp_continue}    &quot;password:&quot;    {send &quot;[lindex $argv 2]\n&quot;}}interact</code></pre><h4 id="使用ssh"><a href="#使用ssh" class="headerlink" title="使用ssh"></a>使用ssh</h4><pre><code>#!/usr/bin/expectset timeout 30spawn ssh [lindex $argv 0]@[lindex $argv 1]expect {    &quot;(yes/no)?&quot;    {send &quot;yes\n&quot;;exp_continue}    &quot;password:&quot;    {send &quot;[lindex $argv 2]\n&quot;}}interact</code></pre><h3 id="2-2-iTerm2配置"><a href="#2-2-iTerm2配置" class="headerlink" title="2.2 iTerm2配置"></a>2.2 iTerm2配置</h3><p>可以直接按快捷键<code>command + ,</code>，或者在iTerm2设置里打开<code>preference</code>，点开Profiles，然后在<code>Genernal-&gt;Command</code>下选择 <code>Login shell</code>，在输入框里填入相关信息，用空格隔开，如果有特殊字符需要用<code>单引号</code>隔开。<img src="https://tanwenbo.top/wp-content/uploads/2018/08/d8505f803d54077b18d5081ec6e5d4fb.png" alt=""></p>
<p>你还可以自己加一个快捷键<img src="https://tanwenbo.top/wp-content/uploads/2018/08/3bed11ccee9fdadaa9ec896542437097.png" alt=""></p>
<h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3 使用"></a>3 使用</h2><p>使用快捷键一键登录！享受mosh带来的低延迟吧！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tanwenbo</p>
  <div class="site-description" itemprop="description">enjoy share</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">112</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tanwenbo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
