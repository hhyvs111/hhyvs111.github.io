<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="enjoy share">
<meta property="og:type" content="website">
<meta property="og:title" content="hhyvs111">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="hhyvs111">
<meta property="og:description" content="enjoy share">
<meta property="article:author" content="tanwenbo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>hhyvs111</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hhyvs111</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Be a great man</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/23/io-e5-ba-93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/23/io-e5-ba-93/" class="post-title-link" itemprop="url">IO库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-23 09:16:58" itemprop="dateCreated datePublished" datetime="2019-01-23T09:16:58+08:00">2019-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h1><ul>
<li><p>IO库</p>
</li>
<li><p>头文件</p>
</li>
<li><p>IO对象无赋值拷贝</p>
</li>
<li><p>管理输出缓冲</p>
<ul>
<li>缓冲刷新的原因</li>
<li>endl</li>
</ul>
</li>
<li><p>文件输入输出</p>
<ul>
<li>使用文件流对象</li>
</ul>
</li>
<li><p>string流</p>
<ul>
<li>istringstream</li>
<li>ostringstream</li>
</ul>
</li>
</ul>
<p>C++语言不直接处理输入输出，而是通过一族定义在标准库中的类型来处理IO。这些类型支持从设备读取数据、向设备写入数据的IO操作，设备可以是文件、控制台窗口等。还有一些类型允许内存IO,即从string读取数据，向string写入数据。</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>头文件</p>
<p>类型</p>
<p>iostream</p>
<p>读写流</p>
<p>fstream</p>
<p>读写文件</p>
<p>sstream</p>
<p>读写string</p>
<h2 id="IO对象无赋值拷贝"><a href="#IO对象无赋值拷贝" class="headerlink" title="IO对象无赋值拷贝"></a>IO对象无赋值拷贝</h2><p>不能拷贝或对IO对象赋值:</p>
<pre><code>ofstream out1，out2 ;
out1 = out2;
//错误:不能对流对象赋值
ofstream print (ofstream) ;
//错误:不能初始化ofstream参数
out2 = print (out2) ;
//错误:不能拷贝流对象</code></pre><p>由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以<strong>引用方式</strong>传递和返回流。读写一个I0对象会改变其状态，因此传递和返回的引用<strong>不能</strong>是const的。</p>
<h2 id="管理输出缓冲"><a href="#管理输出缓冲" class="headerlink" title="管理输出缓冲"></a>管理输出缓冲</h2><p>每个输出流都管理一个缓冲区，用来保存程序读写的数据。例如，如果执行下面的代码</p>
<pre><code>OS &lt;&lt; &quot;please enter a value: &quot;;</code></pre><p>文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。</p>
<h4 id="缓冲刷新的原因"><a href="#缓冲刷新的原因" class="headerlink" title="缓冲刷新的原因"></a>缓冲刷新的原因</h4><p>导致缓冲刷新的原因有很多：</p>
<ul>
<li>程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行；</li>
<li>缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。</li>
<li>我们可以使用操纵符如endl (参见1.2节，第6页)来显式刷新缓冲区。</li>
<li>在每个输出操作之后，我们可以用操纵符unitbuf设置流的内部状态，来清空冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的</li>
<li>一个输出流可能被关联到另-一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin和cerr都关联到cout。因此，读cin或写cerr都会导致cout的缓冲区被刷新。</li>
</ul>
<h4 id="endl"><a href="#endl" class="headerlink" title="endl"></a>endl</h4><p>我们已经使用过操纵符endl,它完成换行并刷新缓冲区的工作。I0库中还有两个类似的操纵符: flush和ends。flush刷新缓冲区，但不输出任何额外的字符: ends向缓冲区插入一个空字符，然后刷新缓冲区:</p>
<pre><code>cout &lt;&lt; &quot;hi!&quot; &lt;&lt; endl; //输出hi和一个换行，然后刷新缓冲区
cout &lt;&lt; &quot;hi!&quot; &lt;&lt; flush; // 输出hi,然后刷新缓冲区，不附加任何额外字符
cout &lt;&lt; &quot;hi!&quot; &lt;&lt; ends ;//输出hi和一个空字符，然后刷新缓冲区</code></pre><h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><blockquote>
<p>有时候写程序的时候总想要输入输出文件，但是总是不知道怎么弄这个格式。</p>
</blockquote>
<p>头文件fstream定义了三个类型来支持文件IO:ifstream从一.个给定文件读取数据，ofstream向一个给定文件写入数据，以及fstream可以读写给定文件。</p>
<h3 id="使用文件流对象"><a href="#使用文件流对象" class="headerlink" title="使用文件流对象"></a>使用文件流对象</h3><p>创建文件流对象时,我们可以提供文件名(可选的)。如果提供了一个文件名，则open会自动被调用:</p>
<pre><code>ifstream in(ifile) ;
//构造一个ifstream并打开给定文件
ofstream out;
//输出文件流未关联到任何文件</code></pre><p>这段代码定义了一个输入流in，它被初始化为从文件读取数据，文件名由string类型的参数ifile指定。第二条语句定义了一个输出流out，未与任何文件关联。在新C++ 11 标准中，文件名既可以是库类型string对象，也可以是C风格字符数组（“12321”类似这种）。旧版本的标准库只允许C风格字符数组。</p>
<h2 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h2><p>其实IO处理String应该较多，大多都是处理文本数据。这些文本数据都是string组成的。 考虑这样一个例子，假定有一个文件，列出了一些人和他们的电话号码。某些人只有一个号码，而另一些人则有多个一家庭电话、工作电话、移动电话等。我们的输入文件 看起来可能是这样的:</p>
<pre><code>morgan 2015552368 8625550123
drew 9735550130
lee 6095550132 2015550175 8005550000</code></pre><p>文件中每条记录都以一个人名开始，后面跟随- -个或多个电话号码。我们首先定义一个简单的类来描述输入数据:</p>
<pre><code>//成员默认为公有;参见7.2节(第240页)
struct PersonInfo {
    string name ; 
    vector&lt;string&gt; phones;
};</code></pre><h3 id="istringstream"><a href="#istringstream" class="headerlink" title="istringstream"></a>istringstream</h3><p>我们的程序会读取数据文件，并创建-一个PersonInfo的vector. vector中每个元素对应文件中的一条记录。我们在一个循环中处理输入数据，每个循环步读取一条记录，提取出一个人名和若干电话号码:</p>
<pre><code>string line, word;
//分别保存来自输入的一行和单词
vector&lt;PersonInfo&gt; people;
//保存来自输入的所有记录
//逐行从输入读取数据，直至cin遇到文件尾(或其他错误)
while (getline(cin, line) ) {
    PersonInfo info;
    //创建一个保存此记录数据的对象
    istringstream record(line); // 将记录绑定到刚读入的行
    record &gt;&gt; info.name;
    //读取名字
    while (record &gt;&gt; word)
    //读取电话号码
     info.phones.push_back(word) ; //保持它们
    people.push_back(info) ;
//将此记录追加到people末尾
}</code></pre><p>这里我们用getline从标准输入读取整条记录。如果getline调用成功，那么line中将保存着从输入文件而来的一条记录。在while中,我们定义了一个局部PersonInfo对象，来保存当前记录中的数据。 接下来我们将一根istringstream与刚刚读取的文本行进行绑定，这样就可以在此istringstream上使用输入运算符来读取当前记录中的每个元素。</p>
<h3 id="ostringstream"><a href="#ostringstream" class="headerlink" title="ostringstream"></a>ostringstream</h3><p>当我们逐步构造输出，希望最后一起打印时，ostringstream 是很有用的。例如，对上一节的例子,我们可能想逐个验证电话号码并改变其格式。如果所有号码都是有效的,我们希望输出一个新的文件，包含改变格式后的号码。对于那些无效的号码，我们不会将它们输出到新文件中，而是打印一条包含人名和无效号码的错误信息。 由于我们不希望输出有无效电话号码的人，因此对每个人，直到验证完所有电话号码后才可以进行输出操作。但是，我们可以先将输出内容“写入”到一个内存ostringstream中:</p>
<pre><code>for(const auto &amp;entry : people) { //对people中每一项
    ostringstream formatted, badNums; // 每个循环步创建的对象
    for(const auto &amp;nums : entry.phones) { // 对每个数
    if(!valid (nums)) {
    badNums &lt;&lt; &quot; &quot; &lt;&lt; nums; //将数的字符串形式存入badNums i
    }
    else
    {
        //将格式化的字符串“写入”formatted
        formatted &lt;&lt;” ”&lt;&lt; format (nums);
    }
    //打印名字
    if (badNums.str().empty())//没有错误的数
        os &lt;&lt; entry.name &lt;&lt;” ”&lt;&lt; formatted.str() &lt;&lt; endl;
    //和格式化的数
    //否则，打印名字和错误的数
    else
    cerr &lt;&lt; &quot;input error:&quot;&lt;&lt; entry.name &lt;&lt; &quot;invalid number (s) &quot;&lt;&lt; badNums.str() &lt;&lt; endl;
}</code></pre><p>在此程序中，我们假定已有两个函数，valid和format,分别完成电话号码验证和改变格式的功能。程序最有趣的部分是对字符串流formatted和badNums的使用。我们使用标准的输出运算符(&lt;&lt;)向这些对象写入数据,但这些“写入”操作实际上转换为string操作，分别向formatted和badNums中的string对象添加字符。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/21/e5-a7-94-e6-89-98-e6-9e-84-e9-80-a0-e5-87-bd-e6-95-b0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/21/e5-a7-94-e6-89-98-e6-9e-84-e9-80-a0-e5-87-bd-e6-95-b0/" class="post-title-link" itemprop="url">委托构造函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-21 08:02:56" itemprop="dateCreated datePublished" datetime="2019-01-21T08:02:56+08:00">2019-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h1><blockquote>
<p>C++11的新标准，有点牛批的感觉啊</p>
</blockquote>
<ul>
<li>委托构造函数<ul>
<li>定义</li>
</ul>
</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>C++11新标准扩展了构造函数初始值的功能,使得我们可以定义所谓的委托构造函数(delegating constructor)。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些(或者全部)职责委托给了其他构造函数。</p>
<blockquote>
<p>就是让别的构造函数来构造自己。</p>
</blockquote>
<p>和其他构造函数一样，一个委托构造函数也有一个成员初始值的列表和一个函数体。在委托构造函数内，成员初始值列表只有一个唯一的入口，就是类名本身。和其他成员初始值一样，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另外一个构造函数匹配。 举个例子，我们使用委托构造函数重写Sales_data类，重写后的形式如下所示:</p>
<pre><code>class Sales_data {
public:
    //非委托构造函数使用对应的实参初始化成员
    Sales_data(std::string s, unsigned cnt，double price) :bookNo(s)，units_sold(cnt), revenue (cnt*price) {}
    .//其余构造函数全都委托给另一.个构造函数
    Sales_data() : Sales_ data(&quot;&quot;, 0，0) { }
    Sales_data(std::string s) : Sales_data(s, 0,0) { }
    Sales_data(std::istream &amp;is) : Sales_data ()
    { read(is, *this) ; }
    //其他成员与之前的版本一致
};</code></pre><p>在这个Sales_data类中，除了一个构造函数外其他的都委托了它们的工作。第一个构造函数接受三个实参，使用这些实参初始化数据成员，然后结束工作。我们定义默认构造函数令其使用三参数的构造函数完成初始化过程，它也无须执行其他任务，这一点从空的构造函数体能看得出来。接受一个string的构造函数同样委托给了三参数的版本。</p>
<blockquote>
<p>有点像是这个类的继承</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/18/e5-90-ab-e6-9c-89-e5-8f-af-e5-8f-98-e5-bd-a2-e5-8f-82-e7-9a-84-e5-87-bd-e6-95-b0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/18/e5-90-ab-e6-9c-89-e5-8f-af-e5-8f-98-e5-bd-a2-e5-8f-82-e7-9a-84-e5-87-bd-e6-95-b0/" class="post-title-link" itemprop="url">含有可变形参的函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-18 09:21:15" itemprop="dateCreated datePublished" datetime="2019-01-18T09:21:15+08:00">2019-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="含有可变形参的参数"><a href="#含有可变形参的参数" class="headerlink" title="含有可变形参的参数"></a>含有可变形参的参数</h1><p>有时候我们无法提前预知应该向参数传递几个实参，为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法:如果所有的实参类型相同，可以传递一个名为<strong>initializer_list</strong>的标准库类型;如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板，关于它的细节将在16.4节(第618页)介绍。</p>
<blockquote>
<p>就是类似vector，你不知道数组的长度就使用vector。</p>
</blockquote>
<pre><code>void error_msg (initializer_list&lt;string&gt; il)
{
    for (auto beg = il.begin() ; beg != il.end() ; + +beg)
    cout &lt;&lt; *beg&lt;&lt;” ”;
    cout &lt;&lt; endl ;
}</code></pre><blockquote>
<p>这个好像和什么vector没啥区别啊，但是为什么要特别用到呢？</p>
</blockquote>
<p>和vector不一样的是，initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/18/e5-bc-95-e7-94-a8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/18/e5-bc-95-e7-94-a8/" class="post-title-link" itemprop="url">引用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-18 07:46:07" itemprop="dateCreated datePublished" datetime="2019-01-18T07:46:07+08:00">2019-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote>
<p>这个东西用不好就是坑，用好了还是很强的。</p>
</blockquote>
<h2 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h2><p>传参就不说了，主要是避免一个问题——避免拷贝。有些数据较大的对象或者容器，如果传参的时候不用引用的话需要对其进行拷贝，这样的开销较大。应该使用引用值，直接对原数组进行操作，这样避免额外的开销，效率也会更快。</p>
<pre><code>//比如对这个vector容器进行操作的时候，一般都是使用引用值。
vector&lt;int&gt; test(vector&lt;int&gt; &amp; nums)
{
...
}</code></pre><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>有时候并不改变传入的参数的值，那么建议使用<strong>对常量的引用</strong></p>
<pre><code>// 比较两个string的大小
bool isShorter (const string &amp;s1, const string &amp;s2)
[
return s1.size() &lt; s2.size() ;
]</code></pre><blockquote>
<p>如果函数无须改变引用形参的值，最好将其声明为常量引用。</p>
</blockquote>
<h2 id="引用形参返回额外信息"><a href="#引用形参返回额外信息" class="headerlink" title="引用形参返回额外信息"></a>引用形参返回额外信息</h2><p>一个函数只能返回一个值，然而有时候函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效途径。</p>
<p>简单来说就是在传参的时候使用引用值，然后在函数体内改变这个引用的值，也就达到了一次返回多个值。</p>
<pre><code>//返回s中c第一次出现的位置索引
//引用形参occurs负责统计c出现的总次数
string: :size_ type find_ char (const string &amp;S，char C,
string: :size_ type &amp;occurs )
{
auto ret = s.size() ;
//第一次出现的位置(如果有的话)
occurs 
= 0;
//设置表示出现次数的形参的值
for (decltype(ret) i = 0; i != s.size() ; ++i) {
    if (s[i] == c) {
      if (ret == s.size() )
        ret = i;
        . //记录c第一次出现的位置
        ++occurs ;
        . //将出现的次数加1
        }
    }
return ret ;
//出现次数通过occurs隐式地返回
}</code></pre><p>当我们调用find_char函数时，必须传入三个实参:作为查找范围的一个string对象、要找的字符以及一个用于保存字符出现次数的size_ type (参见3.2.2节，第79页)对象。假设s是一个string对象，ctr是一个size_ type对象，则我们通过如下形式调用find char函数:</p>
<pre><code>auto index = find char(s, &apos;o&apos;，ctr) ;</code></pre><p>调用完成后，如果string对象中确实存在o,那么ctr的值就是。出现的次数，index指向。第一次出现的位置;否则如果string对象中没有o，index等于s.size()而ctr等于0。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/18/e5-b1-80-e9-83-a8-e9-9d-99-e6-80-81-e5-af-b9-e8-b1-a1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/18/e5-b1-80-e9-83-a8-e9-9d-99-e6-80-81-e5-af-b9-e8-b1-a1/" class="post-title-link" itemprop="url">局部静态对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-18 07:16:13" itemprop="dateCreated datePublished" datetime="2019-01-18T07:16:13+08:00">2019-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="局部静态对象"><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h1><p>在程序的执行路径第一次经过对象定义局域时初始化，知道程序终止时才被销毁，在此期间即使对象所在的函数结束也不会对它有影响。</p>
<pre><code>size_t count_calls ()
f
static size_t ctr = O; //调用结束后，这个值仍然有效
return ++ctr;
)
int main()
[
for(sizeti=O;i!=10;++i)
cout &lt;&lt; count calls () &lt;&lt; endl ;
return O;
)</code></pre><p>在控制流第一次经过ctr的定义之前，ctr被创建并初始化为0。每次调用将ctr加1并返回新值。每次执行count_calls函数时，变量ctr的值都已经存在并且等于函数上一次退出时ctr的值。因此，第二次调用时ctr的值是1，第三次调用时ctr的值是2，以此类推。</p>
<blockquote>
<p>反正就是静态局部变量初始化后再次调用该函数，crr不会重新初始化，而是继续用上次的值。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/17/try-e8-af-ad-e5-8f-a5-e5-9d-97-e5-92-8c-e5-bc-82-e5-b8-b8-e5-a4-84-e7-90-86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/17/try-e8-af-ad-e5-8f-a5-e5-9d-97-e5-92-8c-e5-bc-82-e5-b8-b8-e5-a4-84-e7-90-86/" class="post-title-link" itemprop="url">try语句块和异常处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-17 08:44:02" itemprop="dateCreated datePublished" datetime="2019-01-17T08:44:02+08:00">2019-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h1><ul>
<li>try语句块和异常处理<ul>
<li>定义<ul>
<li>异常处理方式</li>
</ul>
</li>
<li>throw表达式<ul>
<li>cerr解释</li>
</ul>
</li>
<li>try-catch</li>
<li>标准异常<ul>
<li>定义的异常类</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这个东西一般比较少用到，好像以前在Java里经常用。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。典型的异常包括失去数据库连接以及遇到意外输入等。处理反常行为可能是设计所有系统最难的一部分。</p>
<h3 id="异常处理方式"><a href="#异常处理方式" class="headerlink" title="异常处理方式"></a>异常处理方式</h3><ul>
<li>throw表达式；</li>
<li>try语句块，也就是try-catch。try语句块中代码抛出的异常通常会被磨具个catch子句处理。因为catch子句“处理”异常，所以它们也被称作异常处理代码；</li>
<li>一套异常类。</li>
</ul>
<p>下面详细介绍一下这几种方式。</p>
<h2 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h2><p>一般业务代码中都要处理错误，输出一些信息，这样才能快速定位哪里出错了。比如下面这个代码检查它读入的记录是否是关于同一种书籍，如果不是，输出一条信息然后退出。</p>
<pre><code>Sales_ item item1, item2;
cin &gt;&gt; item1 &gt;&gt; item2;
// 检查 item1 和 item2 是否表示同一种书籍
if(item1.isbn() == item2. isbn()) {
cout &lt;&lt; item1 + item2 &lt;&lt; endl ;
return O; // success
} else {
cerr &lt;&lt; &quot;Data must refer to same ISBN&quot; &lt;&lt; endl ;
//cerr 是一个ostream对象，关联到标准错误，通常写入到与标准输出相同的设备。
return -1; // failed
}</code></pre><h4 id="cerr解释"><a href="#cerr解释" class="headerlink" title="cerr解释"></a>cerr解释</h4><p>cerr不经过缓冲而直接输出，一般用于迅速输出出错信息，是标准错误，默认情况下被关联到标准输出流，但它不被缓冲，也就说错误消息可以直接发送到显示器，而无需等到缓冲区或者新的换行符时，才被显示。一般情况下不被重定向。</p>
<blockquote>
<p>这个东西很少见啊，又学习到了新的知识了。</p>
</blockquote>
<p>接上述代码，在真实的程序中，应该把对象相加的代码和用户交互的代码分离开来。此例中，我们改写程序似的检查完成和惠普不再直接输出一条信息，而是<strong>抛出一个异常</strong>：</p>
<pre><code>//首先检查两条数据是否是关于同一种书籍的
if (iteml. isbn() != item2 . isbn() )
throw runtime_error (&quot;Data must refer to same ISBN&quot;) ;
//如果程序执行到了这里，表示两个ISBN是相同的
cout &lt;&lt; item1 + item2 &lt;&lt; endl ;</code></pre><blockquote>
<p>但是这样做有什么用呢？是给后面的try-catch使用的？</p>
</blockquote>
<h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h2><p>try语句块的一开始是关键字try，随后紧跟着一个块。</p>
<p>在之前的例子里，我们使用了一个throw表达式以避免把两个代表不同书籍的 Sales_item相加。我们假设执行Sales_item 对象加法的代码是与用户交互的代码分离开来的。其中与用户交互的代码负责处理发生的异常，它的形式可能如下所示:</p>
<pre><code>while (cin &gt;&gt; item1 &gt;&gt; item2) {
try {
//执行添加两个Sales_ item对象的代码
//如果添加失败，代码抛出一个runtime_ error异常
    if (iteml. isbn() != item2 . isbn() )
    throw runtime_error (&quot;Data must refer to same ISBN&quot;) ;
    //如果程序执行到了这里，表示两个ISBN是相同的
    cout &lt;&lt; item1 + item2 &lt;&lt; endl ;

} catch (runtime_error err) {
//提醒用户两个ISBN必须一致，询问是否重新输入
    cout &lt;&lt; err.what ()&lt;&lt; &quot;\nTry Again? Enter y or n&quot; &lt;&lt; endl ;
    char C;
    cin &gt;&gt; C;
    if(!cin || c ==&apos;n&apos; )
        break; // 跳出while循环
      }
 }</code></pre><p>上面的<code>err.what()</code>就是这个runtime_error后面的字符串。</p>
<p>给用户的提示信息中输出了err.what() 的返回值。我们知道err的类型是 runtime error, 因此能推断what是runtime error 类的一一个成员函数(参见1.5.2节，第20页)。每个标准库异常类都定义了名为what的成员函数，这些函数没有参数，返回值是C风格字符串(即const char*)。 其中， runtime error的what成员返回的是初始化–个具体对象时所用的string对象的副本。如果上一-节编写的代码抛出异常，则本节的catch子句输出：</p>
<pre><code>Data must refer to same ISBN
Try Again? Enter y or n</code></pre><h2 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h2><p>C++标准库定义了一-组类，用于报告标准库函数遇到的问题。这些异常类也可以在用户编写的程序中使用，它们分别定义在4个头文件中:</p>
<ul>
<li>exception头文件定义了最通用的异常类exception。它只报告异常的发生，不提供任何额外信息。</li>
<li>stdexcept头文件定义了几种常用的异常类，详细信息在表5.1中列出。</li>
<li>new头文件定义了bad_alloc异常类型，这种类型将在12.1.2节(第407页)详细介绍。</li>
<li>type_info头文件定义了bad_cast异常类型，这种类型将在19.2节(第731页)详细介绍。</li>
</ul>
<h4 id="定义的异常类"><a href="#定义的异常类" class="headerlink" title="定义的异常类"></a><stdexcept>定义的异常类</h4><p>类</p>
<p>解释</p>
<p>exception</p>
<p>最常见的问题</p>
<p>runtime_error</p>
<p>只有在运行时才能检测出的问题</p>
<p>range_error</p>
<p>运行时错误:生成的结果超出了有意义的值域范围</p>
<p>overflow error</p>
<p>运行时错误:计算上溢</p>
<p>underflow_error</p>
<p>运行时错误:计算下溢</p>
<p>logic_error</p>
<p>程序逻辑错误</p>
<p>domain_error</p>
<p>逻辑错误:参数对应的结果值不存在</p>
<p>invalid_argument</p>
<p>逻辑错误:无效参数</p>
<p>length_error</p>
<p>逻辑错误:试图创建一个超出该类型最大长度的对象</p>
<p>out_of_range</p>
<p>逻辑错误:使用一个超出有效范围的值</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/17/e8-8c-83-e5-9b-b4for-e8-af-ad-e5-8f-a5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/17/e8-8c-83-e5-9b-b4for-e8-af-ad-e5-8f-a5/" class="post-title-link" itemprop="url">范围for语句</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-17 08:07:07" itemprop="dateCreated datePublished" datetime="2019-01-17T08:07:07+08:00">2019-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h1><p>这个东西也算有点熟悉了，但是还是不是完全会用，也不知道到底什么场合适合用这个东西。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><pre><code>for (declaration : expression)
    statement</code></pre><p>声明和表达式，expression必须是一个序列，比如<code>vector</code>和<code>string</code>等等。这些类型的共同特点是能返回迭代器的begin和end成员。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><pre><code>vector&lt;int&gt; v = {0,1,2,3,4,5,6, 7,8,9};
//范围变量必须是引用类型，这样才能对元素执行写操作
for (auto &amp;r : v)
//对于v中的每一个元素
r *=2; //将v中每个元素的值翻倍</code></pre><p>上面的代码等价于下面的代码</p>
<pre><code>for (auto beg = v.begin() ，end = v.end() ; beg != end; ++beg) {
auto &amp;r = *beg; // r必须是引用类型，这样才能对元素执行写操作
r *=2; //将v中每个元素的值翻倍
}</code></pre><p>所以可以看到这个签名的<code>declaration</code>就是一个迭代器指针一样的东西。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在使用vector的时候，不能通过范围for语句增加vector对象的元素，因为一旦在序列中添加或者删除元素，end函数的值就可能变得无效。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/29/e8-bf-ad-e4-bb-a3-e5-99-a8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/29/e8-bf-ad-e4-bb-a3-e5-99-a8/" class="post-title-link" itemprop="url">迭代器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-29 07:23:14" itemprop="dateCreated datePublished" datetime="2018-12-29T07:23:14+08:00">2018-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>简单来说一下迭代器和其它的有什么区别？ 一般都习惯用这个数组来操作，很少用这个迭代器，但是针对stl中一切特别的容器可能就不能直接通过下标来访问容器，需要使用迭代器。</p>
<h3 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h3><p>迭代器只有<code>begin</code>和<code>end</code>两个成员，其中begin是返回第一个元素，end自然是返回容器中最后一个元素。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>如果上了C++11还是要多用这个auto，不知道面试的时候可以使用这个auto么，应该可以吧。</p>
<pre><code>for( auto it = s.begin(); it != s.end() &amp;&amp; !isspace(*it); ++it)
    *it = toupper(*it);
    //将当前字符改成大写形式</code></pre><h3 id="const类型"><a href="#const类型" class="headerlink" title="const类型"></a>const类型</h3><p>迭代器也有类型，比如<code>const_iterator</code>，这种和常量指针差不多，能读取但不能修改它所指的元素值。</p>
<pre><code>vector&lt;int&gt;::iterator it;
//能读写
vector&lt;int&gt;::const_iterator it3;

//只能读</code></pre><h4 id="cbegin"><a href="#cbegin" class="headerlink" title="cbegin"></a>cbegin</h4><p>如果对象只需读而无需写的话最好使用常量类型。C++11中，提供了cbegin，这种无论vector是否是常量，返回值都是const。</p>
<h3 id="解引用"><a href="#解引用" class="headerlink" title="解引用"></a>解引用</h3><p>解引用迭代器可获得迭代器所指的对象。但是如果检查是否为空，那么要对it加空格，运算符优先级规则</p>
<pre><code>(*it).empty();</code></pre><blockquote>
<p>这个it就是个指针，可以用箭头运算符<code>-&gt;</code>。</p>
</blockquote>
<p>在访问迭代器的成员时（比如这个迭代器指向一个结构体），it-&gt;mem和(*it).mem的意思是相同的。</p>
<h3 id="vector对象操作"><a href="#vector对象操作" class="headerlink" title="vector对象操作"></a>vector对象操作</h3><p>如果对vector进行push_back等增删操作会使当前vector对象的迭代器失效。</p>
<h3 id="迭代器移动"><a href="#迭代器移动" class="headerlink" title="迭代器移动"></a>迭代器移动</h3><p>迭代器也能直接移动，加减整数表达式可以直接跳着走，这个和指针的操作是一样的。</p>
<h4 id="二分应用"><a href="#二分应用" class="headerlink" title="二分应用"></a>二分应用</h4><p>这个二分查找还是不要用递归了，效率实在是太低，这样栈空间消耗太大了。很多方法都是用的while循环直接查找。</p>
<h5 id="迭代器二分查找"><a href="#迭代器二分查找" class="headerlink" title="迭代器二分查找"></a>迭代器二分查找</h5><pre><code>auto beg = text.begin(), end = text.end();
auto mid = beg + (end - beg)/2;
while(beg &lt; end &amp;&amp; *mid!=target){
//目标值在mid的右边
if(*mid &lt; target)
//加1的原因：如果mid比tar小，则要找的元素必定出现在mid所指元素的后面，此时将beg
    beg = mid + 1;
else
    end = mid;

mid = beg + (end - beg)/2;
}</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>向一个vector、string或deque插入元素会使所有指向容器的迭代器、引用和指针失效！那么删除操作呢？</p>
<h3 id="改变容器的循环程序"><a href="#改变容器的循环程序" class="headerlink" title="改变容器的循环程序"></a>改变容器的循环程序</h3><p>添加删除vector、string或deque元素的循环程序必须考虑迭代器、引用和指针可能失效的问题。程序必须保证每个循环步中都更新迭代器、引用或指针。如果循环中调用的是insert或erase,那么更新迭代器很容易。这些操作都返回迭代器，我们可以用来更新:</p>
<pre><code>//傻瓜循环,删除偶数元素，复制每个奇数元素
vector&lt;int&gt; vi = {0,1,2,3,4,5,6, 7,8,9};
auto iter = vi.begin(); //调用begin而不是cbegin, 因为我们要改变vi
while (iter != vi.end() ) {
    if (*iter 各2) {
    iter = vi. insert(iter, *iter); //复制当前元素
    iter += 2; //向前移动迭代器，跳过当前元素以及插入到它之前的元素
} else
    iter = vi.erase (iter) ;//删除偶数元素

 //不应向前移动迭代器，iter指向我们删除的元素之后的元素
}</code></pre><p>次程序删除vector中的偶数元素，并赋值每个奇数值元素。我们在调用insert和erase后都更新迭代器，因为两者都会使迭代器失效。</p>
<p><strong>在调用erase后，不必递增迭代器，因为erase返回的迭代器已经指向序列中的下一个元素。</strong></p>
<h3 id="容量增长"><a href="#容量增长" class="headerlink" title="容量增长"></a>容量增长</h3><p>vector等顺序容器是自增长的，并不是每次插入元素就会更新内存。而是选择增长一定长度的容量。</p>
<p>vector的实现采用的策略是在每次需要分配新内存空间时将当前容量翻倍。一般是存储满了才会进行容量的翻倍操作。 <img src="https://tanwenbo.top/wp-content/uploads/2019/01/90c0d4f4ccd58e56e659497b9fa71564.png" alt=""></p>
<p>也就是size会小于capacity！但是也不一定就是翻倍，要看具体实现。</p>
<p>虽然不同的实现可以采用不同的分配策略，但所有实现都应遵循-一个原则:确保用push_back向vector添加元素的操作有高效率。从技术角度说，就是通过在一个初始为空的vector上调用n次push_ back来创建一一个n个元素的vector,所花费的时间不能超过n的常数倍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/26/vector/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/26/vector/" class="post-title-link" itemprop="url">vector</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-26 08:27:30" itemprop="dateCreated datePublished" datetime="2018-12-26T08:27:30+08:00">2018-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><ul>
<li><p>Vector</p>
<ul>
<li><p>特性</p>
</li>
<li><p>初始化</p>
<ul>
<li>默认初始化</li>
</ul>
</li>
<li><p>添加元素</p>
<ul>
<li>注意</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>标准库类型vector表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，用于访问对象。一般称之为<code>容器</code>。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>vector是类模板。这个暂时不知道；</li>
<li>不能将引用作为其元素；</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>代码</p>
<p>说明</p>
<p>vector<T> v1</p>
<p>v1是一个空vector,它潜在的元素是T类型的，执行默认初始化</p>
<p>vector<T> v2 (v1)</p>
<p>v2中包含有v1所有元素的副本.</p>
<p>vector<T> v2 = v1</p>
<p>等价于v2(v1)，v2中包含有v1所有元素的副本.</p>
<p>vector<T> v3 (n, val)</p>
<p>v3包含了n个重复的元素，每个元素的值都是val</p>
<p>vector<T> v4 (n)</p>
<p>v4包含了n个重复地执行了值初始化的对象</p>
<p>vector<T> v5{a,b,c…}</p>
<p>v5 包含了初始值个数的元素，每个元素被赋予相应的初始值</p>
<p>vector<T> v5={a,b,c…}</p>
<p>等价于 v5{a,b,c…}</p>
<p>这个重复元素可以关注一下，可以利用这个来初始化。</p>
<h3 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h3><p>如果是内置类型，比如int，则元素初始值自动设为0，是string则是空。</p>
<pre><code>vector&lt;int&gt; ivec(10) ; // 10个元素，每个都初始化为0
vector&lt;string&gt; svec(10) ; // 10个元素，每个都是空string对象</code></pre><p>这里要特别小心区别花括号和圆括号，效果不同。</p>
<pre><code>vector&lt;int&gt; v1 (10) ;
// v1有10个元素，每个的值都是0
vector&lt;int&gt; v2{10} ;
// v2有1个元素，该元素的值是10
vector&lt;int&gt; v3(10， 1) ;
// v3有10个元素，每个的值都是1
vector&lt;int&gt; v4{10，1} ;
//v4有2个元素，值分别是10和1</code></pre><h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><p>这里<code>push_back()</code>应该比较熟悉，一般如果数组不能确定大小，那么就用vector。</p>
<pre><code>vector&lt;int&gt; v2 ;//空vector对象
for(int i = 0;i != 100;++i)
v2.push_back(i) ; //依次把整数值放到v2尾端

//循环结束后v2有100个元素，值从0到99</code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>vector不能用下标的形式来添加元素，只能在后面添加。但是可以通过下标修改、访问已存在的元素。</p>
<blockquote>
<p>其他的有些内容查看dash好了。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/ubuntu-mysql-yuan-cheng-lian-jie-cuo-wu2003-cant-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/25/ubuntu-mysql-yuan-cheng-lian-jie-cuo-wu2003-cant-c/" class="post-title-link" itemprop="url">Ubuntu MySQL 远程连接错误2003 Can't connect to MySQL server on  (61 "Connection refused")</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-25 19:34:23" itemprop="dateCreated datePublished" datetime="2018-12-25T19:34:23+08:00">2018-12-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">教程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>远程连接服务器上的mysql出现错误，后面查阅了一些资料，但是大部分都写的不是很齐全。如果你用的是Ubuntu系统，那么首先做这两件事，就能确保连接了。</p>
<h2 id="MySQL设置"><a href="#MySQL设置" class="headerlink" title="MySQL设置"></a>MySQL设置</h2><p>首先确保你要连接的账号支持远程登录，可以在<code>mysql</code>数据库下查看用户的登录权限，比如<code>root</code>。</p>
<pre><code>mysql -u root -p 
#输入密码
mysql&gt;use mysql;
mysql&gt;select host,user from user;</code></pre><p><img src="https://tanwenbo.top/wp-content/uploads/2018/12/15457380178188.jpg" alt="">￼</p>
<p>如果你的root的host是localhost，那么是连接不上的。需要改成%。</p>
<pre><code>update user set host = &apos;%&apos; where user = &quot;root&quot;;</code></pre><h2 id="检查MySQL服务"><a href="#检查MySQL服务" class="headerlink" title="检查MySQL服务"></a>检查MySQL服务</h2><p>还要检查一下这个MySQL的监听服务是不是开了。</p>
<pre><code>#假如你的数据库端口是3306
netstat -an | grep 3306</code></pre><p><img src="https://tanwenbo.top/wp-content/uploads/2018/12/15457382765966.jpg" alt="">￼<br>这里如果前面的是127.0.0.1的话那么只能监听此ip，不接受别的ip访问。</p>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>Ubuntu的是在<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code></p>
<p>找到里面的<code>bind-address</code>，改成<code>0.0.0.0</code>或者你想要的ip。</p>
<p>测试一下即可连接成功。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tanwenbo</p>
  <div class="site-description" itemprop="description">enjoy share</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">119</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tanwenbo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
