<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="enjoy share">
<meta property="og:type" content="website">
<meta property="og:title" content="hhyvs111">
<meta property="og:url" content="http://yoursite.com/page/10/index.html">
<meta property="og:site_name" content="hhyvs111">
<meta property="og:description" content="enjoy share">
<meta property="article:author" content="tanwenbo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>hhyvs111</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hhyvs111</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Be a great man</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/28/e7-ac-ac-e5-85-ad-e7-ab-a0-e9-a2-84-e5-a4-84-e7-90-86-e5-99-a8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/28/e7-ac-ac-e5-85-ad-e7-ab-a0-e9-a2-84-e5-a4-84-e7-90-86-e5-99-a8/" class="post-title-link" itemprop="url">第六章 预处理器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-28 01:28:21" itemprop="dateCreated datePublished" datetime="2018-04-28T01:28:21+08:00">2018-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第六章-预处理器"><a href="#第六章-预处理器" class="headerlink" title="第六章 预处理器"></a>第六章 预处理器</h1><p><code>《C陷阱与缺陷》学习笔记``posts</code></p>
<ul>
<li><a href="#第六章-预处理器">第六章 预处理器</a><ul>
<li><a href="#导读">导读</a></li>
<li><a href="#61-不能忽视宏定义中的空格">6.1 不能忽视宏定义中的空格</a></li>
<li><a href="#62-宏并不是函数">6.2 宏并不是函数</a><ul>
<li><a href="#621-括号预防优先级问题">6.2.1 括号预防优先级问题</a></li>
<li><a href="#622-避免参数副作用">6.2.2 避免参数副作用</a></li>
</ul>
</li>
<li><a href="#63-宏并不是语句">6.3 宏并不是语句</a></li>
<li><a href="#63-宏并不是类型定义">6.3 宏并不是类型定义</a></li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
</ul>
<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>预处理器使得编程者可以简化某些工作，它的重要性可以由两个主要的原因说明。</p>
<ul>
<li>第一，有时候我们希望将某个特定数量（如数据表的大小）在程序中出现的<strong>所有实例</strong>统统加以修改。只要改一个地方，其他所有地方都修改。</li>
<li>第二，C语言函数调用时都会带来巨大的系统开销。因此，我们希望有这样一种程序块，它看上去像一个函数，但却没有函数调用。比如，<code>getchar</code>和<code>putchar</code>经常被实现为宏，</li>
</ul>
<p>宏的作用非常强大，有时候可以使代码看起来更加容易理解，将数字或符号替换为自己熟悉的命名。</p>
<h2 id="6-1-不能忽视宏定义中的空格"><a href="#6-1-不能忽视宏定义中的空格" class="headerlink" title="6.1 不能忽视宏定义中的空格"></a>6.1 不能忽视宏定义中的空格</h2><p>宏也是有参数的，和函数一样。函数有空格无关紧要，但是如果宏定义带了空格意思就不一样了。 比如</p>
<pre><code>#define f (x) ((x) - 1)</code></pre><p>可能观察不仔细的人会以为是将f(x)替换成((x) - 1)，这样编译通过不了！所以必须要像下面这样写：</p>
<pre><code>#define f(x) ((x) - 1)</code></pre><p><strong>这一规则不适用与宏调用，只对宏定义有用。因此，在上面完成宏定义后，f(3)与f (3)求值后都等于2。</strong></p>
<h2 id="6-2-宏并不是函数"><a href="#6-2-宏并不是函数" class="headerlink" title="6.2 宏并不是函数"></a>6.2 宏并不是函数</h2><h3 id="6-2-1-括号预防优先级问题"><a href="#6-2-1-括号预防优先级问题" class="headerlink" title="6.2.1 括号预防优先级问题"></a>6.2.1 括号预防优先级问题</h3><p>宏严格来说并不是函数，但是很多程序员都喜欢把一些简单的函数定义为宏。比如如下写法：</p>
<pre><code>#define abs(x) (((x) &gt;= 0) ? (x) : -(x))
#define max(a,b) ((a) &gt; (b) ? (a) : (b))</code></pre><p>之所以这么多括号是预防引起<code>优先级</code>有关的问题，如果没有括号可能会造成优先级的问题。因为宏不像函数，宏只是起到了一个替换的作用，直接将define的中间替换为后面的表达式。比如</p>
<pre><code>#define abs(x) x&gt;0?x:-x
abs(a-b);       //</code></pre><p>会被展开为 <code>a-b&gt;0?a-b:-a-b</code>，其中的-a-b相当于(-a)-b，而不是想象中的-(a-b)。所以最好用括号括起来。</p>
<h3 id="6-2-2-避免参数副作用"><a href="#6-2-2-避免参数副作用" class="headerlink" title="6.2.2 避免参数副作用"></a>6.2.2 避免参数副作用</h3><p>在用到类似的三元运算符宏定义<code>#define max(a,b) a&gt;b ? a : b</code>时，因避免在三元运算符里对数进行改变而产生<strong>副作用</strong>。比如：</p>
<pre><code>biggest = ((biggest) &gt; (x[i++]) &gt; (biggest) : (x[i++]));</code></pre><p>在上述表达式中，若<code>i</code>为<code>0</code>，那么<code>biggest</code>会与<code>x[0]</code>先比较，然后因为<code>i++</code>的作用，此时<code>i</code>为1，然后再在后面的赋值中又有<code>i++</code>，此时计算完毕<code>i</code>的值已经为<code>2</code>，而不是预料之中的<code>1</code>。 所以要确保<strong>max中的参数没有副作用</strong>。</p>
<h2 id="6-3-宏并不是语句"><a href="#6-3-宏并不是语句" class="headerlink" title="6.3 宏并不是语句"></a>6.3 宏并不是语句</h2><p>有些人会认为宏也是语句，如果单独使用也和语句一样，有分号作终止符，其实大错特错！ 比如assert宏，它的参数是一个表达式，如果该表达式为0，就使程序终止执行并给出一条错误信息。</p>
<pre><code>#define assert(e) if(!e) assert_error(_FILE,_LINE_)

if(x &gt; 0 &amp;&amp; y &gt; 0)
    assert(x &gt; y);
else
    assert(y &gt; x);</code></pre><p>上面的式子通过宏替换后就是这样样子:</p>
<pre><code>if( x &gt; 0 &amp;&amp; y &gt; 0)
    if(!(x &gt; y)) assert_error(&quot;foo.c&quot;,37);
else
    if(!(y &gt; x)) assert_error(&quot;foo.c&quot;,39);</code></pre><p>请注意之前的if-else结合优先级问题，未匹配的<code>else</code>会与其最近的<code>if</code>结合。将代码适当缩排一下：</p>
<pre><code>if( x &gt; 0 &amp;&amp; y &gt; 0)
    if(!(x &gt; y)) 
        assert_error(&quot;foo.c&quot;,37);
    else
        if(!(y &gt; x)) 
            assert_error(&quot;foo.c&quot;,39);</code></pre><p>可以看到实际流程与我们想象中的有所出入，那么如何解决这个问题？ 这样定义assert：</p>
<pre><code>#define assert(e) ((void)((e))||_assert_error(__FILE__,__LINE__)))</code></pre><p>这个定义实际上利用了<code>||</code>运算符对两侧的操作数依次顺序求值的性质。具体的也不是很理解。</p>
<h2 id="6-3-宏并不是类型定义"><a href="#6-3-宏并不是类型定义" class="headerlink" title="6.3 宏并不是类型定义"></a>6.3 宏并不是类型定义</h2><p>宏的一个常见用途是，使多个不同变量的类型可在一个地方说明：</p>
<pre><code>#define FOOTYPE struct foo
FOOTYPE a;
FOOTYPE b,c;</code></pre><p>这样，编程者只需在程序中改动一行代码，即可改变<code>a、b、c</code>的类型，而与<code>a、b、c</code>在程序中的什么地方声明无关。这种用法有一个优点——<strong><code>可移植性</code></strong>。但是我们最好还是使用类型定义：</p>
<pre><code>typedef struct foo FOOTYPE;</code></pre><p>看起来差不多，但是使用起来就会有很大的差别。例如，如下代码：</p>
<pre><code>#define T1 struct foo *
typedef struct foo  *T2;</code></pre><p>从上面看，<code>T1</code>和<code>T2</code>好像完全一样，都是指向结构<code>foo</code>的指针。但是当我们试图用他们来声明多个变量时，问题就来了。</p>
<pre><code>T1 a, b;
T2 a, b;
//第一个声明被扩展为：
struct foo *a, b;</code></pre><p>这个语句中<code>a</code>被定义为一个指向结构的指针，而<code>b</code>却被定义为一个结构。第二个声明则不同，它定义的都是指向结构的指针。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>宏是一个强大的功能，用好了则事半功倍，否则事倍功半！总结以下几点，写代码的时候要十分注意。</p>
<ul>
<li><strong>宏不要随便加空格</strong>，因为<code>define</code>后面的<code>两个式子</code>就是<code>相互替换</code>的关系，如果多了一个空格那么就会变成三个式子；</li>
<li><strong>宏不是函数</strong>，是直接替换内容，要考虑运算符优先级的问题，必要时应该加上空格防止优先级错误；</li>
<li><strong>宏要避免参数副作用</strong>，不要在宏里进行多余的操作，比如<code>++</code>操作；</li>
<li><strong>宏不是语句</strong>，不要想当然的当成语句来处理，需要加分号等结束符；</li>
<li><strong>宏不适用于类型定义</strong>，多重定义的时候会出现歧义。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/26/e7-ac-ac-e4-ba-94-e7-ab-a0-e5-ba-93-e5-87-bd-e6-95-b0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/26/e7-ac-ac-e4-ba-94-e7-ab-a0-e5-ba-93-e5-87-bd-e6-95-b0/" class="post-title-link" itemprop="url">第五章 库函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-26 01:16:41" itemprop="dateCreated datePublished" datetime="2018-04-26T01:16:41+08:00">2018-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第五章-库函数"><a href="#第五章-库函数" class="headerlink" title="第五章 库函数"></a>第五章 库函数</h1><p><code>《C陷阱与缺陷》学习笔记``posts</code></p>
<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>C语言中没有定义输入/输出语句，任何一个有用的C程序都必须调用库函数来完成最基本的输入/输出操作。</p>
<blockquote>
<p>就像内存相关的的函数malloc和free是库函数，但是C++里的new和delete是运算符。</p>
</blockquote>
<p>最好尽量使用系统头文件，因为库文件的编写是经过深思熟虑的，代码的功能都是十分完全的。</p>
<ul>
<li><a href="#第五章-库函数">第五章 库函数</a><ul>
<li><a href="#导读">导读</a></li>
<li><a href="#51-返回整数的getchar函数">5.1 返回整数的getchar函数</a></li>
<li><a href="#52-更新顺序文件">5.2 更新顺序文件</a><ul>
<li><a href="#521-函数理解">5.2.1 函数理解</a></li>
<li><a href="#522-代码解释">5.2.2 代码解释</a></li>
<li><a href="#523-如果不fseek直接fread会发生什么呢">5.2.3 如果不fseek直接fread会发生什么呢？</a></li>
</ul>
</li>
<li><a href="#53-缓冲输出与内存分配">5.3 缓冲输出与内存分配</a><ul>
<li><a href="#531-使用setbuf库函数">5.3.1 使用setbuf库函数</a></li>
</ul>
</li>
<li><a href="#54-使用errno">5.4 使用errno</a></li>
<li><a href="#55-库函数signal">5.5 库函数signal</a></li>
</ul>
</li>
</ul>
<h2 id="5-1-返回整数的getchar函数"><a href="#5-1-返回整数的getchar函数" class="headerlink" title="5.1 返回整数的getchar函数"></a>5.1 返回整数的getchar函数</h2><blockquote>
<p>第一眼看到getchar就想起了缓冲回车符，有时候如果不多加一个getchar来缓冲回车符代码就会出错。因为回车也是一个符号，也会进入缓冲区，getchar就是从缓冲区一个个读字符。getchar() 在键盘输入信息时, 并不是在键盘上敲一个字符，该字符就立即送到计算机中，这些字符暂存在键盘的缓冲区中，只有按了Enter键才会把这些字符一起送到计算机中。</p>
</blockquote>
<p>为什么getchar会返回整数int？先看看下面这个例子：</p>
<pre><code>#include&lt;stdio.h&gt;
main()
{
    char c;
    while((c = getchar()) != EOF )
            putchar(c);
}</code></pre><p>C语言中对getchar的描述为：</p>
<pre><code>int getchar(void);</code></pre><p>按理返回值应用<code>char</code>,但为了包含<code>EOF</code>，<code>EOF</code>是一个整型数，通常值为<code>-1</code>，<code>char</code>就装不下，就用了更大的int来装（ASCII码的取值范围<code>0-127</code>）。 编译器会把<code>EOF</code>做<strong>“截断”</strong>处理，把被<strong>“截断”</strong>的值返回给<code>c</code>。</p>
<h2 id="5-2-更新顺序文件"><a href="#5-2-更新顺序文件" class="headerlink" title="5.2 更新顺序文件"></a>5.2 更新顺序文件</h2><blockquote>
<p>可以看一下这篇问答，讲的很好！<a href="http://www.dewen.net.cn/q/9263/%E8%B0%83%E7%94%A8fread%E5%90%8E%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8fwrite%E5%86%99%E4%B8%8D%E8%BF%9B%E5%8E%BB%EF%BC%8C%E5%8F%8D%E4%B9%8B%E4%B9%9F%E6%98%AF%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F" target="_blank" rel="noopener">调用fread后直接调用fwrite写不进去，反之也是，为什么？</a></p>
</blockquote>
<h3 id="5-2-1-函数理解"><a href="#5-2-1-函数理解" class="headerlink" title="5.2.1 函数理解"></a>5.2.1 函数理解</h3><p>linux下，man fread和fread结果</p>
<ul>
<li><code>size_t</code> fread(void <code>*ptr</code>,size_t <code>size</code>,size_t <code>nmemb</code>,File <code>*stream</code> )定义：</li>
</ul>
<blockquote>
<p>fread是一个函数，它从文件流中读数据，最多读取<code>numeb</code>个项，每个项<code>size</code>个字节，如果调用成功返回实际读取到的项个数（小于或等于<code>nmemb</code>），如果不成功或读到文件末尾返回 0。</p>
</blockquote>
<ul>
<li><code>size_t</code> fwrite(void <code>*ptr</code>, size_t <code>size</code>, size_t <code>nmemb</code>, FILE <code>*stream</code>)定义：</li>
</ul>
<blockquote>
<p>fwrite() 是 C 语言标准库中的一个文件处理函数，功能是向指定的文件中写入若干数据块，如成功执行则返回实际写入的数据块数目。该函数以二进制形式对文件进行操作，不局限于文本文件。</p>
</blockquote>
<ul>
<li><code>int</code> fseek(FILE <code>*stream</code>, long <code>offset</code>, int <code>whence</code>);</li>
</ul>
<blockquote>
<p>文件指针偏移，根据whence偏移起始位置偏移offset个字节。</p>
</blockquote>
<ul>
<li><p>fseek的函数参数列表第三个的数字含义： 偏移起始位置：</p>
<ul>
<li>文件头<code>0</code>(SEEK_SET)；</li>
<li>当前位置<code>1</code>(SEEK_CUR)；</li>
<li>文件尾<code>2</code>(SEEK_END)。</li>
</ul>
</li>
</ul>
<h3 id="5-2-2-代码解释"><a href="#5-2-2-代码解释" class="headerlink" title="5.2.2 代码解释"></a>5.2.2 代码解释</h3><p>那么我们再来看下面这段代码：</p>
<pre><code>FILE * fp;  
struct record rec;  
//... ...  
//从fp读结构体rec，每次读一个
while (fread((char *)&amp;rec, sizeof(rec), 1, fp) == 1) 
{  
    /* 对rec执行某些操作 */  
    if (/* rec 必须被重新写入 */) 
    {  
         fseek(fp, -(long)sizeof(rec), 1); 
         /*因为要重新将rec写入到fp，要对文件指针向前回溯，所以是fseek的第二项是负数，后面的1是文件指针当前位置，表明回溯起点是文件中rec的尾部*/
         fwrite((char *)&amp;rec, sizeof(rec), 1, fp);  
         /*rec写入缓冲区，等待写入。*/
         fseek(fp,0L,1);
         /*之所以要调用fseek，因为fwrite的数据只是写入到了缓冲区，而fseek函数中调用了fflush（因版本而异），这样才将缓冲区的内容输入写进fp。*/
         /*其实这个指令看似什么也做，但是其使得磁盘文件中的数据改变了，并且使文件可以正常读取了*/
    }  
}  </code></pre><p>上述代码之前应该有<code>fopen()</code>操作，这个操作是将文件数据读入缓存区，然后fread从缓存区读数据。 flush除了写入文件外，它还把将<code>file</code>中<code>_ptr</code>（文件缓存的指针）的位置重新设置到缓存的开始处了。 借用上面网址中的一幅图，可以很直观的理解文件操作和为什么要<code>fseek</code>。 <img src="http://tanwenbo.top/wp-content/uploads/2018/05/771203f53a763dd89db9de9bd235b906.png" alt=""> </p>
<h3 id="5-2-3-如果不fseek直接fread会发生什么呢？"><a href="#5-2-3-如果不fseek直接fread会发生什么呢？" class="headerlink" title="5.2.3 如果不fseek直接fread会发生什么呢？"></a>5.2.3 如果不fseek直接fread会发生什么呢？</h3><p><strong>fwrite</strong>将数据写入缓存区，<strong>fread</strong>又从文件读数据到缓存区，缓存区中有2组数据，但是fseek只将文件指针向后偏移了一组数据的偏移量，那么数据后面的就会被覆盖。 小结一下</p>
<ul>
<li>连续的fread不用调用fseek</li>
<li>使用了fwrite后应该及时调用fseek，使文件缓存真正写入磁盘文件中。</li>
</ul>
<h2 id="5-3-缓冲输出与内存分配"><a href="#5-3-缓冲输出与内存分配" class="headerlink" title="5.3 缓冲输出与内存分配"></a>5.3 缓冲输出与内存分配</h2><p>程序输出有两种方式：</p>
<ul>
<li>一种是及时处理方式；</li>
<li>另一种是先暂存起来，然后再大块写入的方式。</li>
</ul>
<p>前者往往造成较高的系统负担。因此，C语言实现通常都允许程序员进行实际的写操作之前控制产生的输出数据量。</p>
<h3 id="5-3-1-使用setbuf库函数"><a href="#5-3-1-使用setbuf库函数" class="headerlink" title="5.3.1 使用setbuf库函数"></a>5.3.1 使用setbuf库函数</h3><p>setbuf(stdout,buf);</p>
<p>语句将通知输入/输出库，所有写入到stdout的输出都应该使用buf作为输出缓冲区，知道buf缓冲区被填满或者程序员直接调用fflush（调用之后缓冲区的内容才被实际的写入该文件）。 如果直接在main函数里声明缓冲数组会出错，因为main函数结束后<code>缓冲数组</code>会被释放。解决的方法就是</p>
<ul>
<li><p>声明静态函数</p>
<p>static char buf[BUFSIZ];</p>
</li>
</ul>
<ul>
<li><p>动态分配缓冲区</p>
<p>char *malloc();<br>setbuf(stdout, malloc(BUFSIZ)); </p>
</li>
</ul>
<h2 id="5-4-使用errno"><a href="#5-4-使用errno" class="headerlink" title="5.4 使用errno"></a>5.4 使用errno</h2><p>很多库函数，特别是那些与操作系统有关的，当执行失败时会通过一个名称为<code>errno</code>的外部变量，通知程序该函数调用失败。</p>
<blockquote>
<p>errno 是记录系统的最后一次错误代码。代码是一个int型的值，在errno.h中定义。查看错误代码errno是调试程序的一个重要方法。当linux C api函数发生异常时,一般会将errno变量(需include errno.h)赋一个整数值,不同的值表示不同的含义,可以通过查看该值推测出错的原因。在实际编程中用这一招解决了不少原本看来莫名其妙的问题。</p>
</blockquote>
<p>在调用库函数时，我们应该首先检测作为错误提示的返回值，确定程序执行已经失败。然后，再检查errno，来搞清楚出错原因：</p>
<pre><code>//调用库函数
if(返回的错误值)
        检查errno </code></pre><h2 id="5-5-库函数signal"><a href="#5-5-库函数signal" class="headerlink" title="5.5 库函数signal"></a>5.5 库函数signal</h2><p>信号函数，作为捕获异步事件的一种方式。</p>
<pre><code>#include&lt;signal.h&gt;
signal(signal type, handler function);</code></pre><p>signal type代表信号中的某些常量，比如（<code>SIGINT</code>）。<code>liunx</code>有<code>64</code>种信号，其中<code>32</code>种是不可靠信号，另外<code>32</code>种是可靠信号。 从安全角度出发，signal不应该调用系统的<code>库函数</code>，也就是<code>function</code>不应该是<code>库函数</code>，应该是自己定义的函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/24/four-link/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/24/four-link/" class="post-title-link" itemprop="url">第四章 连接</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-24 12:05:28" itemprop="dateCreated datePublished" datetime="2018-04-24T12:05:28+08:00">2018-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="http://maxiang.io/#/?provider=evernote&guid=558692fd-8021-498e-a42c-9f3d939845dd&notebook=%E3%80%8AC%E9%99%B7%E9%98%B1%E4%B8%8E%E7%BC%BA%E9%99%B7%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0" target="_blank" rel="noopener">Edit</a></p>
<h1 id="第四章-连接"><a href="#第四章-连接" class="headerlink" title="第四章 连接"></a>第四章 连接</h1><p>《C陷阱与缺陷》学习笔记 形参 实参 static posts</p>
<ul>
<li><a href="#第四章-连接">第四章 连接</a></li>
</ul>
<ul>
<li><p><a href="#41-什么是连接器">4.1 什么是连接器</a></p>
</li>
<li><p><a href="#42-声明和定义">4.2 声明和定义</a></p>
</li>
<li><p><a href="#43-命名冲突与static修饰符">4.3 命名冲突与static修饰符</a></p>
</li>
</ul>
<ul>
<li><p><a href="#431-变量">4.3.1 变量</a></p>
</li>
<li><p><a href="#432-函数">4.3.2 函数</a></p>
</li>
</ul>
<ul>
<li><a href="#44-形参实参与返回值">4.4 形参、实参与返回值</a></li>
</ul>
<ul>
<li><p><a href="#441-形参实参的区别">4.4.1 形参实参的区别</a></p>
</li>
<li><p><a href="#442-强制转换">4.4.2 强制转换</a></p>
</li>
<li><p><a href="#443-返回值">4.4.3 返回值</a></p>
</li>
</ul>
<ul>
<li><a href="#45-检查外部类型">4.5 检查外部类型</a></li>
</ul>
<ul>
<li><p><a href="#原内存布局">原内存布局</a></p>
</li>
<li><p><a href="#现内存布局">现内存布局</a></p>
</li>
</ul>
<ul>
<li><p><a href="#46-头文件">4.6 头文件</a></p>
</li>
<li><p><a href="#总结">总结</a></p>
</li>
</ul>
<h2 id="4-1-什么是连接器"><a href="#4-1-什么是连接器" class="headerlink" title="4.1 什么是连接器"></a>4.1 什么是连接器</h2><blockquote>
<p>在C语言中，一个重要的思想就是分别编译，即若干个源程序可以在不同的时候单独进行编译，然后在恰当的时候整合到一起。但是连接器一般是与C编译器分离的，连接器如何做到把若干个C源程序合并成一个整体呢？</p>
<p>典型的连接器把由编译器或汇编器生成的若干个目标模块，整合成一个被称为载入模块或可执行文件的实体，该实体能够被操作系统直接执行。其中，某些目标模块是直接作为输入提供给连接器的；而另外一些目标模块则是根据连接过程的需要，从包括有类似printf函数的库文件中取得的。</p>
</blockquote>
<p>简而言之，连接器就是用来连接各个编译好的模块，然后将其组成一个模块或者可执行文件。且会检查外部对象是否有重复，重复则报错。因为大多数连接器都进制同一个载入模块中的两个不同对象拥有相同的名称。</p>
<h2 id="4-2-声明和定义"><a href="#4-2-声明和定义" class="headerlink" title="4.2 声明和定义"></a>4.2 声明和定义</h2><p>声明在函数体之外的变量是全局变量，也称为外部对象。</p>
<p>1.int a; //声明</p>
<p>2.a = 1; //定义</p>
<p>3.int b = 1; //声明并定义</p>
<p>如果使用了extern关键字，则代表该变量是其他地方分配的。</p>
<p>1.extern int a;</p>
<h2 id="4-3-命名冲突与static修饰符"><a href="#4-3-命名冲突与static修饰符" class="headerlink" title="4.3 命名冲突与static修饰符"></a>4.3 命名冲突与static修饰符</h2><h3 id="4-3-1-变量"><a href="#4-3-1-变量" class="headerlink" title="4.3.1 变量"></a>4.3.1 变量</h3><p>static修饰的变量只会初始化一次，其值固定在内存空间直至销毁，所以如果再次对其进行赋值是无效的。</p>
<p>static变量可以重名，不会发生冲突</p>
<p>1.static int a;</p>
<p>2.int a;</p>
<h3 id="4-3-2-函数"><a href="#4-3-2-函数" class="headerlink" title="4.3.2 函数"></a>4.3.2 函数</h3><p>static声明的函数可以在外部使用，一般称其为静态函数。</p>
<p>1.static int g(int x)</p>
<p>2.{</p>
<p>3…..</p>
<p>4.}</p>
<p>5.</p>
<p>6.void f()</p>
<p>7.{</p>
<ol start="8">
<li>b = g(a);</li>
</ol>
<p>9.}</p>
<h2 id="4-4-形参、实参与返回值"><a href="#4-4-形参、实参与返回值" class="headerlink" title="4.4 形参、实参与返回值"></a>4.4 形参、实参与返回值</h2><h3 id="4-4-1-形参实参的区别"><a href="#4-4-1-形参实参的区别" class="headerlink" title="4.4.1 形参实参的区别"></a>4.4.1 形参实参的区别</h3><p>老生常谈了，用段代码来解释下形参和实参。</p>
<p>1.#include&lt;stdio.h&gt;</p>
<p>2.void swap(int a,int b)</p>
<p>3.{</p>
<ol start="4">
<li>int c = a;</li>
</ol>
<p>5.#include&lt;stdio.h&gt;</p>
<p>6.void swap(int a,int b) //传的形参</p>
<p>7.{</p>
<ol start="8">
<li><p>int c = a;</p>
</li>
<li><p>a = b;</p>
</li>
<li><p>b = c;</p>
</li>
</ol>
<p>11.}</p>
<p>12.void swap1(int *a,int *b) //传实参</p>
<p>13.{</p>
<p>14.</p>
<ol start="15">
<li><p>int c = *a;</p>
</li>
<li><p>*a = *b;</p>
</li>
<li><p>*b = c;</p>
</li>
</ol>
<p>18.}</p>
<p>19.int main()</p>
<p>20.{</p>
<ol start="21">
<li><p>int a = 1,b = 2;</p>
</li>
<li><p>swap(a,b); //没有交换</p>
</li>
<li><p>printf(“%d %d\n”,a ,b);</p>
</li>
<li><p>swap1(&amp;a,&amp;b); //交换了</p>
</li>
<li><p>printf(“%d %d\n”,a , b);</p>
</li>
<li><p>return 0 ;</p>
</li>
</ol>
<p>27.}</p>
<h3 id="4-4-2-强制转换"><a href="#4-4-2-强制转换" class="headerlink" title="4.4.2 强制转换"></a>4.4.2 强制转换</h3><p>当函数指定了参数类型，会进行强制转换，比如：</p>
<p>1.double square(double);</p>
<p>2.square(2); //合法，会自动转换为双精度类型</p>
<h3 id="4-4-3-返回值"><a href="#4-4-3-返回值" class="headerlink" title="4.4.3 返回值"></a>4.4.3 返回值</h3><p>函数除了构造函数和析构函数之外，都要声明返回值，void或者其他类型。</p>
<h2 id="4-5-检查外部类型"><a href="#4-5-检查外部类型" class="headerlink" title="4.5 检查外部类型"></a>4.5 检查外部类型</h2><p>在引用外部变量的时候要注意最好是类型一样，比如：</p>
<p>1.char filename[] = “/etc/passwd”;</p>
<p>2.</p>
<p>3.extern char* filename; //外部引用</p>
<p>虽然指针与数组好像是一样的，但是filename的类型是“字符数组”，而不是“字符指针”。在第二个声明中，filename被确定为一个指针。这两个对filename的声明使用存储空间的方式是不同的。</p>
<h4 id="原内存布局"><a href="#原内存布局" class="headerlink" title="原内存布局"></a>原内存布局</h4><p><img src="https://tanwenbo.top/wp-content/uploads/2018/06/e98054d288ab979ab00d1b0319cfc674.png" alt=""></p>
<h4 id="现内存布局"><a href="#现内存布局" class="headerlink" title="现内存布局"></a>现内存布局</h4><p><img src="https://tanwenbo.top/wp-content/uploads/2018/06/b8923f18c4555c4870fdfd935f6c55e7.png" alt=""></p>
<p>应该改为同样类型：</p>
<p>1.char filename[] = “/etc”;</p>
<p>2.extern char filename[];</p>
<p>3.</p>
<p>4.char* filename= “/etc”;</p>
<p>5.extern char* filename;</p>
<h2 id="4-6-头文件"><a href="#4-6-头文件" class="headerlink" title="4.6 头文件"></a>4.6 头文件</h2><p>每个外部对象应只在一个头文件中声明，需要用到该外部对象的所有模块都应该包括这个头文件。定义该外部对象的模块也应该包括这个头文件。比如：</p>
<p>public.h</p>
<p>1.int a = 1;</p>
<p>2.char* str = “123”;</p>
<p>main.c</p>
<p>1.#include &lt;stdio.h&gt;</p>
<p>2.#include “public.h”</p>
<p>3.extern int a;</p>
<p>4.extern char* str;</p>
<p>5.int main()</p>
<p>6.{</p>
<ol start="7">
<li><p>printf(“%d\n”,a);</p>
</li>
<li><p>return 0;</p>
</li>
</ol>
<p>9.}</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C语言的连接是一个很强大的东西，将小的模块组成大的模块，文件和变量之间能很好的进行交互，从而达到高内聚低耦合的效果。</p>
<p>%23%u7B2C%u56DB%u7AE0%20%u8FDE%u63A5%0A@%28%u300AC%u9677%u9631%u4E0E%u7F3A%u9677%u300B%u5B66%u4E60%u7B14%u8BB0%29%5B%u5F62%u53C2%7C%u5B9E%u53C2%7Cstatic%7Cposts%5D%0A%0A%5BTOC%5D%0A%0A%23%23%204.1%20%u4EC0%u4E48%u662F%u8FDE%u63A5%u5668%0A%3E%20%u5728C%u8BED%u8A00%u4E2D%uFF0C%u4E00%u4E2A%u91CD%u8981%u7684%u601D%u60F3%u5C31%u662F%u5206%u522B%u7F16%u8BD1%uFF0C%u5373%u82E5%u5E72%u4E2A%u6E90%u7A0B%u5E8F%u53EF%u4EE5%u5728%u4E0D%u540C%u7684%u65F6%u5019%u5355%u72EC%u8FDB%u884C%u7F16%u8BD1%uFF0C%u7136%u540E%u5728%u6070%u5F53%u7684%u65F6%u5019%u6574%u5408%u5230%u4E00%u8D77%u3002%u4F46%u662F%u8FDE%u63A5%u5668%u4E00%u822C%u662F%u4E0EC%u7F16%u8BD1%u5668%u5206%u79BB%u7684%uFF0C%u8FDE%u63A5%u5668%u5982%u4F55%u505A%u5230%u628A%u82E5%u5E72%u4E2AC%u6E90%u7A0B%u5E8F%u5408%u5E76%u6210%u4E00%u4E2A%u6574%u4F53%u5462%uFF1F%0A%3E%20%u5178%u578B%u7684%u8FDE%u63A5%u5668%u628A%u7531%u7F16%u8BD1%u5668%u6216%u6C47%u7F16%u5668%u751F%u6210%u7684%u82E5%u5E72%u4E2A%u76EE%u6807%u6A21%u5757%uFF0C%u6574%u5408%u6210%u4E00%u4E2A%u88AB%u79F0%u4E3A%u8F7D%u5165%u6A21%u5757%u6216%u53EF%u6267%u884C%u6587%u4EF6%u7684%u5B9E%u4F53%uFF0C%u8BE5%u5B9E%u4F53%u80FD%u591F%u88AB%u64CD%u4F5C%u7CFB%u7EDF%u76F4%u63A5%u6267%u884C%u3002%u5176%u4E2D%uFF0C%u67D0%u4E9B%u76EE%u6807%u6A21%u5757%u662F%u76F4%u63A5%u4F5C%u4E3A%u8F93%u5165%u63D0%u4F9B%u7ED9%u8FDE%u63A5%u5668%u7684%uFF1B%u800C%u53E6%u5916%u4E00%u4E9B%u76EE%u6807%u6A21%u5757%u5219%u662F%u6839%u636E%u8FDE%u63A5%u8FC7%u7A0B%u7684%u9700%u8981%uFF0C%u4ECE%u5305%u62EC%u6709%u7C7B%u4F3Cprintf%u51FD%u6570%u7684%u5E93%u6587%u4EF6%u4E2D%u53D6%u5F97%u7684%u3002%0A%0A%u7B80%u800C%u8A00%u4E4B%uFF0C%u8FDE%u63A5%u5668%u5C31%u662F%u7528%u6765%u8FDE%u63A5%u5404%u4E2A%u7F16%u8BD1%u597D%u7684%u6A21%u5757%uFF0C%u7136%u540E%u5C06%u5176%u7EC4%u6210%u4E00%u4E2A%u6A21%u5757%u6216%u8005%u53EF%u6267%u884C%u6587%u4EF6%u3002%u4E14%u4F1A%u68C0%u67E5%u5916%u90E8%u5BF9%u8C61%u662F%u5426%u6709%u91CD%u590D%uFF0C%u91CD%u590D%u5219%u62A5%u9519%u3002%u56E0%u4E3A<strong>%u5927%u591A%u6570%u8FDE%u63A5%u5668%u90FD%u8FDB%u5236%u540C%u4E00%u4E2A%u8F7D%u5165%u6A21%u5757%u4E2D%u7684%u4E24%u4E2A%u4E0D%u540C%u5BF9%u8C61%u62E5%u6709%u76F8%u540C%u7684%u540D%u79F0</strong>%u3002%0A%0A%23%23%204.2%20%u58F0%u660E%u548C%u5B9A%u4E49%0A%u58F0%u660E%u5728%u51FD%u6570%u4F53%u4E4B%u5916%u7684%u53D8%u91CF%u662F<strong>%u5168%u5C40%u53D8%u91CF</strong>%uFF0C%u4E5F%u79F0%u4E3A<strong>%u5916%u90E8%u5BF9%u8C61</strong>%u3002%0A%60%60%60c%0Aint%20a%3B%09%09%09%09//%u58F0%u660E%0Aa%20%3D%201%3B%09%09%09%09//%u5B9A%u4E49%0Aint%20b%20%3D%201%3B%09%09%09//%u58F0%u660E%u5E76%u5B9A%u4E49%0A%60%60%60%0A%u5982%u679C%u4F7F%u7528%u4E86extern%u5173%u952E%u5B57%uFF0C%u5219%u4EE3%u8868%u8BE5%u53D8%u91CF%u662F%u5176%u4ED6%u5730%u65B9%u5206%u914D%u7684%u3002%0A%60%60%60c%0Aextern%20int%20a%3B%0A%60%60%60%0A%0A%23%23%204.3%20%u547D%u540D%u51B2%u7A81%u4E0Estatic%u4FEE%u9970%u7B26%0A%23%23%23%204.3.1%20%u53D8%u91CF%0Astatic%u4FEE%u9970%u7684%u53D8%u91CF%u53EA%u4F1A%60%60%u521D%u59CB%u5316%u4E00%u6B21%60%60%uFF0C%u5176%u503C%u56FA%u5B9A%u5728%u5185%u5B58%u7A7A%u95F4%u76F4%u81F3%u9500%u6BC1%uFF0C<strong>%u6240%u4EE5%u5982%u679C%u518D%u6B21%u5BF9%u5176%u8FDB%u884C%u8D4B%u503C%u662F%u65E0%u6548%u7684%u3002</strong>%0A%0Astatic%u53D8%u91CF%u53EF%u4EE5%60%u91CD%u540D%60%uFF0C%u4E0D%u4F1A%u53D1%u751F%u51B2%u7A81%0A%60%60%60c%20%0Astatic%20int%20a%3B%0Aint%20a%3B%0A%60%60%60%0A%0A%23%23%23%204.3.2%20%u51FD%u6570%0Astatic%u58F0%u660E%u7684%u51FD%u6570%u53EF%u4EE5%u5728%u5916%u90E8%u4F7F%u7528%uFF0C%u4E00%u822C%u79F0%u5176%u4E3A%60%u9759%u6001%u51FD%u6570%60%u3002%0A%60%60%60c%0Astatic%20int%20g%28int%20x%29%0A%7B%0A….%0A%7D%20%0A%0Avoid%20f%28%29%0A%7B%0A%09b%20%3D%20g%28a%29%3B%0A%7D%0A%60%60%60%0A%0A%23%23%204.4%20%u5F62%u53C2%u3001%u5B9E%u53C2%u4E0E%u8FD4%u56DE%u503C%0A%23%23%23%204.4.1%20%u5F62%u53C2%u5B9E%u53C2%u7684%u533A%u522B%0A%u8001%u751F%u5E38%u8C08%u4E86%uFF0C%u7528%u6BB5%u4EE3%u7801%u6765%u89E3%u91CA%u4E0B%60%u5F62%u53C2%60%u548C%60%u5B9E%u53C2%60%u3002%0A%60%60%60C%0A%23include%3Cstdio.h%3E%0Avoid%20swap%28int%20a%2Cint%20b%29%0A%7B%0A%20%20%20%20int%20c%20%3D%20a%3B%0A%23include%3Cstdio.h%3E%0Avoid%20swap%28int%20a%2Cint%20b%29%09%09//%u4F20%u7684%u5F62%u53C2%0A%7B%20%20%20%0A%20%20%20%20int%20c%20%3D%20a%3B%0A%20%20%20%20a%20%3D%20b%3B%0A%20%20%20%20b%20%3D%20c%3B%0A%7D%0Avoid%20swap1%28int%20*a%2Cint%20*b%29%20%09//%u4F20%u5B9E%u53C2%0A%7B%0A%0A%20%20%20%20int%20c%20%3D%20*a%3B%20%0A%20%20%20%20*a%20%3D%20*b%3B%20%0A%20%20%20%20*b%20%3D%20c%3B%0A%7D%0Aint%20main%28%29%0A%7B%0A%20%20%20%20int%20a%20%3D%201%2Cb%20%3D%202%3B%0A%20%20%20%20swap%28a%2Cb%29%3B%20%20%20//%u6CA1%u6709%u4EA4%u6362%0A%20%20%20%20printf%28%22%25d%20%25d%5Cn%22%2Ca%20%2Cb%29%3B%20%20%20%20%0A%20%20%20%20swap1%28%26a%2C%26b%29%3B%20%20%20//%u4EA4%u6362%u4E86%0A%20%20%20%20printf%28%22%25d%20%25d%5Cn%22%2Ca%20%2C%20b%29%3B%0A%20%20%20%20return%200%20%3B%0A%7D%0A%60%60%60%0A%23%23%23%204.4.2%20%u5F3A%u5236%u8F6C%u6362%0A%u5F53%u51FD%u6570%u6307%u5B9A%u4E86%u53C2%u6570%u7C7B%u578B%uFF0C%u4F1A%u8FDB%u884C%60%u5F3A%u5236%u8F6C%u6362%60%uFF0C%u6BD4%u5982%uFF1A%0A%60%60%60C%0Adouble%20square%28double%29%3B%0Asquare%282%29%3B%20%09%09%09//%u5408%u6CD5%uFF0C%u4F1A%u81EA%u52A8%u8F6C%u6362%u4E3A%u53CC%u7CBE%u5EA6%u7C7B%u578B%0A%60%60%60%0A%23%23%23%204.4.3%20%u8FD4%u56DE%u503C%0A%u51FD%u6570%u9664%u4E86%60%u6784%u9020%u51FD%u6570%60%u548C%60%u6790%u6784%u51FD%u6570%60%u4E4B%u5916%uFF0C%u90FD%u8981%u58F0%u660E%u8FD4%u56DE%u503C%uFF0Cvoid%u6216%u8005%u5176%u4ED6%u7C7B%u578B%u3002%0A%0A%23%23%204.5%20%u68C0%u67E5%u5916%u90E8%u7C7B%u578B%0A%u5728%u5F15%u7528%60%u5916%u90E8%u53D8%u91CF%60%u7684%u65F6%u5019%u8981%u6CE8%u610F%u6700%u597D%u662F%u7C7B%u578B%u4E00%u6837%uFF0C%u6BD4%u5982%uFF1A%0A%60%60%60c%0Achar%20filename%5B%5D%20%3D%20%22/etc/passwd%22%3B%0A%0Aextern%20char<em>%20filename%3B%09//%u5916%u90E8%u5F15%u7528%0A%60%60%60%0A%u867D%u7136%u6307%u9488%u4E0E%u6570%u7EC4%u597D%u50CF%u662F%u4E00%u6837%u7684%uFF0C%u4F46%u662F%60filename%60%u7684%u7C7B%u578B%u662F%u201C%60%u5B57%u7B26%u6570%u7EC4%60%u201D%uFF0C%u800C%u4E0D%u662F%60%u201C%u5B57%u7B26%u6307%u9488%u201D%60%u3002%u5728%u7B2C%u4E8C%u4E2A%u58F0%u660E%u4E2D%uFF0C%60filename%60%u88AB%u786E%u5B9A%u4E3A%u4E00%u4E2A%60%u6307%u9488%60%u3002%u8FD9%u4E24%u4E2A%u5BF9%60filename%60%u7684%u58F0%u660E%u4F7F%u7528%u5B58%u50A8%u7A7A%u95F4%u7684%u65B9%u5F0F%u662F%u4E0D%u540C%u7684%u3002%0A%0A%23%23%23%23%20%u539F%u5185%u5B58%u5E03%u5C40%0A%21%5BAlt%20text%5D%28./1524645704928.png%29%0A%23%23%23%23%20%u73B0%u5185%u5B58%u5E03%u5C40%0A%21%5BAlt%20text%5D%28./1524645774249.png%29%0A%0A%u5E94%u8BE5%u6539%u4E3A%u540C%u6837%u7C7B%u578B%uFF1A%0A%60%60%60C%0Achar%20filename%5B%5D%20%3D%20%22/etc%22%3B%0Aextern%20char%20filename%5B%5D%3B%0A%0Achar</em>%20filename%3D%20%22/etc%22%3B%0Aextern%20char<em>%20filename%3B%0A%60%60%60%0A%0A%23%23%204.6%20%u5934%u6587%u4EF6%0A%u6BCF%u4E2A%u5916%u90E8%u5BF9%u8C61%u5E94%u53EA%u5728%u4E00%u4E2A%60%u5934%u6587%u4EF6%60%u4E2D%u58F0%u660E%uFF0C%u9700%u8981%u7528%u5230%u8BE5%u5916%u90E8%u5BF9%u8C61%u7684%60%u6240%u6709%u6A21%u5757%60%u90FD%u5E94%u8BE5%u5305%u62EC%u8FD9%u4E2A%60%u5934%u6587%u4EF6%60%u3002%u5B9A%u4E49%u8BE5%u5916%u90E8%u5BF9%u8C61%u7684%u6A21%u5757%u4E5F%u5E94%u8BE5%u5305%u62EC%u8FD9%u4E2A%60%u5934%u6587%u4EF6%60%u3002%u6BD4%u5982%uFF1A%0A%0A**public.h*\</em>%0A%60%60%60c%0Aint%20a%20%3D%201%3B%0Achar<em>%20str%20%3D%20%22123%22%3B%0A%60%60%60%0A**main.c*\</em>%0A%60%60%60c%0A%23include%20%3Cstdio.h%3E%0A%23include%20%22public.h%22%0Aextern%20int%20a%3B%0Aextern%20char<em>%20str%3B%0Aint%20main%28%29%0A%7B%0A%09printf%28%22%25d%5Cn%22%2Ca%29%3B%0A%09return%200%3B%0A%7D%0A%60%60%60%0A%23%23%20%u603B%u7ED3%0AC%u8BED%u8A00%u7684%u8FDE%u63A5%u662F%u4E00%u4E2A%u5F88%u5F3A%u5927%u7684%u4E1C%u897F%uFF0C%u5C06%u5C0F%u7684%u6A21%u5757%u7EC4%u6210%u5927%u7684%u6A21%u5757%uFF0C%u6587%u4EF6%u548C%u53D8%u91CF%u4E4B%u95F4%u80FD%u5F88%u597D%u7684%u8FDB%u884C%u4EA4%u4E92%uFF0C%u4ECE%u800C%u8FBE%u5230*</em>%u9AD8%u5185%u805A%u4F4E%u8026%u5408**%u7684%u6548%u679C%u3002%0A%0A</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/24/3-e8-af-ad-e4-b9-89-e9-99-b7-e9-98-b1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/24/3-e8-af-ad-e4-b9-89-e9-99-b7-e9-98-b1/" class="post-title-link" itemprop="url">第三章 语义“陷阱”</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-24 03:19:47" itemprop="dateCreated datePublished" datetime="2018-04-24T03:19:47+08:00">2018-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第三章-语义“陷阱”"><a href="#第三章-语义“陷阱”" class="headerlink" title="第三章 语义“陷阱”"></a>第三章 语义“陷阱”</h1><p><code>《C陷阱与缺陷》学习笔记``指针``数组``posts</code></p>
<ul>
<li><a href="#第三章-语义陷阱">第三章 语义“陷阱”</a><ul>
<li><a href="#31-指针与数组">3.1 指针与数组</a><ul>
<li><a href="#311-数组名的使用">3.1.1 数组名的使用</a></li>
<li><a href="#312-指针的使用">3.1.2 指针的使用</a></li>
<li><a href="#313-二维数组">3.1.3 二维数组</a></li>
<li><a href="#314-二维数组名的使用">3.1.4 二维数组名的使用</a></li>
</ul>
</li>
<li><a href="#32-非数组的指针">3.2 非数组的指针</a></li>
<li><a href="#33-作为参数的数组声明">3.3 作为参数的数组声明</a></li>
<li><a href="#34-避免举隅法">3.4 避免“举隅法”</a><ul>
<li><a href="#341-指针复制问题">3.4.1 指针复制问题</a></li>
</ul>
</li>
<li><a href="#35-空指针并非空字符串">3.5 空指针并非空字符串</a></li>
<li><a href="#36-边界计算与不对称边界">3.6 边界计算与不对称边界</a><ul>
<li><a href="#361-规定编码风格">3.6.1 规定编码风格</a></li>
</ul>
</li>
<li><a href="#37-求值顺序">3.7 求值顺序</a></li>
<li><a href="#38-运算符和">3.8 运算符&amp;&amp;、||和!</a></li>
<li><a href="#39-整数溢出">3.9 整数溢出</a></li>
<li><a href="#310-main函数的返回值">3.10 main函数的返回值</a></li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
</ul>
<h2 id="3-1-指针与数组"><a href="#3-1-指针与数组" class="headerlink" title="3.1 指针与数组"></a>3.1 指针与数组</h2><p>数组其实就是由指针实现的，任何数组下标运算都等同于一个对应的指针运算。</p>
<pre><code>1.int *ip;
2.int i; 
3.ip = &amp;i; //地址赋值，使ip指向了整型变量i
4.*ip = 17; //通过指针修改i的值， </code></pre><h3 id="3-1-1-数组名的使用"><a href="#3-1-1-数组名的使用" class="headerlink" title="3.1.1 数组名的使用"></a>3.1.1 数组名的使用</h3><p>如果直接使用数组名（一维数组），那么数组名就当作指向该数组下标为0的元素的指针。</p>
<pre><code>1.int a[10];
2.int *p;
3.p = a; //p指向了a数组的首地址
4.int num = *p; //*p就是a[0]的值 </code></pre><h3 id="3-1-2-指针的使用"><a href="#3-1-2-指针的使用" class="headerlink" title="3.1.2 指针的使用"></a>3.1.2 指针的使用</h3><p>指针有时候也可以当成数组使用，二者意思相等。</p>
<pre><code>1.int a[10];
2.int *p;
3.p = a + 2; //p指向了a[2]
4.p++; //p指向了a[3]
5. </code></pre><h3 id="3-1-3-二维数组"><a href="#3-1-3-二维数组" class="headerlink" title="3.1.3 二维数组"></a>3.1.3 二维数组</h3><pre><code>1.int calendar[12][31];
2.int *p;
3.int i;
4.p = calendar[4]; //p指向了calender[4]中下标为0的元素
5.//下面三个式子意思一样
6.i = calendar[4][7];
7.i = *(calendar[4] + 7);
8.i = *(*calendar+4) + 7);</code></pre><p>记住解引用的用法，和数组[]符号意思一样。</p>
<h3 id="3-1-4-二维数组名的使用"><a href="#3-1-4-二维数组名的使用" class="headerlink" title="3.1.4 二维数组名的使用"></a>3.1.4 二维数组名的使用</h3><p>一维数组可以直接使用数组名，但是二维数组不行。比如：</p>
<pre><code>1.int calendar[12][31];
2.int *p;
3.p = calendar; //非法，因为p是指向整型变量的指针，calender是指向数组的指针，类型不同</code></pre><p>需要声明一种指向数组的指针的方法，需要类型相同</p>
<pre><code>1.int calendar[12][31];
2.int (*monthp)[31];
3.monthp = calendar; </code></pre><h2 id="3-2-非数组的指针"><a href="#3-2-非数组的指针" class="headerlink" title="3.2 非数组的指针"></a>3.2 非数组的指针</h2><p><strong>任何指针都需要初始化，否则会成为野指针</strong></p>
<blockquote>
<p>野指针指向一个已删除的对象或未申请访问受限内存区域的指针。与空指针不同，野指针无法通过简单地判断是否为 NULL避免，而只能通过养成良好的编程习惯来尽力减少。对野指针进行操作很容易造成程序错误。</p>
</blockquote>
<p>简单归纳如下：</p>
<ul>
<li><p>指针需要初始化，指向NULL或者一块内存区域;</p>
</li>
<li><p>分配的内存使用完后要及时释放;</p>
</li>
<li><p>malloc分配内存的时候应在字符长度的基础上+1，用来存放结束标志。</p>
<p>1.char *r;<br>2.r = malloc(strlen(s) + 1); </p>
</li>
</ul>
<h2 id="3-3-作为参数的数组声明"><a href="#3-3-作为参数的数组声明" class="headerlink" title="3.3 作为参数的数组声明"></a>3.3 作为参数的数组声明</h2><p>将数组作为参数传到函数里，C语言会自动的将作为参数的数组声明转换成相应的指针声明，所以在传数组的时候只需要写数组名，不需要写大小。</p>
<pre><code>1.int strlen(char s[]) 等于 int strlen(char *s) //都是将首地址传了进去 </code></pre><h2 id="3-4-避免“举隅法”"><a href="#3-4-避免“举隅法”" class="headerlink" title="3.4 避免“举隅法”"></a>3.4 避免“举隅法”</h2><p><strong>简单来说就是不要以<code>整体</code>代表<code>部分</code>，或者以<code>部分</code>代表<code>整体</code></strong></p>
<pre><code>1.char *p, *q;
2.p = &quot;xyz&quot;;</code></pre><p>之前可能以为p的值就是字符串<code>“xyz”</code>，其实不然，p是一个指向由<code>&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;\0&#39;</code>，4个字符组成的数组的起始元素的指针。</p>
<h3 id="3-4-1-指针复制问题"><a href="#3-4-1-指针复制问题" class="headerlink" title="3.4.1 指针复制问题"></a>3.4.1 指针复制问题</h3><p>如果直接执行</p>
<pre><code>1.q = p;</code></pre><p>程序并没有想象中的那样所有值都复制了过来，而是都指向同一地址。</p>
<p><strong>需要记住，复制指针并不同时复制指针指向的数据</strong> 而且如果通过<code>q</code>来修改指针内容，那么<code>p</code>的内容也变了</p>
<pre><code>1.q[1] = &apos;Y&apos;;</code></pre><p>这个时候内存变为<code>&quot;xYz&quot;</code>,p[1]也是<code>&#39;Y&#39;</code>。</p>
<h2 id="3-5-空指针并非空字符串"><a href="#3-5-空指针并非空字符串" class="headerlink" title="3.5 空指针并非空字符串"></a>3.5 空指针并非空字符串</h2><p>在C语言中，<code>NULL</code>和<code>0</code>的值都是一样的，但是为了目的和用途以及容易识别的原因，<strong><code>NULL</code>用于指针和对象，<code>0</code>用于数值对与字符串的结尾，使用’\0’</strong> 在不同的系统中，<code>NULL</code>并非总是和<code>0</code>等同，<strong><code>NULL</code>仅仅代表空值，也就是指向一个不被使用的地址</strong></p>
<h2 id="3-6-边界计算与不对称边界"><a href="#3-6-边界计算与不对称边界" class="headerlink" title="3.6 边界计算与不对称边界"></a>3.6 边界计算与不对称边界</h2><p>C语言里边界问题是一个很容易出错的地方，比如：满足边界X&gt;=16且X&lt;=37的整数有多少个？ 按常规思考，会计算出37-16 = 21个数，但是其实是22个。</p>
<h3 id="3-6-1-规定编码风格"><a href="#3-6-1-规定编码风格" class="headerlink" title="3.6.1 规定编码风格"></a>3.6.1 规定编码风格</h3><p><strong><code>入界点</code></strong>在取值范围里，<strong><code>出界点</code></strong>不在取值范围里。这样的操作带来的效果是惊人的：</p>
<ul>
<li><strong>取值范围的大小就是上界与下界之差；</strong>。</li>
<li><strong>如果取值范围为空，那么上界等于下界；</strong></li>
<li><strong>即使取值范围为空，上界也永远不可能小于下界。</strong></li>
</ul>
<h2 id="3-7-求值顺序"><a href="#3-7-求值顺序" class="headerlink" title="3.7 求值顺序"></a>3.7 求值顺序</h2><p>在使用if语句的时候可能会用到多个条件判断，C语言中判断的顺序是从左至右，比如:</p>
<pre><code>1.if(a &gt; b &amp;&amp; a &gt; c) //如果a &gt; b成立才会判断a &gt; c，不会先判断a &gt; c
2.max = a; </code></pre><h2 id="3-8-运算符-amp-amp-、-和"><a href="#3-8-运算符-amp-amp-、-和" class="headerlink" title="3.8 运算符&amp;&amp;、||和!"></a>3.8 运算符&amp;&amp;、||和!</h2><p>这些都是逻辑运算符，用来判断语句的正确性，可以相互组合起来。但是有时候会<code>少写</code>一个，编译器也不会报错，需要十分小心。</p>
<h2 id="3-9-整数溢出"><a href="#3-9-整数溢出" class="headerlink" title="3.9 整数溢出"></a>3.9 整数溢出</h2><p>C语言里有两类整数算术运算</p>
<ul>
<li><code>无符号运算</code></li>
<li><code>有符号运算</code></li>
</ul>
<p>在无符号算术中，没有“溢出”的说法。</p>
<h2 id="3-10-main函数的返回值"><a href="#3-10-main函数的返回值" class="headerlink" title="3.10 main函数的返回值"></a>3.10 main函数的返回值</h2><p>main函数会有返回值，就想我们平时写程序一样：</p>
<pre><code>1.int main()
2.{
3.        ...
4.        return 0;
5.}</code></pre><p>返回值为<code>0</code>代表程序执行成功，返回值<code>非0</code>则表示程序执行失败！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>数组就是由指针实现的，在进行一些数组操作的时候可以当成指针来使用。同理，在对指针进行操作的时候也可以将其当成数组来操作；</li>
<li>函数传指针或者数组，只需要传首地址即可；</li>
<li>数组不要越界，在遍历的时候遵循<strong><code>“满下界，空上界”</code></strong>原则。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/21/e8-af-ad-e6-b3-95-e9-87-8c-e5-b8-b8-e8-a7-81-e7-9a-84-e9-94-99-e8-af-af/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/21/e8-af-ad-e6-b3-95-e9-87-8c-e5-b8-b8-e8-a7-81-e7-9a-84-e9-94-99-e8-af-af/" class="post-title-link" itemprop="url">语法里常见的错误</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-21 03:07:32" itemprop="dateCreated datePublished" datetime="2018-04-21T03:07:32+08:00">2018-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-语句结束符的分号"><a href="#1-语句结束符的分号" class="headerlink" title="1 语句结束符的分号"></a>1 语句结束符的分号</h3><p>如果在写代码的时候少写了分号或者多加了分号，这样的错误带来的后果是很严重的。有时候编译器可能都不会对其进行报错，这样导致你寻找错误的成本大大增加。比如：</p>
<pre><code>if(x[i] &gt; big);
    big = x[i];</code></pre><p>编译器会正常地接收第一行代码中的分号而不会提示任何警告信息，正确的做法应该是：</p>
<pre><code>if(x[i] &gt; big)
    big = x[i];</code></pre><h3 id="2-switch语句"><a href="#2-switch语句" class="headerlink" title="2 switch语句"></a>2 switch语句</h3><p>C语言的switch语句的控制流程能够依次通过并执行各个case部分，这一点是C语言与众不同之处。但是你有时候会忘记写break语句，这样就会造成意想不到的后果，比如：</p>
<pre><code>switch(color){
case 1:printf(&quot;red&quot;);
case 2:printf(&quot;yellow&quot;);
case 3:printf(&quot;blue&quot;);
}</code></pre><p>如果当color的值为2的时候，编译器会输出“yellowblue”。因为程序的控制流程在执行了第二个printf函数的调用之后，会自然而然的顺序执行下去，第三个printf函数调用也会被执行。所以在写switch语句的时候要相当注意，不过有时候你的需求就是不用加break，那么最好在程序里写上你的注释，这样别人就不会以为是忽略的错误。</p>
<pre><code>case SUBTRACT:
            opnd2 = -opnd2;
            //此处没有break语句

case ADD:
            .....</code></pre><h3 id="3-“悬挂”else引发的问题"><a href="#3-“悬挂”else引发的问题" class="headerlink" title="3 “悬挂”else引发的问题"></a>3 “悬挂”else引发的问题</h3><p><strong>else始终会与同一对括号内最近的且未匹配的if结合</strong></p>
<h3 id="练习2-1"><a href="#练习2-1" class="headerlink" title="练习2-1"></a>练习2-1</h3><p>C语言允许初始化列表中出现多余的逗号，例如：</p>
<pre><code>int days[] = { 31, 28 ,31 , 31,};</code></pre><p>为什么这种特性是有用的？答：方便自动化编写代码，不用单独处理。</p>
<p>​</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/20/e8-bf-90-e7-ae-97-e7-ac-a6-e4-bc-98-e5-85-88-e7-ba-a7-e7-9a-84-e9-97-ae-e9-a2-98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/20/e8-bf-90-e7-ae-97-e7-ac-a6-e4-bc-98-e5-85-88-e7-ba-a7-e7-9a-84-e9-97-ae-e9-a2-98/" class="post-title-link" itemprop="url">运算符优先级的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-20 12:03:07" itemprop="dateCreated datePublished" datetime="2018-04-20T12:03:07+08:00">2018-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="http://47.100.160.51/wordpress/wp-content/uploads/2018/04/1edd33fbc74d915b8ddfe9c96af8aaa1.png" alt=""></p>
<h3 id="结合性的理解"><a href="#结合性的理解" class="headerlink" title="结合性的理解"></a>结合性的理解</h3><p><strong>自左向右</strong>，比如成员运算符‘.’，a.b.c的含义是(a.b).c，而不是a.(b.c)。就是从左到右依次结合。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>优先级依次递减</p>
<h4 id="单目运算符"><a href="#单目运算符" class="headerlink" title="单目运算符"></a>单目运算符</h4><p>运算所需变量为<strong>1个</strong>的运算符（并不是之前理解的一个字符就是单目运算符），又称一元运算符，其中有</p>
<ul>
<li>!（逻辑非运算符）</li>
<li>~（按位取反运算符)</li>
<li>++（自增运算符）</li>
<li>—（自减运算符）</li>
</ul>
<p>它们的结合性是<strong>从右到左</strong>，比如*p++会被编译器解释成*(p++)，即取指针p所指向的对象，然后将p递增1；而不是(*p)++，即取指针p所指向的对象，然后将该对象递增1。</p>
<h4 id="双目运算符"><a href="#双目运算符" class="headerlink" title="双目运算符"></a>双目运算符</h4><p>顾名思义，需要2个变量的运算符。</p>
<h5 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h5><p>比如加减乘除操作，但是乘除的优先级大于加减，+ - * /。</p>
<h5 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h5><p>&lt;&lt;和&gt;&gt;，不是cout里的输出流运算符，而是移位。比如:</p>
<ul>
<li><p>&lt;&lt;是左移运算符，i&lt;&lt;4,是按位左移4位，例如：</p>
<p>i=8;</p>
<p>i&lt;&lt;4位后，，变成：</p>
<p>0000 0000 0000 1000 =8</p>
<p>0000 0000 1000 0000 =128</p>
</li>
</ul>
<h5 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h5><p>大于小于，大于等于，大于小于。不多解释</p>
<p>以上的结合性都是<strong>从左至右</strong></p>
<h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><p>需要三个变量的运算符，<strong>?:</strong>，比如：</p>
<pre><code>tax_rate = income&gt;40000 &amp;&amp; residency&lt;5 ? 3.5 : 2.0;</code></pre><p>上述代码的意思是：如果income大于40000且residency小于5，那么tax_rate的值为3.5否则为2.0;</p>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>=，+=等等赋值运算符，结合性为<strong>从右至左</strong></p>
<pre><code>home_score = visitor_score = 0;</code></pre><p>和下面的语句是一样的意思:</p>
<pre><code>visitor_score = 0;
home_score = visitor_score;</code></pre><p>​</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/19/linux-e8-bf-9b-e7-a8-8b-e9-80-9a-e4-bf-a1-e4-b9-8b-e4-bf-a1-e5-8f-b7-e9-87-8f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/19/linux-e8-bf-9b-e7-a8-8b-e9-80-9a-e4-bf-a1-e4-b9-8b-e4-bf-a1-e5-8f-b7-e9-87-8f/" class="post-title-link" itemprop="url">linux进程通信之信号量</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-19 06:10:26" itemprop="dateCreated datePublished" datetime="2018-04-19T06:10:26+08:00">2018-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>shmctl删除内存。 信号量，虽说可以于通讯，但是更加适合于进程间的同步。通过PV操作相互操作。 编程模型：1、semget：创建信号量，或者获取信号量</p>
<pre><code>semget(ftok(&quot;.&quot;,123),2,IPC_CREAT | IPC_EXCL |0666)  ;</code></pre><p>2、semctl：初始化信号量，控制信号量 3、semop：做PV操作（对信号量做加减操作）</p>
<blockquote>
<p>ftok，共享内存，消息队列，信号量它们三个都是找一个中间介质，来进行通信的。这种介质多的是，就是要要怎么区分</p>
</blockquote>
<p>如下代码： PV减：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/ipc.h&gt;
#include&lt;sys/sem.h&gt;
   union semun {
               int              val;    /* Value for SETVAL */
               struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */
               unsigned short  *array;  /* Array for GETALL, SETALL */
               struct seminfo  *__buf;  /* Buffer for IPC_INFO
                                           (Linux-specific) */
           };  

int main()

{
//  int semid = semget(ftok(&quot;1&quot;,123),2,IPC_CREAT | IPC_EXCL |0666)  ;
    int semid = semget(ftok(&quot;1&quot;,123),0,0)  ;
    union semun v;
    v.val = 3;
    int ret = semctl(semid,1,SETVAL,v);

    if(ret == -1) printf(&quot;semctl err :%m&quot;),exit(-1);

    struct  sembuf sbf;
    sbf.sem_num = 1;
    sbf.sem_op = -1;
    sbf.sem_flg = 0;

    while(1)
    {
        semop(semid,&amp;sbf,1);
        printf(&quot;gogogo\n&quot;);
    }
    return 0;
}</code></pre><p>PV加操作：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;unistd.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/ipc.h&gt;
#include&lt;sys/sem.h&gt;
   union semun {
               int              val;    /* Value for SETVAL */
               struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */
               unsigned short  *array;  /* Array for GETALL, SETALL */
               struct seminfo  *__buf;  /* Buffer for IPC_INFO
                                           (Linux-specific) */
           };  
int main()
//  int semid = semget(ftok(&quot;1&quot;,123),2,IPC_CREAT | IPC_EXCL |0666)  ;
    int semid = semget(ftok(&quot;1&quot;,123),0,0)  ;

    struct  sembuf sbf;
    sbf.sem_num = 1;
    sbf.sem_op = 1;   //正数是加，负数是减
    sbf.sem_flg = 0;  

    while(1)
    {
        semop(semid,&amp;sbf,1);    //对信号量进行操作
        sleep(1);

        printf(&quot;gogogo\n&quot;);
    }   
    return 0;
}</code></pre><p>​</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/15/e6-9c-89-a-e3-80-81-b-e3-80-81-c-e3-80-81-d-e5-9b-9b-e4-b8-aa-e4-ba-ba-ef-bc-8c-e8-a6-81-e5-9c-a8-e5-a4-9c-e9-87-8c-e8-bf-87-e4-b8-80-e5-ba-a7-e6-a1-a5-e3-80-82-e4-bb-96-e4-bb-ac-e9-80-9a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/15/e6-9c-89-a-e3-80-81-b-e3-80-81-c-e3-80-81-d-e5-9b-9b-e4-b8-aa-e4-ba-ba-ef-bc-8c-e8-a6-81-e5-9c-a8-e5-a4-9c-e9-87-8c-e8-bf-87-e4-b8-80-e5-ba-a7-e6-a1-a5-e3-80-82-e4-bb-96-e4-bb-ac-e9-80-9a/" class="post-title-link" itemprop="url">智力题——过桥问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-15 02:33:26" itemprop="dateCreated datePublished" datetime="2018-04-15T02:33:26+08:00">2018-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="过桥问题"><a href="#过桥问题" class="headerlink" title="过桥问题"></a>过桥问题</h2><blockquote>
<p>有 A 、 B 、 C 、 D 四个人，要在夜里过一座桥。他们通过这座桥分别需要耗时 1 、 2 、 5 、 10 分钟，只有一支手电，并且同时最多只能两个人一起过桥。请问，如何安排，能够在 17 分钟内这四个人都过桥？</p>
</blockquote>
<h3 id="类似于多线程调度，要保证用时最长的同时运行"><a href="#类似于多线程调度，要保证用时最长的同时运行" class="headerlink" title="类似于多线程调度，要保证用时最长的同时运行"></a>类似于多线程调度，要保证用时最长的同时运行</h3><p>Solution:关键是时间最长的两个人必须同时过桥The First Time ： A(1) 和 B(2) 过桥， A(1) 返回 Cost ： 1+2The Second Time ： C(5) 和 D(10) 过桥， B(2) 返回 Cost ： 10+2The Third Time A(1) 和 B(2) 过桥 Cost ： 2Total Time Cost ： (1+2)+(10+2)+2=17 minutes ​</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/15/e5-ad-97-e7-ac-a6-e4-b8-b2-e6-8b-b7-e8-b4-9d-sprintf-e3-80-81strcpy-e5-8f-8a-memcpy-e5-87-bd-e6-95-b0-e7-9a-84-e5-8c-ba-e5-88-ab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/15/e5-ad-97-e7-ac-a6-e4-b8-b2-e6-8b-b7-e8-b4-9d-sprintf-e3-80-81strcpy-e5-8f-8a-memcpy-e5-87-bd-e6-95-b0-e7-9a-84-e5-8c-ba-e5-88-ab/" class="post-title-link" itemprop="url">字符串拷贝 sprintf、strcpy 及 memcpy 函数的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-15 02:24:50" itemprop="dateCreated datePublished" datetime="2018-04-15T02:24:50+08:00">2018-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="这些函数的区别在于实现功能以及操作对象不同。"><a href="#这些函数的区别在于实现功能以及操作对象不同。" class="headerlink" title="这些函数的区别在于实现功能以及操作对象不同。"></a>这些函数的区别在于实现功能以及操作对象不同。</h3><ul>
<li>strcpy 函数操作的对象是字符串，完成从源字符串到目的字符串的拷贝功能。</li>
<li>sprintf 函数操作的对象不限于字符串：虽然目的对象是字符串，但是源对象可以是字符串、也可以是任意基本类型的数据。这个函数主要用来实现（字符串或基本数据类型）向字符串的转换功能。如果源对象是字符串，并且指定 %s 格式符，也可实现字符串拷贝功能。</li>
<li>memcpy 函数顾名思义就是内存拷贝，实现将一个内存块的内容复制到另一个内存块这一功能。内存块由其首地址以及长度确定。程序中出现的实体对象，不论是什么类型，其最终表现就是在内存中占据一席之地（一个内存区间或块）。因此，memcpy 的操作对象不局限于某一类数据类型，或者说可适用于任意数据类型，只要能给出对象的起始地址和内存长度信息、并且对象具有可操作性即可。鉴于memcpy 函数等长拷贝的特点以及数据类型代表的物理意义，memcpy 函数通常限于同种类型数据或对象之间的拷贝，其中当然也包括字符串拷贝以及基本数据类型的拷贝。</li>
</ul>
<h4 id="对于字符串拷贝来说，用上述三个函数都可以实现，但是其实现的效率和使用的方便程度不同："><a href="#对于字符串拷贝来说，用上述三个函数都可以实现，但是其实现的效率和使用的方便程度不同：" class="headerlink" title="对于字符串拷贝来说，用上述三个函数都可以实现，但是其实现的效率和使用的方便程度不同："></a>对于字符串拷贝来说，用上述三个函数都可以实现，但是其实现的效率和使用的方便程度不同：</h4><ul>
<li>strcpy 无疑是最合适的选择：效率高且调用方便。</li>
<li>sprintf 要额外指定格式符并且进行格式转化，麻烦且效率不高。</li>
<li>memcpy 虽然高效，但是需要额外提供拷贝的内存长度这一参数，易错且使用不便；并且如果长度指定过大的话（最优长度是源字符串长度 + 1），还会带来性能的下降。其实 strcpy 函数一般是在内部调用 memcpy 函数或者用汇编直接实现的，以达到高效的目的。因此，使用 memcpy 和 strcpy 拷贝字符串在性能上应该没有什么大的差别。</li>
</ul>
<p>对于非字符串类型的数据的复制来说，strcpy 和 snprintf 一般就无能为力了，可是对 memcpy 却没有什么影响。但是，对于基本数据类型来说，尽管可以用 memcpy 进行拷贝，由于有赋值运算符可以方便且高效地进行同种或兼容类型的数据之间的拷贝，所以这种情况下 memcpy 几乎不被使用 。memcpy 的长处是用来实现（通常是内部实现居多）对结构或者数组的拷贝，其目的是或者高效，或者使用方便，甚或两者兼有。</p>
<p>​</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/14/c-e5-a4-9a-e6-80-81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/14/c-e5-a4-9a-e6-80-81/" class="post-title-link" itemprop="url">C++多态</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-14 02:31:22" itemprop="dateCreated datePublished" datetime="2018-04-14T02:31:22+08:00">2018-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>多态性是将接口与实现进行分离；用形象的语言来解释就是实现以共同的方法，但因个体差异，而采用不同的策略。</p>
</blockquote>
<h3 id="多态的定义"><a href="#多态的定义" class="headerlink" title="多态的定义"></a>多态的定义</h3><p>多态性可以简单地概括为“<strong>一个接口，多种方法</strong>”，程序在运行时才决定调用的函数。</p>
<h3 id="多态的条件"><a href="#多态的条件" class="headerlink" title="多态的条件"></a>多态的条件</h3><p>C++多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数；形成多态必须具备三个条件：1、必须存在继承关系；2、继承关系必须有同名虚函数（其中虚函数是在基类中使用关键字Virtual声明的函数，在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数）；3、存在基类类型的指针或者引用，通过该指针或引用调用虚函数；</p>
<h3 id="多态和重载的区别"><a href="#多态和重载的区别" class="headerlink" title="多态和重载的区别"></a>多态和重载的区别</h3><p>C++多态性是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。（这里我觉得要补充，重写的话可以有两种，直接重写成员函数和重写虚函数，只有重写了虚函数的才能算作是体现了C++多态性）而重载则是允许有多个同名的函数，而这些函数的参数列表不同，允许参数个数不同，参数类型不同，或者两者都不同。编译器会根据这些函数的不同列表，将同名的函数的名称做修饰，从而生成一些不同名称的预处理函数，来实现同名函数调用时的重载问题。但这并没有体现多态性。</p>
<h3 id="多态的作用"><a href="#多态的作用" class="headerlink" title="多态的作用"></a>多态的作用</h3><blockquote>
<p>封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。也就是说，不论传递过来的究竟是那个类的对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。</p>
</blockquote>
<p>（1）多态技术允许将基类指针或基类引用指向派生类对象。（2）把不同派生类的对象都当作基类对象来看待，可以屏蔽不同派生类之间的差异，从而写出通用的代码以适应需求的不断变化。</p>
<h3 id="多态的分类"><a href="#多态的分类" class="headerlink" title="多态的分类"></a>多态的分类</h3><p>多态分为两种：</p>
<ul>
<li>静态多态，是指编译时候的多态，通过函数重载或者运算符重载实现。</li>
<li>动态多态，是指运行时候的多态，通过虚函数与基类指针共同作用实现。</li>
</ul>
<p>​</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tanwenbo</p>
  <div class="site-description" itemprop="description">enjoy share</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">119</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tanwenbo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
