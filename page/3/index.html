<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="enjoy share">
<meta property="og:type" content="website">
<meta property="og:title" content="hhyvs111">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="hhyvs111">
<meta property="og:description" content="enjoy share">
<meta property="article:author" content="tanwenbo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>hhyvs111</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hhyvs111</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Be a great man</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/04/e7-ba-bf-e7-a8-8b-e5-ae-89-e5-85-a8-e7-9a-84-e5-af-b9-e8-b1-a1-e7-94-9f-e5-91-bd-e6-9c-9f-e7-ae-a1-e7-90-86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/04/e7-ba-bf-e7-a8-8b-e5-ae-89-e5-85-a8-e7-9a-84-e5-af-b9-e8-b1-a1-e7-94-9f-e5-91-bd-e6-9c-9f-e7-ae-a1-e7-90-86/" class="post-title-link" itemprop="url">线程安全的对象生命期管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-04 06:59:50" itemprop="dateCreated datePublished" datetime="2019-02-04T06:59:50+08:00">2019-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="线程安全的对象生命期管理"><a href="#线程安全的对象生命期管理" class="headerlink" title="线程安全的对象生命期管理"></a>线程安全的对象生命期管理</h1><ul>
<li><p>线程安全的对象生命期管理</p>
</li>
<li><p>1 前言</p>
<ul>
<li>1.1 Observer设计模式</li>
<li>1.2 Race Conditoin</li>
</ul>
</li>
<li><p>2 析构函数遇到多线程</p>
<ul>
<li>2.1 线程安全的定义</li>
<li>2.2 MutexLock与MutexLockGuard</li>
<li>2.3 一个线程安全的Counter示例</li>
</ul>
</li>
<li><p>3 使用智能指针</p>
<ul>
<li>3.1 内存问题</li>
<li>3.2 线程的RAII handle</li>
</ul>
</li>
</ul>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>编写线程安全的类不是难事，用同步原语（synchronization primitives）保护内部状态即可。但是对象的生与死不能由对象自身拥有的 mutex（互斥器）来保护。如何避免对象析构时可能存在的race condition（竞态条件）是 C++ 多线程编程面临的 基本问题，可以借助 Boost 库中的 <code>shared_ptr</code> 和 <code>weak_ptr</code> 完美解决。这也是实现线程安全的Observer模式的必备技术。</p>
<h3 id="1-1-Observer设计模式"><a href="#1-1-Observer设计模式" class="headerlink" title="1.1 Observer设计模式"></a>1.1 Observer设计模式</h3><p>当对象间存在一对多关系是，则使用观察者模式。比如，当一个对象被修改时，则会自动通知它的依赖对象。</p>
<h3 id="1-2-Race-Conditoin"><a href="#1-2-Race-Conditoin" class="headerlink" title="1.2 Race Conditoin"></a>1.2 Race Conditoin</h3><p>翻译为竞态条件，也就是资源的争夺吧。书上给出三种竞态条件：</p>
<ul>
<li>在即将析构一个对象时，从何而知此刻是否有别的线程正在执行该对象的成员函数？</li>
<li>如何保证在执行成员函数期间，对象不会在另一个线程被析构？</li>
<li>在调用某个对象的成员函数之前，如何得知这个对象还活着？它的析构函数会不会碰巧执行到一半？</li>
</ul>
<p>这里也是通过使用智能指针解决这个问题。</p>
<h2 id="2-析构函数遇到多线程"><a href="#2-析构函数遇到多线程" class="headerlink" title="2 析构函数遇到多线程"></a>2 析构函数遇到多线程</h2><p>上面说的各种条件各种模式也是为了要正确释放资源，这里如何处理好多线程中析构函数的使用就是个关键。</p>
<h3 id="2-1-线程安全的定义"><a href="#2-1-线程安全的定义" class="headerlink" title="2.1 线程安全的定义"></a>2.1 线程安全的定义</h3><p>线程安全的class应当满足以下三个条件：</p>
<ul>
<li>多个线程同时访问时，其表现出正确的行为。</li>
<li>无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织；</li>
<li>调用端代码无须额外的同步或其他协调动作。</li>
</ul>
<p>一般的std里的vector之类的都是需要加锁才能供多个线程同时访问！</p>
<h3 id="2-2-MutexLock与MutexLockGuard"><a href="#2-2-MutexLock与MutexLockGuard" class="headerlink" title="2.2 MutexLock与MutexLockGuard"></a>2.2 MutexLock与MutexLockGuard</h3><p>MutexLock 封装临界区（critical section），这是一个简单的资源类在Linux下是pthread_mutex_t，默认是不可重入的。 MutexLockGuard封装临界区的进入和退出，即加锁和解锁。</p>
<h3 id="2-3-一个线程安全的Counter示例"><a href="#2-3-一个线程安全的Counter示例" class="headerlink" title="2.3 一个线程安全的Counter示例"></a>2.3 一个线程安全的Counter示例</h3><pre><code>class Counter : boost::noncopyable {
// copy-ctor and assignment should be private by default for a class. public:
    Counter() : value_(0) {}
    int64_t value() const; 
    int64_t getAndIncrease();
private:
    int64_t value_; mutable MutexLock mutex_; 
 };
 //上面是类定义</code></pre><p>类定义，具体实现如下：</p>
<pre><code>int64_t Counter::value() const {
    MutexLockGuard lock(mutex_);
    // lock 的析构会晚于返回对象的构造， // 因此有效地保护了这个共享数据。
    return value_; 
}

int64_t Counter::getAndIncrease() {
    MutexLockGuard lock(mutex_);
    int64_t ret = value_++;
    return ret; 
} // In a real world, atomic operations are preferred.
// 当然在实际项目中，这个 class 用原子操作更合理，这里用锁仅仅为了举例。</code></pre><h2 id="3-使用智能指针"><a href="#3-使用智能指针" class="headerlink" title="3 使用智能指针"></a>3 使用智能指针</h2><p>这里也用到了share_ptr，记录一下几关键点。</p>
<ul>
<li>shared_ptr 控制对象的生命期。shared_ptr 是强引用（想象成用铁丝绑住堆上 的对象）， 只要有一个指向 x 对象的 shared_ptr 存在， 该 x 对象就不会析构。 当指向对象 x 的最后一个 shared_ptr 析构或 reset() 的时候，x 保证会被销毁。</li>
<li>weak_ptr 不控制对象的生命期，但是它知道对象是否还活着（想象成用棉线轻 轻拴住堆上的对象）。如果对象还活着，那么它可以提升（promote）为有效的 shared_ptr；如果对象已经死了，提升会失败，返回一个空的 shared_ptr。“提升/lock()”行为是线程安全的。</li>
<li>shared_ptr/weak_ptr 的“计数”在主流平台上是原子操作，没有用锁，性能不俗。</li>
<li>shared_ptr/weak_ptr 的线程安全级别与 std::string 和 STL 容器一样，后面还会讲。</li>
</ul>
<h3 id="3-1-内存问题"><a href="#3-1-内存问题" class="headerlink" title="3.1 内存问题"></a>3.1 内存问题</h3><p>没有正确处理好这个指针等资源的释放就会造成很多内存问题。 C++ 里可能出现的内存问题大致有这么几个方面：</p>
<ol>
<li>缓冲区溢出（buffer overrun）。</li>
<li>空悬指针/野指针。</li>
<li>重复释放（double delete）。</li>
<li>内存泄漏（memory leak）。</li>
<li>不配对的 new[]/delete。</li>
<li>内存碎片（memory fragmentation）。</li>
</ol>
<p>正确使用智能指针能很轻易地解决前面 5 个问题， 解决第 6 个问题需要别的思路。</p>
<h3 id="3-2-线程的RAII-handle"><a href="#3-2-线程的RAII-handle" class="headerlink" title="3.2 线程的RAII handle"></a>3.2 线程的RAII handle</h3><p>我认为 RAII（资源获取即初始化）是 C++ 语言区别于 其他所有编程语言的最重要的特性， 一个不懂 RAII 的 C++ 程序员不是一个合格的 C++ 程序员。初学 C++ 的教条是“new 和 delete 要配对，new 了之后要记着 delete”； 如果使用 RAII [CCS，条款 13] ，要改成“每一个明确的资源配置动作（例如 new）都应 该在单一语句中执行， 并在该语句中立刻将配置获得的资源交给 handle 对象（如 shared_ptr），程序中一般不出现 delete”。shared_ptr 是管理共享资源的利器，需要 注意避免循环引用，通常的做法是 owner 持有指向 child 的 shared_ptr，child 持有 指向 owner 的 weak_ptr。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/02/e8-99-9a-e5-87-bd-e6-95-b0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/02/e8-99-9a-e5-87-bd-e6-95-b0/" class="post-title-link" itemprop="url">虚函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-02 06:47:47" itemprop="dateCreated datePublished" datetime="2019-02-02T06:47:47+08:00">2019-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><ul>
<li>虚函数<ul>
<li>定义<ul>
<li>虚函数表</li>
<li>虚函数指针</li>
</ul>
</li>
<li>final和override说明符<ul>
<li>错误原因</li>
<li>解决方法</li>
</ul>
</li>
<li>虚函数与默认实参<ul>
<li>回避虚函数</li>
</ul>
</li>
<li>纯虚函数<ul>
<li>应用场景</li>
<li>抽象基类</li>
<li>实现抽象功能</li>
</ul>
</li>
<li>小结</li>
</ul>
</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>如前所述，在C++语言中，当我们使用<strong>基类的引用或指针</strong>调用一个虚成员函数时会执行动态绑定。因为我们直到运行时才能知道到底调用了哪个版本的虚函数，所以所有虚函数都必须有定义。通常情况下，如果我们不使用某个函数，则无须为该函数提供定义。但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为连编译器也无法确定到底会使用哪个虚函数。</p>
<blockquote>
<p>动态绑定只有当我们通过指针或引用调用虚函数时才会发生</p>
</blockquote>
<h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p>类的所有对象共用一张虚函数表vtable，存有类里所有的函数指针，当派生类重写了基类的虚函数，那么派生类的虚函数表会用派生类里的函数覆盖掉基类的函数，实现动态绑定。</p>
<h3 id="虚函数指针"><a href="#虚函数指针" class="headerlink" title="虚函数指针"></a>虚函数指针</h3><p>每个对象的结构体中都会多出一个虚函数指针vptr，指向已经被覆盖了的虚函数表。</p>
<h2 id="final和override说明符"><a href="#final和override说明符" class="headerlink" title="final和override说明符"></a>final和override说明符</h2><h3 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h3><p>派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。此时，派生类的函数并没有覆盖掉基类中的版本。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>要想调试并发现这样的错误显然非常困难。在C++11 新标准中我们可以使用 override关键字来说明派生类中的虚函数。这么做的好处是在使得程序员的意图更加清晰的同时让编译器可以为我们发现一些错误，后者在编程实践中显得更加重要。如果我们使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错:</p>
<pre><code>struct B {
    virtual void f1 (int) const;
    virtual void f2 () ;
    void f3() ;
};
structD1:B{
    void f1 (int) const override;//正确: f1与基类中的f1匹配
    void f2 (int) override; //错误:B没有形如f2(int)的函数
    void f3() override;  //错误:f3不是虚函数
    void f4() override;  //错误: B没有名为f4的函数
};</code></pre><p>在D1中，f1的override说明符是正确的，因为基类和派生类中的f1都是const成员，并且它们都接受一个int返回void,所以D1中的f1正确地覆盖了它从B中继承而来的虚函数。</p>
<p>D1中f2的声明与B中f2的声明不匹配，显然B中定义的f2不接受任何参数而D1,的f2接受一个int。因为这两个声明不匹配，所以D1的f2不能覆盖B的f2,它是一个新函数，仅仅是名字恰好与原来的函数- -样 而已。因为我们使用override 所表达的意思是我们希望能覆盖基类中的虚函数而实际上并未做到，所以编译器会报错。</p>
<h2 id="虚函数与默认实参"><a href="#虚函数与默认实参" class="headerlink" title="虚函数与默认实参"></a>虚函数与默认实参</h2><p>和其它函数一样，虚函数也可以拥有默认实参。如果某次函数调用了默认实参，则该实参值由本次调用的静态类型决定。</p>
<p>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</p>
<h3 id="回避虚函数"><a href="#回避虚函数" class="headerlink" title="回避虚函数"></a>回避虚函数</h3><p>直接使用作用域运算符禁止使用虚函数。</p>
<pre><code>//强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么
double undiscounted = baseP-&gt;Quote::net price (42) ;</code></pre><p>该代码强行调用Quote的net_price函数，而不管baseP实际指向的对象类型到底是什么。该调用将在编译时完成解析。</p>
<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>假设我们希望扩展书店程序并令其支持几种不同的折扣策略。除了购买量超过-一定数量享受折扣外，我们也可能提供另外一种策略,即购买量不超过某个限额时可以享受折扣，但是一旦超过限额就要按原价支付。或者折扣策略还可能是购买量超过一定数量后购买的全部书籍都享受折扣，否则全都不打折。</p>
<p>上面的每个策略都要求一个购买量的值和一个折扣值。我们可以定义一个新的名为Disc_quote的类来支持不同的折扣策略，其中Disc_quote负责保存购买量的值和折扣值。其他的表示某种特定策略的类(如Bulk_uote) 将分别继承自Disc_quote,每个派生类通过定义自己的net_price函数来实现各自的折扣策略。</p>
<p>在定义Disc_quote类之前，首先要确定它的net_price函数完成什么工作。显然我们的Disc_quote类与任何特定的折扣策略都无关，因此Disc_quote类中的,net_price函数是没有实际含义的。</p>
<p>我们可以在Disc_quote类中不定义新的net_price,此时，Disc quote 将继承Quote中的net_price 函数。</p>
<p>然而，这样的设计可能导致用户编写出一些无意义的代码。用户可能会创建一个Disc_quote对象并为其提供购买量和折扣值,如果将该对象传给一个像print_total这样的函数，则程序将调用Quote版本的net_price。显然，最终计算出的销售价格并没有考虑我们在创建对象时提供的折扣值，因此上述操作毫无意义。</p>
<blockquote>
<p>简单来说就是这个类是一个抽象的，是一个概念并不是某个具体的。可以用来定义接口，以实现不同的操作。</p>
</blockquote>
<p>认真思考上面描述的情形我们可以发现，关键问题并不仅仅是不知道应该如何定义net_price,而是我们根本就不希望用户创建一个Disc_quote 对象。Disc_quote类表示的是一本打折书籍的通用概念，而非某种具体的折扣策略。</p>
<h3 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h3><p>含有纯虚函数的类是抽象基类，抽象基类负责定义接口，后续的其他类可以覆盖该接口。我们不能(直接)创建一个抽象基类的对象。因为Disc_quote将net_price定义成了纯虚函数，所以我们不能定义Disc_quote的对象。我们可以定义Disc_quote的派生类的对象，前提是这些类覆盖了net price 函数:</p>
<pre><code>// Disc_ quote声明了纯虚函数，而Bulk_ quote将覆盖该函数
Disc_quote discounted;  //错误:不能定义Disc_ quote的对象
Bulk_quote bulk; //正确:Bulkquote中没有纯虚函数</code></pre><p>Disc_ quote的派生类必须给出自己的net_price定义，否则它们仍将是抽象基类。</p>
<h3 id="实现抽象功能"><a href="#实现抽象功能" class="headerlink" title="实现抽象功能"></a>实现抽象功能</h3><p>可以重新实现Bulk_quote了，这一次让它继承Disc_quote而非Quote：</p>
<pre><code>//当同一书籍的销售量超过某个值时启用折扣
//折扣的值是一-个小于1的正的小数值，以此来降低正常销售价格.
class Bulk_quote : public Disc_quote {
public:
    Bulk_quote() = default;
    Bulk_quote (const std::string&amp; book, double price,
    std::size_t qty, double disc) :
    Disc_quote(book, price, qty, disc) { }
    . //覆盖基类中的函数版本以实现一种新的折扣策略
    double net_price (std::size_t) const override;
};</code></pre><p>这个版本的Bulk_quote的直接基类是Disc_quote，间接基类是Quote。 每个Bulk_quote 对象包含三个子对象:一个(空的) Bulk_quote 部分、一个Disc_quote子对象和一个Quote子对象。</p>
<p>如前所述，每个类各自控制其对象的初始化过程。因此，即使Bulk_quote没有自己的数据成员，它也仍然需要像原来一样提供一个接受四个参数的构造函数。该构造函数将它的实参传递给Disc_quote的构造函数，随后Disc_quote的构造函数继续调用Quote的构造函数。Quote的构造函数首先初始化bulk的bookNo和price成员，当Quote的构造函数结束后，开始运行Disc_quote 的构造函数并初始化quantity和、discount成员，最后运行Bulk_quote的构造函数，该函数无须执行实际的初始化或其他工作。</p>
<blockquote>
<p>这个概念有点牛批啊，一环接一环，可以用派生类的参数构造基类参数。</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>继承使得我们可以编写一些新的类，这些新类既能共享其基类的行为，又能根据需要覆盖或添加行为。动态绑定使得我们可以忽略类型之间的差异，其机理是在运行时根据对象的动态类型来选择运行函数的哪个版本。继承和动态绑定的结合使得我们能够编写具有特定类型行为但又独立于类型的程序。</p>
<p>在C++语言中，动态绑定只作用于虚函数，并且需要通过指针或引用调用。</p>
<p>在派生类对象中包含有与它的每个基类对应的子对象。因为所有派生类对象都含有基类部分，所以我们能将派生类的引用或指针转换为一个可访问的基类引用或指针。</p>
<p>当执行派生类的构造、拷贝、移动和赋值操作时，首先构造、拷贝、移动和赋值其中的基类部分，然后才轮到派生类部分。析构函数的执行顺序则正好相反，首先销毁派生类，接下来执行基类子对象的析构函数。基类通常都应该定义一个虚析构函数，即使基类根本不需要析构函数也最好这么做。<strong>将基类的析构函数定义成虚函数的原因是为了确保当我们删除一个基类指针，而该指针实际指向一个派生类对象时，程序也能正确运行</strong>。</p>
<p>派生类为它的每个基类提供一个保护级别。public基类的成员也是派生类接口的一部分; private基类的成员是不可访问的; protected基类的成员对于派生类的派生类是可访问的，但是对于派生类的用户不可访问。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/30/e5-8a-a8-e6-80-81-e5-86-85-e5-ad-98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/30/e5-8a-a8-e6-80-81-e5-86-85-e5-ad-98/" class="post-title-link" itemprop="url">动态内存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-30 04:08:44" itemprop="dateCreated datePublished" datetime="2019-01-30T04:08:44+08:00">2019-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><ul>
<li>动态内存<ul>
<li>智能指针<ul>
<li>shared_ptr<ul>
<li>引用计数</li>
<li>析构函数</li>
<li>make_shared函数</li>
</ul>
</li>
<li>unique_ptr</li>
</ul>
</li>
<li>直接管理内存<ul>
<li>new和delete<ul>
<li>列表初始化</li>
<li>指针值和delete</li>
<li>空悬指针</li>
</ul>
</li>
<li>智能指针陷阱</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这一章感觉还挺重要，主要是这个智能指针和动态内存。</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>标准库定义了两个智能指针类型来管理动态分配的对象，当一个对象应该被释放时，指向它的智能指针可以确保自动地释放它。</p>
<p><code>shared_ptr</code>允许多个指针指向同一个对象; <code>unique_ptr</code>则“独占”所指向的对象。标准库还定义了一个名为<code>weak_ptr</code>的伴随类，它是一种弱引用，指向<code>shared_ptr</code>所管理的对象。这三种类型都定义在memory头文件中。</p>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>类似vector，智能指针也是模板，因此当我们创建一个智能指针时，必须提供额外的信息——指针可以指向的类型。与vector一样，我们在尖括号内给出类型，之后是所定义的这种智能指针的名字:</p>
<pre><code>shared_ptr&lt;string&gt; p1; // shared ptr，可以指向string
shared_ptr&lt;list&lt;int&gt;&gt; p2; // shared ptr，可以指向int的list</code></pre><p>默认初始化的智能指针中保存着一个空指针。</p>
<p>它的操作和一般指针一样，都有解引用等操作。将p作为一个条件判断，若p指向一个对象，则为true。</p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>当进行拷贝或赋值操作时，每个<code>shared_ptr</code>都会记录有多少个其他<code>shared_ptr</code> 指向相同的对象:</p>
<pre><code>auto p = make shared&lt;int&gt;(42); // p指向的对象只有p一个引用者
auto q(p); // p和q指向相同对象，此对象有两个引用者</code></pre><p>我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数( reference count)。无论何时我们拷贝一个<code>shared_ptr</code>，计数器都会递增。例如，当用一个<code>shared_ptr</code>初始化另一个<code>shared_ptr</code>， 或将它作为参数传递给一个函数以及作为函数的返回值时，它所关联的计数器就会递增。当我们给shared_ptr赋予一个新值或是shared_ptr被销毁(例如一个局部的shared_ptr离开其作用域)时，计数器就会递减。</p>
<p><strong>一旦一个shared ptr的计数器变为0，它就会自动释放自已所管理的对象:</strong></p>
<pre><code>auto r = make shared&lt;int&gt;(42); // r指向的int只有一个引用者
r=q;//给r赋值，令它指向另一个地址
//递增q指向的对象的引用计数
//递减r原来指向的对象的引用计数
// r原来指向的对象已没有引用者，会自动释放</code></pre><p>此例中我们分配了一个int,将其指针保存在r中。接下来，我们将一个新值赋予r。在此情况下，r是唯一指向此int的shared_ptr, 在把q赋给r的过程中，此int被自动释放。</p>
<blockquote>
<p>有点像是Linux的内核引用计数，父子进程、socket等使用。</p>
</blockquote>
<p>当创建一个对象的实例并在堆上申请内存时，对象的引用计数就为1，在其他对象中需要持有这个对象时，就需要把该对象的引用计数加1，需要释放一个对象时，就将该对象的引用计数减1，直至对象的引用计数为0，对象的内存会被立刻释放。</p>
<h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p>智能指针主要是通过析构函数来释放对象的。<code>shared_ptr</code>的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0,<code>shared_ptr</code>的析构函数就会销毁对象，并释放它占用的内存。</p>
<h4 id="make-shared函数"><a href="#make-shared函数" class="headerlink" title="make_shared函数"></a>make_shared函数</h4><p>最安全的分配和使用动态内存的方法是调用一个名为make_shared 的标准库函数。此函数在动态内存中分配-一个对象并初始化它，返回指向此对象的shared_ptr.与智能指针一样，make_shared也定义在头文件memory中。</p>
<p>当要用make_shared时,必须指定想要创建的对象的类型。定义方式与模板类相同，在函数名之后跟一个尖括号，在其中给出类型:</p>
<pre><code>//指向一个值为42的int的shared ptr
shared_ptr&lt;int&gt; p3 = make_shared&lt;int&gt; (42) ;
// p4指向- -个值为&quot;9999999999&quot;的string
shared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt; (10，&apos; 9&apos;) ;
// p5指向一个值初始化的(参见33.1节，第88页)int，即，值为0
shared_ptr&lt;int&gt; p5 = make_shared&lt;int&gt; () ;</code></pre><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>一一个unique_ptr“拥有”它所指向的对象。与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时,它所指向的对象也被销毁。</p>
<blockquote>
<p>感觉这个没什么特别的用途？不过和auto_ptr是一样的，但是现在应该用这个unique_ptr来编写程序。</p>
</blockquote>
<h2 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h2><p>C++语言定义了两个运算符来分配和释放动态内存。运算符new分配内存，delete释放new分配的内存。</p>
<p>相对于智能指针，使用这两个运算符管理内存非常容易出错,随着我们逐步详细介绍这两个运算符，这一点会更为清楚。而且，自己直接管理内存的类与使用智能指针的类不同，它们不能依赖类对象拷贝、赋值和销毁操作的任何默认定义。因此，使用智能指针的程序更容易编写和调试。</p>
<h3 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h3><p>就是new一个对象出来，然后用完了再delete，但是很多时候都会忘了delete，导致内存被用完出现错误。</p>
<h4 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h4><pre><code>int *pi = new int (1024) ;// pi指向的对象的值为1024 .
string *ps = new string(10， &apos;9&apos;) ;// *ps为&quot;9999999999&quot;
//vector有10个元素，值依次从0到9
vector&lt;int&gt; *pv = new vector&lt;int&gt;{0,1,2,3,4,5,6, 7,8,9};</code></pre><h4 id="指针值和delete"><a href="#指针值和delete" class="headerlink" title="指针值和delete"></a>指针值和delete</h4><p>我们传递给delete的指针必须指向动态分配的内存，或者是一个空指针。释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为是未定义的:</p>
<pre><code>int i, *pi1 = &amp;i，*pi2 = nullptr;
double *pd = new double(33) ，*pd2 = pd;
delete i; //错误: i不是一个指针
delete pil; // 未定义: pil 指向一个局部变量
delete pd;  //正确
delete pd2; // 未定义: pd2指向的内存已经被释放了
delete pi2; // 正确:释放一个空指针总是没有错误的</code></pre><h4 id="空悬指针"><a href="#空悬指针" class="headerlink" title="空悬指针"></a>空悬指针</h4><p>当我们delete一个指针后，指针值就变为无效了。虽然指针已经无效，但在很多机器上指针仍然保存着（已经释放了的）动态内存的地址。在delete之后，指针就变为了<strong>空悬指针</strong>，即指向一块曾经保存数据对象但现在已经无效的内存的指针。</p>
<p>动态内存的一个基本问题是可能有多个指针指向相同的内存。在delete内存之后重置指针的方法只对这个指针有效，对其他任何仍指向(已释放的)内存的指针是没有作用的。例如:</p>
<pre><code>int *p(new int(42)); // p指向动态内存
autoq=p;
// p和q指向相同的内存
delete p;
// p和q均变为无效
p = nullptr;
//指出p不再绑定到任何对象</code></pre><h3 id="智能指针陷阱"><a href="#智能指针陷阱" class="headerlink" title="智能指针陷阱"></a>智能指针陷阱</h3><p>智能指针可以提供对动态分配的内存安全而又方便的管理，但这建立在正确使用的前提下。为了正确使用智能指针，我们必须坚持一些基本规范:</p>
<ul>
<li>不使用相同的内置指针值初始化(或reset)多个智能指针。</li>
<li>不delete get()返回的指针。</li>
<li>不使用get()初始化或reset另一个智能指针。</li>
<li>如果你使用get()返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了。</li>
<li>如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/27/e5-85-b3-e8-81-94-e5-ae-b9-e5-99-a8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/27/e5-85-b3-e8-81-94-e5-ae-b9-e5-99-a8/" class="post-title-link" itemprop="url">关联容器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-27 08:22:04" itemprop="dateCreated datePublished" datetime="2019-01-27T08:22:04+08:00">2019-01-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><ul>
<li><p>关联容器</p>
<ul>
<li><p>定义</p>
</li>
<li><p>标准库容器</p>
<ul>
<li><p>按关键字有序保存元素</p>
</li>
<li><p>无序集合</p>
</li>
<li><p>使用map</p>
</li>
<li><p>使用set</p>
<ul>
<li>初始化</li>
</ul>
</li>
<li><p>pair对象</p>
</li>
<li><p>检测insert的返回值</p>
</li>
<li><p>在multimap或multiset中查找元素</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>关联容器和顺序容器有着根本的不同，关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。虽然关联容器的很多行为与顺序容器相同，但其不同之处反映了关键字的作用。</p>
<p>关联容器支持高校的关键字访问和查找。两个主要的关联容器是<strong>map</strong>和<strong>set</strong>，都是键值对，关键字起到索引的作用，值则表示与索引相关联的数据。</p>
<p>二者的区别就在于set是去重的，map是不去重的。</p>
<h2 id="标准库容器"><a href="#标准库容器" class="headerlink" title="标准库容器"></a>标准库容器</h2><p>标准库提供 <code>8</code>个关联容器，如下表:</p>
<h4 id="按关键字有序保存元素"><a href="#按关键字有序保存元素" class="headerlink" title="按关键字有序保存元素"></a>按关键字有序保存元素</h4><p>说明</p>
<p>说明</p>
<p>map</p>
<p>关联数组;保存关键字-值对</p>
<p>set</p>
<p>关键字即值，即只保存关键字的容器</p>
<p>multimap</p>
<p>关键字可重复出现的map</p>
<p>multiset</p>
<p>关键字可重复出现的set</p>
<h4 id="无序集合"><a href="#无序集合" class="headerlink" title="无序集合"></a>无序集合</h4><p>容器</p>
<p>说明</p>
<p>unordered_map</p>
<p>用哈希函数组织的map</p>
<p>unordered_set</p>
<p>用哈希函数组织的set</p>
<p>unordered_multimap</p>
<p>哈希组织的map;关键字可以重复出现</p>
<p>unordered_multiset</p>
<p>哈希组织的set;关键字可以重复出现</p>
<p><strong>这8个容器间的不同体现在三个维度上:每个容器</strong></p>
<ol>
<li>或者是一个set，或者是一个map;</li>
<li>或者要求不重复的关键字，或者允许重复关键字;</li>
<li>按顺序保存元素，或无序保存。允许重复关键字的容器的名字中都包含单词multi;不保持关键字按顺序存储的容器的名字都以单词unordered开头。</li>
</ol>
<h3 id="使用map"><a href="#使用map" class="headerlink" title="使用map"></a>使用map</h3><p>一个经典的使用关联数组的例子是单词计数程序:</p>
<pre><code>//统计每个单词在输入中出现的次数
map&lt;string, size_ t&gt; word_ count; // string 到size_ t的空map
string word;
while (cin &gt;&gt; word)
++word_count[word] ;
//提取word的计数器并将其加1
for(const auto &amp;w : word count) // 对map中的每个元素
//打印结果
cout &lt;&lt; w.first &lt;&lt;”occurs &quot; &lt;&lt; w.second
    &lt;&lt;((w.second&gt;1)?”times&quot;:”time&quot;)&lt;&lt;endl;</code></pre><p>此程序读取输入，报告每个单词出现多少次。</p>
<blockquote>
<p>注意这里的word_count[word]，这里不像vector，如果不存在就不允许直接引用。但是map可以直接用，如果不存在则创建，这里的string就是一个类似于下标一样的东西。</p>
</blockquote>
<p>当对word_count进行下标操作时，我们使用一个string作为下标，获得与此string相关联的size_t类型的计数器。</p>
<p>while循环每次从标准输入读取一个单词，它使用每个单词对word_count进行下标操作。如果word还未在map中，下标运算符会创建一个新元素，其关键字为word，值为0。不管元素是否是新创建的，我们将其值加1。</p>
<p>一旦读取完所有输入，范围for语句(参见3.2.3节，第81页)就会遍历map,打印每个单词和对应的计数器。当从map中提取一个元素时,会得到一个<strong>pai</strong>r类型的对象，我们将在11.2.3 节(第379页)介绍它。简单来说，pair是一个模板类型，保存两个名:为<code>first</code>和<code>second</code>的(公有)数据成员。map所使用的pair用first成员保存关键字，用second成员保存对应的值。因此，输出语句的效果是打印每个单词及其关联的计数器。</p>
<h3 id="使用set"><a href="#使用set" class="headerlink" title="使用set"></a>使用set</h3><p>这里的用法和map差不多，只要记住set有去重效果，而且map和set都有排序效果。但是要注意的是，定义map，必须指明关键字类型又需要指明值类型；而定义一个set时，只需要指明关键字类型，因为set中没有值。因为值是必须唯一的，所以没有必要再指定一个值形成值对pair。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>一般会用到用vector来初始化set，这个是比较有用的。只要传入vector的迭代器就能将vector转换为set。</p>
<pre><code>//类型要一致
set&lt;int&gt; iset(ivec.begin(), ivec.end()):</code></pre><h3 id="pair对象"><a href="#pair对象" class="headerlink" title="pair对象"></a>pair对象</h3><p>pair对象就是map里存储的，比如map&lt;int, string&gt;。里面存储的就是pair，在使用的时候用pair的成员函数，first和second就行了。这个可以可以作为参数来使用，比如作为函数的返回值：</p>
<pre><code>pair&lt;string, int&gt; process(vector&lt;string&gt; &amp;v)
{
    //处理v
    if( !v.empty())
        return {v.back(), v.back().size() }; //列表初始化
    else
        return pair&lt;string, int&gt;(); //隐式构造返回值</code></pre><p>若v不为空，我们返回一个由v中最后一个string及其大小组成的pair。否则，隐式构造一个空pair，并返回它。</p>
<h3 id="检测insert的返回值"><a href="#检测insert的返回值" class="headerlink" title="检测insert的返回值"></a>检测insert的返回值</h3><blockquote>
<p>在做题的时候有用到这个，感觉还蛮牛批的！</p>
</blockquote>
<p>insert (或emplace)返回的值依赖于容器类型和参数。对于不包含重复关键字的容器，添加单一元素的insert和emplace版本返回一个<code>pair</code>,告诉我们插入操作是否成功。pair的first成员是一个迭代器，指向具有给定关键字的元素;second成员是一个<code>bool</code>值，指出元素是插入成功还是已经存在于容器中。</p>
<pre><code>pair(it,bool);</code></pre><p>如果关键字已在容器中，则insert什么事情也不做，且返回值中的bool部分为<code>false</code>。如果关键字不存在，元素被插入容器中，且bool值为true。 作为一个例子，我们用insert重写单词计数程序：</p>
<pre><code>//统计每个单词在输入中出现次数的一种更烦琐的方法
map&lt;string, size_ t&gt; word_count; // 从string到size_ _t 的空map
string word;
while (cin &gt;&gt; word) {
    //插入一个元素，关键字等于word,值为1;
    //若word已在word count中，insert什么也不做
    auto ret = word_count.insert({word, 1}) ;
    if (!ret. second)
    // word已在word count中
        ++ret.first-&gt; second;
    . //递增计数器
}</code></pre><p>对于每个word,我们尝试将其插入到容器中，对应的值为1。若word已在map中，则什么都不做，特别是与word相关联的计数器的值不变。若word还未在map中，则此string对象被添加到map中，且其计数器的值被置为1。</p>
<blockquote>
<p>有人可能觉得，这个和find有啥区别？总的来说如果你想实现上述功能，没有则插入，有则不插入。可以直接判断insert的返回值，而不是先find再insert。</p>
</blockquote>
<h3 id="在multimap或multiset中查找元素"><a href="#在multimap或multiset中查找元素" class="headerlink" title="在multimap或multiset中查找元素"></a>在multimap或multiset中查找元素</h3><p>在一个不允许重复关键字的关联容器中查找一个元素是- -件很简单的事情一元素要么在容器中，要么不在。但对于允许重复关键字的容器来说，过程就更为复杂:在容器中可能有很多元素具有给定的关键字。如果一个multimap或multiset中有多个元素具有给定关键字，则这些元素在容器中会<code>相邻存储</code>。</p>
<p>例如，给定一个从作者到著作题目的映射,我们可能想打印一个特定作者的所有著作。可以用三种不同方法来解决这个问题。最直观的方法是使用find和count:</p>
<pre><code>string search_ item(&quot;Alain de Botton&quot;) ;
//要查找的作者
auto entries = authors.count (search_item) ;
//元素的数量
auto iter = authors.find(search_item) ;
//此作者的第一本书
//用一个循环查找此作者的所有著作
while (entries) {
    cout &lt;&lt; iter-&gt;second &lt;&lt; endl;
    //打印每个题目
    ++iter;
    //前进到下一本书
    --entries;
    //记录已经打印了多少本书
    }</code></pre><p>首先调用count确定此作者共有多少本著作，并调用find获得一个迭代器，指向第一个关键字为此作者的元素。for循环的迭代次数依赖于count的返回值。特别是，如果count返回0，则循环一次也不执行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/23/io-e5-ba-93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/23/io-e5-ba-93/" class="post-title-link" itemprop="url">IO库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-23 09:16:58" itemprop="dateCreated datePublished" datetime="2019-01-23T09:16:58+08:00">2019-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h1><ul>
<li><p>IO库</p>
</li>
<li><p>头文件</p>
</li>
<li><p>IO对象无赋值拷贝</p>
</li>
<li><p>管理输出缓冲</p>
<ul>
<li>缓冲刷新的原因</li>
<li>endl</li>
</ul>
</li>
<li><p>文件输入输出</p>
<ul>
<li>使用文件流对象</li>
</ul>
</li>
<li><p>string流</p>
<ul>
<li>istringstream</li>
<li>ostringstream</li>
</ul>
</li>
</ul>
<p>C++语言不直接处理输入输出，而是通过一族定义在标准库中的类型来处理IO。这些类型支持从设备读取数据、向设备写入数据的IO操作，设备可以是文件、控制台窗口等。还有一些类型允许内存IO,即从string读取数据，向string写入数据。</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>头文件</p>
<p>类型</p>
<p>iostream</p>
<p>读写流</p>
<p>fstream</p>
<p>读写文件</p>
<p>sstream</p>
<p>读写string</p>
<h2 id="IO对象无赋值拷贝"><a href="#IO对象无赋值拷贝" class="headerlink" title="IO对象无赋值拷贝"></a>IO对象无赋值拷贝</h2><p>不能拷贝或对IO对象赋值:</p>
<pre><code>ofstream out1，out2 ;
out1 = out2;
//错误:不能对流对象赋值
ofstream print (ofstream) ;
//错误:不能初始化ofstream参数
out2 = print (out2) ;
//错误:不能拷贝流对象</code></pre><p>由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以<strong>引用方式</strong>传递和返回流。读写一个I0对象会改变其状态，因此传递和返回的引用<strong>不能</strong>是const的。</p>
<h2 id="管理输出缓冲"><a href="#管理输出缓冲" class="headerlink" title="管理输出缓冲"></a>管理输出缓冲</h2><p>每个输出流都管理一个缓冲区，用来保存程序读写的数据。例如，如果执行下面的代码</p>
<pre><code>OS &lt;&lt; &quot;please enter a value: &quot;;</code></pre><p>文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。</p>
<h4 id="缓冲刷新的原因"><a href="#缓冲刷新的原因" class="headerlink" title="缓冲刷新的原因"></a>缓冲刷新的原因</h4><p>导致缓冲刷新的原因有很多：</p>
<ul>
<li>程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行；</li>
<li>缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。</li>
<li>我们可以使用操纵符如endl (参见1.2节，第6页)来显式刷新缓冲区。</li>
<li>在每个输出操作之后，我们可以用操纵符unitbuf设置流的内部状态，来清空冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的</li>
<li>一个输出流可能被关联到另-一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin和cerr都关联到cout。因此，读cin或写cerr都会导致cout的缓冲区被刷新。</li>
</ul>
<h4 id="endl"><a href="#endl" class="headerlink" title="endl"></a>endl</h4><p>我们已经使用过操纵符endl,它完成换行并刷新缓冲区的工作。I0库中还有两个类似的操纵符: flush和ends。flush刷新缓冲区，但不输出任何额外的字符: ends向缓冲区插入一个空字符，然后刷新缓冲区:</p>
<pre><code>cout &lt;&lt; &quot;hi!&quot; &lt;&lt; endl; //输出hi和一个换行，然后刷新缓冲区
cout &lt;&lt; &quot;hi!&quot; &lt;&lt; flush; // 输出hi,然后刷新缓冲区，不附加任何额外字符
cout &lt;&lt; &quot;hi!&quot; &lt;&lt; ends ;//输出hi和一个空字符，然后刷新缓冲区</code></pre><h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><blockquote>
<p>有时候写程序的时候总想要输入输出文件，但是总是不知道怎么弄这个格式。</p>
</blockquote>
<p>头文件fstream定义了三个类型来支持文件IO:ifstream从一.个给定文件读取数据，ofstream向一个给定文件写入数据，以及fstream可以读写给定文件。</p>
<h3 id="使用文件流对象"><a href="#使用文件流对象" class="headerlink" title="使用文件流对象"></a>使用文件流对象</h3><p>创建文件流对象时,我们可以提供文件名(可选的)。如果提供了一个文件名，则open会自动被调用:</p>
<pre><code>ifstream in(ifile) ;
//构造一个ifstream并打开给定文件
ofstream out;
//输出文件流未关联到任何文件</code></pre><p>这段代码定义了一个输入流in，它被初始化为从文件读取数据，文件名由string类型的参数ifile指定。第二条语句定义了一个输出流out，未与任何文件关联。在新C++ 11 标准中，文件名既可以是库类型string对象，也可以是C风格字符数组（“12321”类似这种）。旧版本的标准库只允许C风格字符数组。</p>
<h2 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h2><p>其实IO处理String应该较多，大多都是处理文本数据。这些文本数据都是string组成的。 考虑这样一个例子，假定有一个文件，列出了一些人和他们的电话号码。某些人只有一个号码，而另一些人则有多个一家庭电话、工作电话、移动电话等。我们的输入文件 看起来可能是这样的:</p>
<pre><code>morgan 2015552368 8625550123
drew 9735550130
lee 6095550132 2015550175 8005550000</code></pre><p>文件中每条记录都以一个人名开始，后面跟随- -个或多个电话号码。我们首先定义一个简单的类来描述输入数据:</p>
<pre><code>//成员默认为公有;参见7.2节(第240页)
struct PersonInfo {
    string name ; 
    vector&lt;string&gt; phones;
};</code></pre><h3 id="istringstream"><a href="#istringstream" class="headerlink" title="istringstream"></a>istringstream</h3><p>我们的程序会读取数据文件，并创建-一个PersonInfo的vector. vector中每个元素对应文件中的一条记录。我们在一个循环中处理输入数据，每个循环步读取一条记录，提取出一个人名和若干电话号码:</p>
<pre><code>string line, word;
//分别保存来自输入的一行和单词
vector&lt;PersonInfo&gt; people;
//保存来自输入的所有记录
//逐行从输入读取数据，直至cin遇到文件尾(或其他错误)
while (getline(cin, line) ) {
    PersonInfo info;
    //创建一个保存此记录数据的对象
    istringstream record(line); // 将记录绑定到刚读入的行
    record &gt;&gt; info.name;
    //读取名字
    while (record &gt;&gt; word)
    //读取电话号码
     info.phones.push_back(word) ; //保持它们
    people.push_back(info) ;
//将此记录追加到people末尾
}</code></pre><p>这里我们用getline从标准输入读取整条记录。如果getline调用成功，那么line中将保存着从输入文件而来的一条记录。在while中,我们定义了一个局部PersonInfo对象，来保存当前记录中的数据。 接下来我们将一根istringstream与刚刚读取的文本行进行绑定，这样就可以在此istringstream上使用输入运算符来读取当前记录中的每个元素。</p>
<h3 id="ostringstream"><a href="#ostringstream" class="headerlink" title="ostringstream"></a>ostringstream</h3><p>当我们逐步构造输出，希望最后一起打印时，ostringstream 是很有用的。例如，对上一节的例子,我们可能想逐个验证电话号码并改变其格式。如果所有号码都是有效的,我们希望输出一个新的文件，包含改变格式后的号码。对于那些无效的号码，我们不会将它们输出到新文件中，而是打印一条包含人名和无效号码的错误信息。 由于我们不希望输出有无效电话号码的人，因此对每个人，直到验证完所有电话号码后才可以进行输出操作。但是，我们可以先将输出内容“写入”到一个内存ostringstream中:</p>
<pre><code>for(const auto &amp;entry : people) { //对people中每一项
    ostringstream formatted, badNums; // 每个循环步创建的对象
    for(const auto &amp;nums : entry.phones) { // 对每个数
    if(!valid (nums)) {
    badNums &lt;&lt; &quot; &quot; &lt;&lt; nums; //将数的字符串形式存入badNums i
    }
    else
    {
        //将格式化的字符串“写入”formatted
        formatted &lt;&lt;” ”&lt;&lt; format (nums);
    }
    //打印名字
    if (badNums.str().empty())//没有错误的数
        os &lt;&lt; entry.name &lt;&lt;” ”&lt;&lt; formatted.str() &lt;&lt; endl;
    //和格式化的数
    //否则，打印名字和错误的数
    else
    cerr &lt;&lt; &quot;input error:&quot;&lt;&lt; entry.name &lt;&lt; &quot;invalid number (s) &quot;&lt;&lt; badNums.str() &lt;&lt; endl;
}</code></pre><p>在此程序中，我们假定已有两个函数，valid和format,分别完成电话号码验证和改变格式的功能。程序最有趣的部分是对字符串流formatted和badNums的使用。我们使用标准的输出运算符(&lt;&lt;)向这些对象写入数据,但这些“写入”操作实际上转换为string操作，分别向formatted和badNums中的string对象添加字符。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/21/e5-a7-94-e6-89-98-e6-9e-84-e9-80-a0-e5-87-bd-e6-95-b0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/21/e5-a7-94-e6-89-98-e6-9e-84-e9-80-a0-e5-87-bd-e6-95-b0/" class="post-title-link" itemprop="url">委托构造函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-21 08:02:56" itemprop="dateCreated datePublished" datetime="2019-01-21T08:02:56+08:00">2019-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h1><blockquote>
<p>C++11的新标准，有点牛批的感觉啊</p>
</blockquote>
<ul>
<li>委托构造函数<ul>
<li>定义</li>
</ul>
</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>C++11新标准扩展了构造函数初始值的功能,使得我们可以定义所谓的委托构造函数(delegating constructor)。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些(或者全部)职责委托给了其他构造函数。</p>
<blockquote>
<p>就是让别的构造函数来构造自己。</p>
</blockquote>
<p>和其他构造函数一样，一个委托构造函数也有一个成员初始值的列表和一个函数体。在委托构造函数内，成员初始值列表只有一个唯一的入口，就是类名本身。和其他成员初始值一样，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另外一个构造函数匹配。 举个例子，我们使用委托构造函数重写Sales_data类，重写后的形式如下所示:</p>
<pre><code>class Sales_data {
public:
    //非委托构造函数使用对应的实参初始化成员
    Sales_data(std::string s, unsigned cnt，double price) :bookNo(s)，units_sold(cnt), revenue (cnt*price) {}
    .//其余构造函数全都委托给另一.个构造函数
    Sales_data() : Sales_ data(&quot;&quot;, 0，0) { }
    Sales_data(std::string s) : Sales_data(s, 0,0) { }
    Sales_data(std::istream &amp;is) : Sales_data ()
    { read(is, *this) ; }
    //其他成员与之前的版本一致
};</code></pre><p>在这个Sales_data类中，除了一个构造函数外其他的都委托了它们的工作。第一个构造函数接受三个实参，使用这些实参初始化数据成员，然后结束工作。我们定义默认构造函数令其使用三参数的构造函数完成初始化过程，它也无须执行其他任务，这一点从空的构造函数体能看得出来。接受一个string的构造函数同样委托给了三参数的版本。</p>
<blockquote>
<p>有点像是这个类的继承</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/18/e5-90-ab-e6-9c-89-e5-8f-af-e5-8f-98-e5-bd-a2-e5-8f-82-e7-9a-84-e5-87-bd-e6-95-b0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/18/e5-90-ab-e6-9c-89-e5-8f-af-e5-8f-98-e5-bd-a2-e5-8f-82-e7-9a-84-e5-87-bd-e6-95-b0/" class="post-title-link" itemprop="url">含有可变形参的函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-18 09:21:15" itemprop="dateCreated datePublished" datetime="2019-01-18T09:21:15+08:00">2019-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="含有可变形参的参数"><a href="#含有可变形参的参数" class="headerlink" title="含有可变形参的参数"></a>含有可变形参的参数</h1><p>有时候我们无法提前预知应该向参数传递几个实参，为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法:如果所有的实参类型相同，可以传递一个名为<strong>initializer_list</strong>的标准库类型;如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板，关于它的细节将在16.4节(第618页)介绍。</p>
<blockquote>
<p>就是类似vector，你不知道数组的长度就使用vector。</p>
</blockquote>
<pre><code>void error_msg (initializer_list&lt;string&gt; il)
{
    for (auto beg = il.begin() ; beg != il.end() ; + +beg)
    cout &lt;&lt; *beg&lt;&lt;” ”;
    cout &lt;&lt; endl ;
}</code></pre><blockquote>
<p>这个好像和什么vector没啥区别啊，但是为什么要特别用到呢？</p>
</blockquote>
<p>和vector不一样的是，initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/18/e5-bc-95-e7-94-a8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/18/e5-bc-95-e7-94-a8/" class="post-title-link" itemprop="url">引用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-18 07:46:07" itemprop="dateCreated datePublished" datetime="2019-01-18T07:46:07+08:00">2019-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote>
<p>这个东西用不好就是坑，用好了还是很强的。</p>
</blockquote>
<h2 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h2><p>传参就不说了，主要是避免一个问题——避免拷贝。有些数据较大的对象或者容器，如果传参的时候不用引用的话需要对其进行拷贝，这样的开销较大。应该使用引用值，直接对原数组进行操作，这样避免额外的开销，效率也会更快。</p>
<pre><code>//比如对这个vector容器进行操作的时候，一般都是使用引用值。
vector&lt;int&gt; test(vector&lt;int&gt; &amp; nums)
{
...
}</code></pre><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>有时候并不改变传入的参数的值，那么建议使用<strong>对常量的引用</strong></p>
<pre><code>// 比较两个string的大小
bool isShorter (const string &amp;s1, const string &amp;s2)
[
return s1.size() &lt; s2.size() ;
]</code></pre><blockquote>
<p>如果函数无须改变引用形参的值，最好将其声明为常量引用。</p>
</blockquote>
<h2 id="引用形参返回额外信息"><a href="#引用形参返回额外信息" class="headerlink" title="引用形参返回额外信息"></a>引用形参返回额外信息</h2><p>一个函数只能返回一个值，然而有时候函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效途径。</p>
<p>简单来说就是在传参的时候使用引用值，然后在函数体内改变这个引用的值，也就达到了一次返回多个值。</p>
<pre><code>//返回s中c第一次出现的位置索引
//引用形参occurs负责统计c出现的总次数
string: :size_ type find_ char (const string &amp;S，char C,
string: :size_ type &amp;occurs )
{
auto ret = s.size() ;
//第一次出现的位置(如果有的话)
occurs 
= 0;
//设置表示出现次数的形参的值
for (decltype(ret) i = 0; i != s.size() ; ++i) {
    if (s[i] == c) {
      if (ret == s.size() )
        ret = i;
        . //记录c第一次出现的位置
        ++occurs ;
        . //将出现的次数加1
        }
    }
return ret ;
//出现次数通过occurs隐式地返回
}</code></pre><p>当我们调用find_char函数时，必须传入三个实参:作为查找范围的一个string对象、要找的字符以及一个用于保存字符出现次数的size_ type (参见3.2.2节，第79页)对象。假设s是一个string对象，ctr是一个size_ type对象，则我们通过如下形式调用find char函数:</p>
<pre><code>auto index = find char(s, &apos;o&apos;，ctr) ;</code></pre><p>调用完成后，如果string对象中确实存在o,那么ctr的值就是。出现的次数，index指向。第一次出现的位置;否则如果string对象中没有o，index等于s.size()而ctr等于0。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/18/e5-b1-80-e9-83-a8-e9-9d-99-e6-80-81-e5-af-b9-e8-b1-a1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/18/e5-b1-80-e9-83-a8-e9-9d-99-e6-80-81-e5-af-b9-e8-b1-a1/" class="post-title-link" itemprop="url">局部静态对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-18 07:16:13" itemprop="dateCreated datePublished" datetime="2019-01-18T07:16:13+08:00">2019-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="局部静态对象"><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h1><p>在程序的执行路径第一次经过对象定义局域时初始化，知道程序终止时才被销毁，在此期间即使对象所在的函数结束也不会对它有影响。</p>
<pre><code>size_t count_calls ()
f
static size_t ctr = O; //调用结束后，这个值仍然有效
return ++ctr;
)
int main()
[
for(sizeti=O;i!=10;++i)
cout &lt;&lt; count calls () &lt;&lt; endl ;
return O;
)</code></pre><p>在控制流第一次经过ctr的定义之前，ctr被创建并初始化为0。每次调用将ctr加1并返回新值。每次执行count_calls函数时，变量ctr的值都已经存在并且等于函数上一次退出时ctr的值。因此，第二次调用时ctr的值是1，第三次调用时ctr的值是2，以此类推。</p>
<blockquote>
<p>反正就是静态局部变量初始化后再次调用该函数，crr不会重新初始化，而是继续用上次的值。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/17/try-e8-af-ad-e5-8f-a5-e5-9d-97-e5-92-8c-e5-bc-82-e5-b8-b8-e5-a4-84-e7-90-86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/17/try-e8-af-ad-e5-8f-a5-e5-9d-97-e5-92-8c-e5-bc-82-e5-b8-b8-e5-a4-84-e7-90-86/" class="post-title-link" itemprop="url">try语句块和异常处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-17 08:44:02" itemprop="dateCreated datePublished" datetime="2019-01-17T08:44:02+08:00">2019-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h1><ul>
<li>try语句块和异常处理<ul>
<li>定义<ul>
<li>异常处理方式</li>
</ul>
</li>
<li>throw表达式<ul>
<li>cerr解释</li>
</ul>
</li>
<li>try-catch</li>
<li>标准异常<ul>
<li>定义的异常类</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这个东西一般比较少用到，好像以前在Java里经常用。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。典型的异常包括失去数据库连接以及遇到意外输入等。处理反常行为可能是设计所有系统最难的一部分。</p>
<h3 id="异常处理方式"><a href="#异常处理方式" class="headerlink" title="异常处理方式"></a>异常处理方式</h3><ul>
<li>throw表达式；</li>
<li>try语句块，也就是try-catch。try语句块中代码抛出的异常通常会被磨具个catch子句处理。因为catch子句“处理”异常，所以它们也被称作异常处理代码；</li>
<li>一套异常类。</li>
</ul>
<p>下面详细介绍一下这几种方式。</p>
<h2 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h2><p>一般业务代码中都要处理错误，输出一些信息，这样才能快速定位哪里出错了。比如下面这个代码检查它读入的记录是否是关于同一种书籍，如果不是，输出一条信息然后退出。</p>
<pre><code>Sales_ item item1, item2;
cin &gt;&gt; item1 &gt;&gt; item2;
// 检查 item1 和 item2 是否表示同一种书籍
if(item1.isbn() == item2. isbn()) {
cout &lt;&lt; item1 + item2 &lt;&lt; endl ;
return O; // success
} else {
cerr &lt;&lt; &quot;Data must refer to same ISBN&quot; &lt;&lt; endl ;
//cerr 是一个ostream对象，关联到标准错误，通常写入到与标准输出相同的设备。
return -1; // failed
}</code></pre><h4 id="cerr解释"><a href="#cerr解释" class="headerlink" title="cerr解释"></a>cerr解释</h4><p>cerr不经过缓冲而直接输出，一般用于迅速输出出错信息，是标准错误，默认情况下被关联到标准输出流，但它不被缓冲，也就说错误消息可以直接发送到显示器，而无需等到缓冲区或者新的换行符时，才被显示。一般情况下不被重定向。</p>
<blockquote>
<p>这个东西很少见啊，又学习到了新的知识了。</p>
</blockquote>
<p>接上述代码，在真实的程序中，应该把对象相加的代码和用户交互的代码分离开来。此例中，我们改写程序似的检查完成和惠普不再直接输出一条信息，而是<strong>抛出一个异常</strong>：</p>
<pre><code>//首先检查两条数据是否是关于同一种书籍的
if (iteml. isbn() != item2 . isbn() )
throw runtime_error (&quot;Data must refer to same ISBN&quot;) ;
//如果程序执行到了这里，表示两个ISBN是相同的
cout &lt;&lt; item1 + item2 &lt;&lt; endl ;</code></pre><blockquote>
<p>但是这样做有什么用呢？是给后面的try-catch使用的？</p>
</blockquote>
<h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h2><p>try语句块的一开始是关键字try，随后紧跟着一个块。</p>
<p>在之前的例子里，我们使用了一个throw表达式以避免把两个代表不同书籍的 Sales_item相加。我们假设执行Sales_item 对象加法的代码是与用户交互的代码分离开来的。其中与用户交互的代码负责处理发生的异常，它的形式可能如下所示:</p>
<pre><code>while (cin &gt;&gt; item1 &gt;&gt; item2) {
try {
//执行添加两个Sales_ item对象的代码
//如果添加失败，代码抛出一个runtime_ error异常
    if (iteml. isbn() != item2 . isbn() )
    throw runtime_error (&quot;Data must refer to same ISBN&quot;) ;
    //如果程序执行到了这里，表示两个ISBN是相同的
    cout &lt;&lt; item1 + item2 &lt;&lt; endl ;

} catch (runtime_error err) {
//提醒用户两个ISBN必须一致，询问是否重新输入
    cout &lt;&lt; err.what ()&lt;&lt; &quot;\nTry Again? Enter y or n&quot; &lt;&lt; endl ;
    char C;
    cin &gt;&gt; C;
    if(!cin || c ==&apos;n&apos; )
        break; // 跳出while循环
      }
 }</code></pre><p>上面的<code>err.what()</code>就是这个runtime_error后面的字符串。</p>
<p>给用户的提示信息中输出了err.what() 的返回值。我们知道err的类型是 runtime error, 因此能推断what是runtime error 类的一一个成员函数(参见1.5.2节，第20页)。每个标准库异常类都定义了名为what的成员函数，这些函数没有参数，返回值是C风格字符串(即const char*)。 其中， runtime error的what成员返回的是初始化–个具体对象时所用的string对象的副本。如果上一-节编写的代码抛出异常，则本节的catch子句输出：</p>
<pre><code>Data must refer to same ISBN
Try Again? Enter y or n</code></pre><h2 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h2><p>C++标准库定义了一-组类，用于报告标准库函数遇到的问题。这些异常类也可以在用户编写的程序中使用，它们分别定义在4个头文件中:</p>
<ul>
<li>exception头文件定义了最通用的异常类exception。它只报告异常的发生，不提供任何额外信息。</li>
<li>stdexcept头文件定义了几种常用的异常类，详细信息在表5.1中列出。</li>
<li>new头文件定义了bad_alloc异常类型，这种类型将在12.1.2节(第407页)详细介绍。</li>
<li>type_info头文件定义了bad_cast异常类型，这种类型将在19.2节(第731页)详细介绍。</li>
</ul>
<h4 id="定义的异常类"><a href="#定义的异常类" class="headerlink" title="定义的异常类"></a><stdexcept>定义的异常类</h4><p>类</p>
<p>解释</p>
<p>exception</p>
<p>最常见的问题</p>
<p>runtime_error</p>
<p>只有在运行时才能检测出的问题</p>
<p>range_error</p>
<p>运行时错误:生成的结果超出了有意义的值域范围</p>
<p>overflow error</p>
<p>运行时错误:计算上溢</p>
<p>underflow_error</p>
<p>运行时错误:计算下溢</p>
<p>logic_error</p>
<p>程序逻辑错误</p>
<p>domain_error</p>
<p>逻辑错误:参数对应的结果值不存在</p>
<p>invalid_argument</p>
<p>逻辑错误:无效参数</p>
<p>length_error</p>
<p>逻辑错误:试图创建一个超出该类型最大长度的对象</p>
<p>out_of_range</p>
<p>逻辑错误:使用一个超出有效范围的值</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tanwenbo</p>
  <div class="site-description" itemprop="description">enjoy share</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">113</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">71</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tanwenbo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
