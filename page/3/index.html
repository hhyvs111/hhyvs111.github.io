<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="enjoy share">
<meta property="og:type" content="website">
<meta property="og:title" content="hhyvs111">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="hhyvs111">
<meta property="og:description" content="enjoy share">
<meta property="article:author" content="tanwenbo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>hhyvs111</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hhyvs111</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Be a great man</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/30/e5-8a-a8-e6-80-81-e5-86-85-e5-ad-98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/30/e5-8a-a8-e6-80-81-e5-86-85-e5-ad-98/" class="post-title-link" itemprop="url">动态内存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-01-30 04:08:44" itemprop="dateCreated datePublished" datetime="2019-01-30T04:08:44+08:00">2019-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><ul>
<li>动态内存<ul>
<li>智能指针<ul>
<li>shared_ptr<ul>
<li>引用计数</li>
<li>析构函数</li>
<li>make_shared函数</li>
</ul>
</li>
<li>unique_ptr</li>
</ul>
</li>
<li>直接管理内存<ul>
<li>new和delete<ul>
<li>列表初始化</li>
<li>指针值和delete</li>
<li>空悬指针</li>
</ul>
</li>
<li>智能指针陷阱</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这一章感觉还挺重要，主要是这个智能指针和动态内存。</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>标准库定义了两个智能指针类型来管理动态分配的对象，当一个对象应该被释放时，指向它的智能指针可以确保自动地释放它。</p>
<p><code>shared_ptr</code>允许多个指针指向同一个对象; <code>unique_ptr</code>则“独占”所指向的对象。标准库还定义了一个名为<code>weak_ptr</code>的伴随类，它是一种弱引用，指向<code>shared_ptr</code>所管理的对象。这三种类型都定义在memory头文件中。</p>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>类似vector，智能指针也是模板，因此当我们创建一个智能指针时，必须提供额外的信息——指针可以指向的类型。与vector一样，我们在尖括号内给出类型，之后是所定义的这种智能指针的名字:</p>
<pre><code>shared_ptr&lt;string&gt; p1; // shared ptr，可以指向string
shared_ptr&lt;list&lt;int&gt;&gt; p2; // shared ptr，可以指向int的list</code></pre><p>默认初始化的智能指针中保存着一个空指针。</p>
<p>它的操作和一般指针一样，都有解引用等操作。将p作为一个条件判断，若p指向一个对象，则为true。</p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>当进行拷贝或赋值操作时，每个<code>shared_ptr</code>都会记录有多少个其他<code>shared_ptr</code> 指向相同的对象:</p>
<pre><code>auto p = make shared&lt;int&gt;(42); // p指向的对象只有p一个引用者
auto q(p); // p和q指向相同对象，此对象有两个引用者</code></pre><p>我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数( reference count)。无论何时我们拷贝一个<code>shared_ptr</code>，计数器都会递增。例如，当用一个<code>shared_ptr</code>初始化另一个<code>shared_ptr</code>， 或将它作为参数传递给一个函数以及作为函数的返回值时，它所关联的计数器就会递增。当我们给shared_ptr赋予一个新值或是shared_ptr被销毁(例如一个局部的shared_ptr离开其作用域)时，计数器就会递减。</p>
<p><strong>一旦一个shared ptr的计数器变为0，它就会自动释放自已所管理的对象:</strong></p>
<pre><code>auto r = make shared&lt;int&gt;(42); // r指向的int只有一个引用者
r=q;//给r赋值，令它指向另一个地址
//递增q指向的对象的引用计数
//递减r原来指向的对象的引用计数
// r原来指向的对象已没有引用者，会自动释放</code></pre><p>此例中我们分配了一个int,将其指针保存在r中。接下来，我们将一个新值赋予r。在此情况下，r是唯一指向此int的shared_ptr, 在把q赋给r的过程中，此int被自动释放。</p>
<blockquote>
<p>有点像是Linux的内核引用计数，父子进程、socket等使用。</p>
</blockquote>
<p>当创建一个对象的实例并在堆上申请内存时，对象的引用计数就为1，在其他对象中需要持有这个对象时，就需要把该对象的引用计数加1，需要释放一个对象时，就将该对象的引用计数减1，直至对象的引用计数为0，对象的内存会被立刻释放。</p>
<h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p>智能指针主要是通过析构函数来释放对象的。<code>shared_ptr</code>的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0,<code>shared_ptr</code>的析构函数就会销毁对象，并释放它占用的内存。</p>
<h4 id="make-shared函数"><a href="#make-shared函数" class="headerlink" title="make_shared函数"></a>make_shared函数</h4><p>最安全的分配和使用动态内存的方法是调用一个名为make_shared 的标准库函数。此函数在动态内存中分配-一个对象并初始化它，返回指向此对象的shared_ptr.与智能指针一样，make_shared也定义在头文件memory中。</p>
<p>当要用make_shared时,必须指定想要创建的对象的类型。定义方式与模板类相同，在函数名之后跟一个尖括号，在其中给出类型:</p>
<pre><code>//指向一个值为42的int的shared ptr
shared_ptr&lt;int&gt; p3 = make_shared&lt;int&gt; (42) ;
// p4指向- -个值为&quot;9999999999&quot;的string
shared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt; (10，&apos; 9&apos;) ;
// p5指向一个值初始化的(参见33.1节，第88页)int，即，值为0
shared_ptr&lt;int&gt; p5 = make_shared&lt;int&gt; () ;</code></pre><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>一一个unique_ptr“拥有”它所指向的对象。与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时,它所指向的对象也被销毁。</p>
<blockquote>
<p>感觉这个没什么特别的用途？不过和auto_ptr是一样的，但是现在应该用这个unique_ptr来编写程序。</p>
</blockquote>
<h2 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h2><p>C++语言定义了两个运算符来分配和释放动态内存。运算符new分配内存，delete释放new分配的内存。</p>
<p>相对于智能指针，使用这两个运算符管理内存非常容易出错,随着我们逐步详细介绍这两个运算符，这一点会更为清楚。而且，自己直接管理内存的类与使用智能指针的类不同，它们不能依赖类对象拷贝、赋值和销毁操作的任何默认定义。因此，使用智能指针的程序更容易编写和调试。</p>
<h3 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h3><p>就是new一个对象出来，然后用完了再delete，但是很多时候都会忘了delete，导致内存被用完出现错误。</p>
<h4 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h4><pre><code>int *pi = new int (1024) ;// pi指向的对象的值为1024 .
string *ps = new string(10， &apos;9&apos;) ;// *ps为&quot;9999999999&quot;
//vector有10个元素，值依次从0到9
vector&lt;int&gt; *pv = new vector&lt;int&gt;{0,1,2,3,4,5,6, 7,8,9};</code></pre><h4 id="指针值和delete"><a href="#指针值和delete" class="headerlink" title="指针值和delete"></a>指针值和delete</h4><p>我们传递给delete的指针必须指向动态分配的内存，或者是一个空指针。释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为是未定义的:</p>
<pre><code>int i, *pi1 = &amp;i，*pi2 = nullptr;
double *pd = new double(33) ，*pd2 = pd;
delete i; //错误: i不是一个指针
delete pil; // 未定义: pil 指向一个局部变量
delete pd;  //正确
delete pd2; // 未定义: pd2指向的内存已经被释放了
delete pi2; // 正确:释放一个空指针总是没有错误的</code></pre><h4 id="空悬指针"><a href="#空悬指针" class="headerlink" title="空悬指针"></a>空悬指针</h4><p>当我们delete一个指针后，指针值就变为无效了。虽然指针已经无效，但在很多机器上指针仍然保存着（已经释放了的）动态内存的地址。在delete之后，指针就变为了<strong>空悬指针</strong>，即指向一块曾经保存数据对象但现在已经无效的内存的指针。</p>
<p>动态内存的一个基本问题是可能有多个指针指向相同的内存。在delete内存之后重置指针的方法只对这个指针有效，对其他任何仍指向(已释放的)内存的指针是没有作用的。例如:</p>
<pre><code>int *p(new int(42)); // p指向动态内存
autoq=p;
// p和q指向相同的内存
delete p;
// p和q均变为无效
p = nullptr;
//指出p不再绑定到任何对象</code></pre><h3 id="智能指针陷阱"><a href="#智能指针陷阱" class="headerlink" title="智能指针陷阱"></a>智能指针陷阱</h3><p>智能指针可以提供对动态分配的内存安全而又方便的管理，但这建立在正确使用的前提下。为了正确使用智能指针，我们必须坚持一些基本规范:</p>
<ul>
<li>不使用相同的内置指针值初始化(或reset)多个智能指针。</li>
<li>不delete get()返回的指针。</li>
<li>不使用get()初始化或reset另一个智能指针。</li>
<li>如果你使用get()返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了。</li>
<li>如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/27/e5-85-b3-e8-81-94-e5-ae-b9-e5-99-a8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/27/e5-85-b3-e8-81-94-e5-ae-b9-e5-99-a8/" class="post-title-link" itemprop="url">关联容器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-01-27 08:22:04" itemprop="dateCreated datePublished" datetime="2019-01-27T08:22:04+08:00">2019-01-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><ul>
<li><p>关联容器</p>
<ul>
<li><p>定义</p>
</li>
<li><p>标准库容器</p>
<ul>
<li><p>按关键字有序保存元素</p>
</li>
<li><p>无序集合</p>
</li>
<li><p>使用map</p>
</li>
<li><p>使用set</p>
<ul>
<li>初始化</li>
</ul>
</li>
<li><p>pair对象</p>
</li>
<li><p>检测insert的返回值</p>
</li>
<li><p>在multimap或multiset中查找元素</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>关联容器和顺序容器有着根本的不同，关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。虽然关联容器的很多行为与顺序容器相同，但其不同之处反映了关键字的作用。</p>
<p>关联容器支持高校的关键字访问和查找。两个主要的关联容器是<strong>map</strong>和<strong>set</strong>，都是键值对，关键字起到索引的作用，值则表示与索引相关联的数据。</p>
<p>二者的区别就在于set是去重的，map是不去重的。</p>
<h2 id="标准库容器"><a href="#标准库容器" class="headerlink" title="标准库容器"></a>标准库容器</h2><p>标准库提供 <code>8</code>个关联容器，如下表:</p>
<h4 id="按关键字有序保存元素"><a href="#按关键字有序保存元素" class="headerlink" title="按关键字有序保存元素"></a>按关键字有序保存元素</h4><p>说明</p>
<p>说明</p>
<p>map</p>
<p>关联数组;保存关键字-值对</p>
<p>set</p>
<p>关键字即值，即只保存关键字的容器</p>
<p>multimap</p>
<p>关键字可重复出现的map</p>
<p>multiset</p>
<p>关键字可重复出现的set</p>
<h4 id="无序集合"><a href="#无序集合" class="headerlink" title="无序集合"></a>无序集合</h4><p>容器</p>
<p>说明</p>
<p>unordered_map</p>
<p>用哈希函数组织的map</p>
<p>unordered_set</p>
<p>用哈希函数组织的set</p>
<p>unordered_multimap</p>
<p>哈希组织的map;关键字可以重复出现</p>
<p>unordered_multiset</p>
<p>哈希组织的set;关键字可以重复出现</p>
<p><strong>这8个容器间的不同体现在三个维度上:每个容器</strong></p>
<ol>
<li>或者是一个set，或者是一个map;</li>
<li>或者要求不重复的关键字，或者允许重复关键字;</li>
<li>按顺序保存元素，或无序保存。允许重复关键字的容器的名字中都包含单词multi;不保持关键字按顺序存储的容器的名字都以单词unordered开头。</li>
</ol>
<h3 id="使用map"><a href="#使用map" class="headerlink" title="使用map"></a>使用map</h3><p>一个经典的使用关联数组的例子是单词计数程序:</p>
<pre><code>//统计每个单词在输入中出现的次数
map&lt;string, size_ t&gt; word_ count; // string 到size_ t的空map
string word;
while (cin &gt;&gt; word)
++word_count[word] ;
//提取word的计数器并将其加1
for(const auto &amp;w : word count) // 对map中的每个元素
//打印结果
cout &lt;&lt; w.first &lt;&lt;”occurs &quot; &lt;&lt; w.second
    &lt;&lt;((w.second&gt;1)?”times&quot;:”time&quot;)&lt;&lt;endl;</code></pre><p>此程序读取输入，报告每个单词出现多少次。</p>
<blockquote>
<p>注意这里的word_count[word]，这里不像vector，如果不存在就不允许直接引用。但是map可以直接用，如果不存在则创建，这里的string就是一个类似于下标一样的东西。</p>
</blockquote>
<p>当对word_count进行下标操作时，我们使用一个string作为下标，获得与此string相关联的size_t类型的计数器。</p>
<p>while循环每次从标准输入读取一个单词，它使用每个单词对word_count进行下标操作。如果word还未在map中，下标运算符会创建一个新元素，其关键字为word，值为0。不管元素是否是新创建的，我们将其值加1。</p>
<p>一旦读取完所有输入，范围for语句(参见3.2.3节，第81页)就会遍历map,打印每个单词和对应的计数器。当从map中提取一个元素时,会得到一个<strong>pai</strong>r类型的对象，我们将在11.2.3 节(第379页)介绍它。简单来说，pair是一个模板类型，保存两个名:为<code>first</code>和<code>second</code>的(公有)数据成员。map所使用的pair用first成员保存关键字，用second成员保存对应的值。因此，输出语句的效果是打印每个单词及其关联的计数器。</p>
<h3 id="使用set"><a href="#使用set" class="headerlink" title="使用set"></a>使用set</h3><p>这里的用法和map差不多，只要记住set有去重效果，而且map和set都有排序效果。但是要注意的是，定义map，必须指明关键字类型又需要指明值类型；而定义一个set时，只需要指明关键字类型，因为set中没有值。因为值是必须唯一的，所以没有必要再指定一个值形成值对pair。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>一般会用到用vector来初始化set，这个是比较有用的。只要传入vector的迭代器就能将vector转换为set。</p>
<pre><code>//类型要一致
set&lt;int&gt; iset(ivec.begin(), ivec.end()):</code></pre><h3 id="pair对象"><a href="#pair对象" class="headerlink" title="pair对象"></a>pair对象</h3><p>pair对象就是map里存储的，比如map&lt;int, string&gt;。里面存储的就是pair，在使用的时候用pair的成员函数，first和second就行了。这个可以可以作为参数来使用，比如作为函数的返回值：</p>
<pre><code>pair&lt;string, int&gt; process(vector&lt;string&gt; &amp;v)
{
    //处理v
    if( !v.empty())
        return {v.back(), v.back().size() }; //列表初始化
    else
        return pair&lt;string, int&gt;(); //隐式构造返回值</code></pre><p>若v不为空，我们返回一个由v中最后一个string及其大小组成的pair。否则，隐式构造一个空pair，并返回它。</p>
<h3 id="检测insert的返回值"><a href="#检测insert的返回值" class="headerlink" title="检测insert的返回值"></a>检测insert的返回值</h3><blockquote>
<p>在做题的时候有用到这个，感觉还蛮牛批的！</p>
</blockquote>
<p>insert (或emplace)返回的值依赖于容器类型和参数。对于不包含重复关键字的容器，添加单一元素的insert和emplace版本返回一个<code>pair</code>,告诉我们插入操作是否成功。pair的first成员是一个迭代器，指向具有给定关键字的元素;second成员是一个<code>bool</code>值，指出元素是插入成功还是已经存在于容器中。</p>
<pre><code>pair(it,bool);</code></pre><p>如果关键字已在容器中，则insert什么事情也不做，且返回值中的bool部分为<code>false</code>。如果关键字不存在，元素被插入容器中，且bool值为true。 作为一个例子，我们用insert重写单词计数程序：</p>
<pre><code>//统计每个单词在输入中出现次数的一种更烦琐的方法
map&lt;string, size_ t&gt; word_count; // 从string到size_ _t 的空map
string word;
while (cin &gt;&gt; word) {
    //插入一个元素，关键字等于word,值为1;
    //若word已在word count中，insert什么也不做
    auto ret = word_count.insert({word, 1}) ;
    if (!ret. second)
    // word已在word count中
        ++ret.first-&gt; second;
    . //递增计数器
}</code></pre><p>对于每个word,我们尝试将其插入到容器中，对应的值为1。若word已在map中，则什么都不做，特别是与word相关联的计数器的值不变。若word还未在map中，则此string对象被添加到map中，且其计数器的值被置为1。</p>
<blockquote>
<p>有人可能觉得，这个和find有啥区别？总的来说如果你想实现上述功能，没有则插入，有则不插入。可以直接判断insert的返回值，而不是先find再insert。</p>
</blockquote>
<h3 id="在multimap或multiset中查找元素"><a href="#在multimap或multiset中查找元素" class="headerlink" title="在multimap或multiset中查找元素"></a>在multimap或multiset中查找元素</h3><p>在一个不允许重复关键字的关联容器中查找一个元素是- -件很简单的事情一元素要么在容器中，要么不在。但对于允许重复关键字的容器来说，过程就更为复杂:在容器中可能有很多元素具有给定的关键字。如果一个multimap或multiset中有多个元素具有给定关键字，则这些元素在容器中会<code>相邻存储</code>。</p>
<p>例如，给定一个从作者到著作题目的映射,我们可能想打印一个特定作者的所有著作。可以用三种不同方法来解决这个问题。最直观的方法是使用find和count:</p>
<pre><code>string search_ item(&quot;Alain de Botton&quot;) ;
//要查找的作者
auto entries = authors.count (search_item) ;
//元素的数量
auto iter = authors.find(search_item) ;
//此作者的第一本书
//用一个循环查找此作者的所有著作
while (entries) {
    cout &lt;&lt; iter-&gt;second &lt;&lt; endl;
    //打印每个题目
    ++iter;
    //前进到下一本书
    --entries;
    //记录已经打印了多少本书
    }</code></pre><p>首先调用count确定此作者共有多少本著作，并调用find获得一个迭代器，指向第一个关键字为此作者的元素。for循环的迭代次数依赖于count的返回值。特别是，如果count返回0，则循环一次也不执行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/23/io-e5-ba-93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/23/io-e5-ba-93/" class="post-title-link" itemprop="url">IO库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-01-23 09:16:58" itemprop="dateCreated datePublished" datetime="2019-01-23T09:16:58+08:00">2019-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h1><ul>
<li><p>IO库</p>
</li>
<li><p>头文件</p>
</li>
<li><p>IO对象无赋值拷贝</p>
</li>
<li><p>管理输出缓冲</p>
<ul>
<li>缓冲刷新的原因</li>
<li>endl</li>
</ul>
</li>
<li><p>文件输入输出</p>
<ul>
<li>使用文件流对象</li>
</ul>
</li>
<li><p>string流</p>
<ul>
<li>istringstream</li>
<li>ostringstream</li>
</ul>
</li>
</ul>
<p>C++语言不直接处理输入输出，而是通过一族定义在标准库中的类型来处理IO。这些类型支持从设备读取数据、向设备写入数据的IO操作，设备可以是文件、控制台窗口等。还有一些类型允许内存IO,即从string读取数据，向string写入数据。</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>头文件</p>
<p>类型</p>
<p>iostream</p>
<p>读写流</p>
<p>fstream</p>
<p>读写文件</p>
<p>sstream</p>
<p>读写string</p>
<h2 id="IO对象无赋值拷贝"><a href="#IO对象无赋值拷贝" class="headerlink" title="IO对象无赋值拷贝"></a>IO对象无赋值拷贝</h2><p>不能拷贝或对IO对象赋值:</p>
<pre><code>ofstream out1，out2 ;
out1 = out2;
//错误:不能对流对象赋值
ofstream print (ofstream) ;
//错误:不能初始化ofstream参数
out2 = print (out2) ;
//错误:不能拷贝流对象</code></pre><p>由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以<strong>引用方式</strong>传递和返回流。读写一个I0对象会改变其状态，因此传递和返回的引用<strong>不能</strong>是const的。</p>
<h2 id="管理输出缓冲"><a href="#管理输出缓冲" class="headerlink" title="管理输出缓冲"></a>管理输出缓冲</h2><p>每个输出流都管理一个缓冲区，用来保存程序读写的数据。例如，如果执行下面的代码</p>
<pre><code>OS &lt;&lt; &quot;please enter a value: &quot;;</code></pre><p>文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。</p>
<h4 id="缓冲刷新的原因"><a href="#缓冲刷新的原因" class="headerlink" title="缓冲刷新的原因"></a>缓冲刷新的原因</h4><p>导致缓冲刷新的原因有很多：</p>
<ul>
<li>程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行；</li>
<li>缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。</li>
<li>我们可以使用操纵符如endl (参见1.2节，第6页)来显式刷新缓冲区。</li>
<li>在每个输出操作之后，我们可以用操纵符unitbuf设置流的内部状态，来清空冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的</li>
<li>一个输出流可能被关联到另-一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin和cerr都关联到cout。因此，读cin或写cerr都会导致cout的缓冲区被刷新。</li>
</ul>
<h4 id="endl"><a href="#endl" class="headerlink" title="endl"></a>endl</h4><p>我们已经使用过操纵符endl,它完成换行并刷新缓冲区的工作。I0库中还有两个类似的操纵符: flush和ends。flush刷新缓冲区，但不输出任何额外的字符: ends向缓冲区插入一个空字符，然后刷新缓冲区:</p>
<pre><code>cout &lt;&lt; &quot;hi!&quot; &lt;&lt; endl; //输出hi和一个换行，然后刷新缓冲区
cout &lt;&lt; &quot;hi!&quot; &lt;&lt; flush; // 输出hi,然后刷新缓冲区，不附加任何额外字符
cout &lt;&lt; &quot;hi!&quot; &lt;&lt; ends ;//输出hi和一个空字符，然后刷新缓冲区</code></pre><h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><blockquote>
<p>有时候写程序的时候总想要输入输出文件，但是总是不知道怎么弄这个格式。</p>
</blockquote>
<p>头文件fstream定义了三个类型来支持文件IO:ifstream从一.个给定文件读取数据，ofstream向一个给定文件写入数据，以及fstream可以读写给定文件。</p>
<h3 id="使用文件流对象"><a href="#使用文件流对象" class="headerlink" title="使用文件流对象"></a>使用文件流对象</h3><p>创建文件流对象时,我们可以提供文件名(可选的)。如果提供了一个文件名，则open会自动被调用:</p>
<pre><code>ifstream in(ifile) ;
//构造一个ifstream并打开给定文件
ofstream out;
//输出文件流未关联到任何文件</code></pre><p>这段代码定义了一个输入流in，它被初始化为从文件读取数据，文件名由string类型的参数ifile指定。第二条语句定义了一个输出流out，未与任何文件关联。在新C++ 11 标准中，文件名既可以是库类型string对象，也可以是C风格字符数组（“12321”类似这种）。旧版本的标准库只允许C风格字符数组。</p>
<h2 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h2><p>其实IO处理String应该较多，大多都是处理文本数据。这些文本数据都是string组成的。 考虑这样一个例子，假定有一个文件，列出了一些人和他们的电话号码。某些人只有一个号码，而另一些人则有多个一家庭电话、工作电话、移动电话等。我们的输入文件 看起来可能是这样的:</p>
<pre><code>morgan 2015552368 8625550123
drew 9735550130
lee 6095550132 2015550175 8005550000</code></pre><p>文件中每条记录都以一个人名开始，后面跟随- -个或多个电话号码。我们首先定义一个简单的类来描述输入数据:</p>
<pre><code>//成员默认为公有;参见7.2节(第240页)
struct PersonInfo {
    string name ; 
    vector&lt;string&gt; phones;
};</code></pre><h3 id="istringstream"><a href="#istringstream" class="headerlink" title="istringstream"></a>istringstream</h3><p>我们的程序会读取数据文件，并创建-一个PersonInfo的vector. vector中每个元素对应文件中的一条记录。我们在一个循环中处理输入数据，每个循环步读取一条记录，提取出一个人名和若干电话号码:</p>
<pre><code>string line, word;
//分别保存来自输入的一行和单词
vector&lt;PersonInfo&gt; people;
//保存来自输入的所有记录
//逐行从输入读取数据，直至cin遇到文件尾(或其他错误)
while (getline(cin, line) ) {
    PersonInfo info;
    //创建一个保存此记录数据的对象
    istringstream record(line); // 将记录绑定到刚读入的行
    record &gt;&gt; info.name;
    //读取名字
    while (record &gt;&gt; word)
    //读取电话号码
     info.phones.push_back(word) ; //保持它们
    people.push_back(info) ;
//将此记录追加到people末尾
}</code></pre><p>这里我们用getline从标准输入读取整条记录。如果getline调用成功，那么line中将保存着从输入文件而来的一条记录。在while中,我们定义了一个局部PersonInfo对象，来保存当前记录中的数据。 接下来我们将一根istringstream与刚刚读取的文本行进行绑定，这样就可以在此istringstream上使用输入运算符来读取当前记录中的每个元素。</p>
<h3 id="ostringstream"><a href="#ostringstream" class="headerlink" title="ostringstream"></a>ostringstream</h3><p>当我们逐步构造输出，希望最后一起打印时，ostringstream 是很有用的。例如，对上一节的例子,我们可能想逐个验证电话号码并改变其格式。如果所有号码都是有效的,我们希望输出一个新的文件，包含改变格式后的号码。对于那些无效的号码，我们不会将它们输出到新文件中，而是打印一条包含人名和无效号码的错误信息。 由于我们不希望输出有无效电话号码的人，因此对每个人，直到验证完所有电话号码后才可以进行输出操作。但是，我们可以先将输出内容“写入”到一个内存ostringstream中:</p>
<pre><code>for(const auto &amp;entry : people) { //对people中每一项
    ostringstream formatted, badNums; // 每个循环步创建的对象
    for(const auto &amp;nums : entry.phones) { // 对每个数
    if(!valid (nums)) {
    badNums &lt;&lt; &quot; &quot; &lt;&lt; nums; //将数的字符串形式存入badNums i
    }
    else
    {
        //将格式化的字符串“写入”formatted
        formatted &lt;&lt;” ”&lt;&lt; format (nums);
    }
    //打印名字
    if (badNums.str().empty())//没有错误的数
        os &lt;&lt; entry.name &lt;&lt;” ”&lt;&lt; formatted.str() &lt;&lt; endl;
    //和格式化的数
    //否则，打印名字和错误的数
    else
    cerr &lt;&lt; &quot;input error:&quot;&lt;&lt; entry.name &lt;&lt; &quot;invalid number (s) &quot;&lt;&lt; badNums.str() &lt;&lt; endl;
}</code></pre><p>在此程序中，我们假定已有两个函数，valid和format,分别完成电话号码验证和改变格式的功能。程序最有趣的部分是对字符串流formatted和badNums的使用。我们使用标准的输出运算符(&lt;&lt;)向这些对象写入数据,但这些“写入”操作实际上转换为string操作，分别向formatted和badNums中的string对象添加字符。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/21/e5-a7-94-e6-89-98-e6-9e-84-e9-80-a0-e5-87-bd-e6-95-b0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/21/e5-a7-94-e6-89-98-e6-9e-84-e9-80-a0-e5-87-bd-e6-95-b0/" class="post-title-link" itemprop="url">委托构造函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-01-21 08:02:56" itemprop="dateCreated datePublished" datetime="2019-01-21T08:02:56+08:00">2019-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h1><blockquote>
<p>C++11的新标准，有点牛批的感觉啊</p>
</blockquote>
<ul>
<li>委托构造函数<ul>
<li>定义</li>
</ul>
</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>C++11新标准扩展了构造函数初始值的功能,使得我们可以定义所谓的委托构造函数(delegating constructor)。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些(或者全部)职责委托给了其他构造函数。</p>
<blockquote>
<p>就是让别的构造函数来构造自己。</p>
</blockquote>
<p>和其他构造函数一样，一个委托构造函数也有一个成员初始值的列表和一个函数体。在委托构造函数内，成员初始值列表只有一个唯一的入口，就是类名本身。和其他成员初始值一样，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另外一个构造函数匹配。 举个例子，我们使用委托构造函数重写Sales_data类，重写后的形式如下所示:</p>
<pre><code>class Sales_data {
public:
    //非委托构造函数使用对应的实参初始化成员
    Sales_data(std::string s, unsigned cnt，double price) :bookNo(s)，units_sold(cnt), revenue (cnt*price) {}
    .//其余构造函数全都委托给另一.个构造函数
    Sales_data() : Sales_ data(&quot;&quot;, 0，0) { }
    Sales_data(std::string s) : Sales_data(s, 0,0) { }
    Sales_data(std::istream &amp;is) : Sales_data ()
    { read(is, *this) ; }
    //其他成员与之前的版本一致
};</code></pre><p>在这个Sales_data类中，除了一个构造函数外其他的都委托了它们的工作。第一个构造函数接受三个实参，使用这些实参初始化数据成员，然后结束工作。我们定义默认构造函数令其使用三参数的构造函数完成初始化过程，它也无须执行其他任务，这一点从空的构造函数体能看得出来。接受一个string的构造函数同样委托给了三参数的版本。</p>
<blockquote>
<p>有点像是这个类的继承</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/18/e5-90-ab-e6-9c-89-e5-8f-af-e5-8f-98-e5-bd-a2-e5-8f-82-e7-9a-84-e5-87-bd-e6-95-b0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/18/e5-90-ab-e6-9c-89-e5-8f-af-e5-8f-98-e5-bd-a2-e5-8f-82-e7-9a-84-e5-87-bd-e6-95-b0/" class="post-title-link" itemprop="url">含有可变形参的函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-01-18 09:21:15" itemprop="dateCreated datePublished" datetime="2019-01-18T09:21:15+08:00">2019-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="含有可变形参的参数"><a href="#含有可变形参的参数" class="headerlink" title="含有可变形参的参数"></a>含有可变形参的参数</h1><p>有时候我们无法提前预知应该向参数传递几个实参，为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法:如果所有的实参类型相同，可以传递一个名为<strong>initializer_list</strong>的标准库类型;如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板，关于它的细节将在16.4节(第618页)介绍。</p>
<blockquote>
<p>就是类似vector，你不知道数组的长度就使用vector。</p>
</blockquote>
<pre><code>void error_msg (initializer_list&lt;string&gt; il)
{
    for (auto beg = il.begin() ; beg != il.end() ; + +beg)
    cout &lt;&lt; *beg&lt;&lt;” ”;
    cout &lt;&lt; endl ;
}</code></pre><blockquote>
<p>这个好像和什么vector没啥区别啊，但是为什么要特别用到呢？</p>
</blockquote>
<p>和vector不一样的是，initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/18/e5-bc-95-e7-94-a8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/18/e5-bc-95-e7-94-a8/" class="post-title-link" itemprop="url">引用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-01-18 07:46:07" itemprop="dateCreated datePublished" datetime="2019-01-18T07:46:07+08:00">2019-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote>
<p>这个东西用不好就是坑，用好了还是很强的。</p>
</blockquote>
<h2 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h2><p>传参就不说了，主要是避免一个问题——避免拷贝。有些数据较大的对象或者容器，如果传参的时候不用引用的话需要对其进行拷贝，这样的开销较大。应该使用引用值，直接对原数组进行操作，这样避免额外的开销，效率也会更快。</p>
<pre><code>//比如对这个vector容器进行操作的时候，一般都是使用引用值。
vector&lt;int&gt; test(vector&lt;int&gt; &amp; nums)
{
...
}</code></pre><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>有时候并不改变传入的参数的值，那么建议使用<strong>对常量的引用</strong></p>
<pre><code>// 比较两个string的大小
bool isShorter (const string &amp;s1, const string &amp;s2)
[
return s1.size() &lt; s2.size() ;
]</code></pre><blockquote>
<p>如果函数无须改变引用形参的值，最好将其声明为常量引用。</p>
</blockquote>
<h2 id="引用形参返回额外信息"><a href="#引用形参返回额外信息" class="headerlink" title="引用形参返回额外信息"></a>引用形参返回额外信息</h2><p>一个函数只能返回一个值，然而有时候函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效途径。</p>
<p>简单来说就是在传参的时候使用引用值，然后在函数体内改变这个引用的值，也就达到了一次返回多个值。</p>
<pre><code>//返回s中c第一次出现的位置索引
//引用形参occurs负责统计c出现的总次数
string: :size_ type find_ char (const string &amp;S，char C,
string: :size_ type &amp;occurs )
{
auto ret = s.size() ;
//第一次出现的位置(如果有的话)
occurs 
= 0;
//设置表示出现次数的形参的值
for (decltype(ret) i = 0; i != s.size() ; ++i) {
    if (s[i] == c) {
      if (ret == s.size() )
        ret = i;
        . //记录c第一次出现的位置
        ++occurs ;
        . //将出现的次数加1
        }
    }
return ret ;
//出现次数通过occurs隐式地返回
}</code></pre><p>当我们调用find_char函数时，必须传入三个实参:作为查找范围的一个string对象、要找的字符以及一个用于保存字符出现次数的size_ type (参见3.2.2节，第79页)对象。假设s是一个string对象，ctr是一个size_ type对象，则我们通过如下形式调用find char函数:</p>
<pre><code>auto index = find char(s, &apos;o&apos;，ctr) ;</code></pre><p>调用完成后，如果string对象中确实存在o,那么ctr的值就是。出现的次数，index指向。第一次出现的位置;否则如果string对象中没有o，index等于s.size()而ctr等于0。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/18/e5-b1-80-e9-83-a8-e9-9d-99-e6-80-81-e5-af-b9-e8-b1-a1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/18/e5-b1-80-e9-83-a8-e9-9d-99-e6-80-81-e5-af-b9-e8-b1-a1/" class="post-title-link" itemprop="url">局部静态对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-01-18 07:16:13" itemprop="dateCreated datePublished" datetime="2019-01-18T07:16:13+08:00">2019-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="局部静态对象"><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h1><p>在程序的执行路径第一次经过对象定义局域时初始化，知道程序终止时才被销毁，在此期间即使对象所在的函数结束也不会对它有影响。</p>
<pre><code>size_t count_calls ()
f
static size_t ctr = O; //调用结束后，这个值仍然有效
return ++ctr;
)
int main()
[
for(sizeti=O;i!=10;++i)
cout &lt;&lt; count calls () &lt;&lt; endl ;
return O;
)</code></pre><p>在控制流第一次经过ctr的定义之前，ctr被创建并初始化为0。每次调用将ctr加1并返回新值。每次执行count_calls函数时，变量ctr的值都已经存在并且等于函数上一次退出时ctr的值。因此，第二次调用时ctr的值是1，第三次调用时ctr的值是2，以此类推。</p>
<blockquote>
<p>反正就是静态局部变量初始化后再次调用该函数，crr不会重新初始化，而是继续用上次的值。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/17/try-e8-af-ad-e5-8f-a5-e5-9d-97-e5-92-8c-e5-bc-82-e5-b8-b8-e5-a4-84-e7-90-86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/17/try-e8-af-ad-e5-8f-a5-e5-9d-97-e5-92-8c-e5-bc-82-e5-b8-b8-e5-a4-84-e7-90-86/" class="post-title-link" itemprop="url">try语句块和异常处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-01-17 08:44:02" itemprop="dateCreated datePublished" datetime="2019-01-17T08:44:02+08:00">2019-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h1><ul>
<li>try语句块和异常处理<ul>
<li>定义<ul>
<li>异常处理方式</li>
</ul>
</li>
<li>throw表达式<ul>
<li>cerr解释</li>
</ul>
</li>
<li>try-catch</li>
<li>标准异常<ul>
<li>定义的异常类</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这个东西一般比较少用到，好像以前在Java里经常用。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。典型的异常包括失去数据库连接以及遇到意外输入等。处理反常行为可能是设计所有系统最难的一部分。</p>
<h3 id="异常处理方式"><a href="#异常处理方式" class="headerlink" title="异常处理方式"></a>异常处理方式</h3><ul>
<li>throw表达式；</li>
<li>try语句块，也就是try-catch。try语句块中代码抛出的异常通常会被磨具个catch子句处理。因为catch子句“处理”异常，所以它们也被称作异常处理代码；</li>
<li>一套异常类。</li>
</ul>
<p>下面详细介绍一下这几种方式。</p>
<h2 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h2><p>一般业务代码中都要处理错误，输出一些信息，这样才能快速定位哪里出错了。比如下面这个代码检查它读入的记录是否是关于同一种书籍，如果不是，输出一条信息然后退出。</p>
<pre><code>Sales_ item item1, item2;
cin &gt;&gt; item1 &gt;&gt; item2;
// 检查 item1 和 item2 是否表示同一种书籍
if(item1.isbn() == item2. isbn()) {
cout &lt;&lt; item1 + item2 &lt;&lt; endl ;
return O; // success
} else {
cerr &lt;&lt; &quot;Data must refer to same ISBN&quot; &lt;&lt; endl ;
//cerr 是一个ostream对象，关联到标准错误，通常写入到与标准输出相同的设备。
return -1; // failed
}</code></pre><h4 id="cerr解释"><a href="#cerr解释" class="headerlink" title="cerr解释"></a>cerr解释</h4><p>cerr不经过缓冲而直接输出，一般用于迅速输出出错信息，是标准错误，默认情况下被关联到标准输出流，但它不被缓冲，也就说错误消息可以直接发送到显示器，而无需等到缓冲区或者新的换行符时，才被显示。一般情况下不被重定向。</p>
<blockquote>
<p>这个东西很少见啊，又学习到了新的知识了。</p>
</blockquote>
<p>接上述代码，在真实的程序中，应该把对象相加的代码和用户交互的代码分离开来。此例中，我们改写程序似的检查完成和惠普不再直接输出一条信息，而是<strong>抛出一个异常</strong>：</p>
<pre><code>//首先检查两条数据是否是关于同一种书籍的
if (iteml. isbn() != item2 . isbn() )
throw runtime_error (&quot;Data must refer to same ISBN&quot;) ;
//如果程序执行到了这里，表示两个ISBN是相同的
cout &lt;&lt; item1 + item2 &lt;&lt; endl ;</code></pre><blockquote>
<p>但是这样做有什么用呢？是给后面的try-catch使用的？</p>
</blockquote>
<h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h2><p>try语句块的一开始是关键字try，随后紧跟着一个块。</p>
<p>在之前的例子里，我们使用了一个throw表达式以避免把两个代表不同书籍的 Sales_item相加。我们假设执行Sales_item 对象加法的代码是与用户交互的代码分离开来的。其中与用户交互的代码负责处理发生的异常，它的形式可能如下所示:</p>
<pre><code>while (cin &gt;&gt; item1 &gt;&gt; item2) {
try {
//执行添加两个Sales_ item对象的代码
//如果添加失败，代码抛出一个runtime_ error异常
    if (iteml. isbn() != item2 . isbn() )
    throw runtime_error (&quot;Data must refer to same ISBN&quot;) ;
    //如果程序执行到了这里，表示两个ISBN是相同的
    cout &lt;&lt; item1 + item2 &lt;&lt; endl ;

} catch (runtime_error err) {
//提醒用户两个ISBN必须一致，询问是否重新输入
    cout &lt;&lt; err.what ()&lt;&lt; &quot;\nTry Again? Enter y or n&quot; &lt;&lt; endl ;
    char C;
    cin &gt;&gt; C;
    if(!cin || c ==&apos;n&apos; )
        break; // 跳出while循环
      }
 }</code></pre><p>上面的<code>err.what()</code>就是这个runtime_error后面的字符串。</p>
<p>给用户的提示信息中输出了err.what() 的返回值。我们知道err的类型是 runtime error, 因此能推断what是runtime error 类的一一个成员函数(参见1.5.2节，第20页)。每个标准库异常类都定义了名为what的成员函数，这些函数没有参数，返回值是C风格字符串(即const char*)。 其中， runtime error的what成员返回的是初始化–个具体对象时所用的string对象的副本。如果上一-节编写的代码抛出异常，则本节的catch子句输出：</p>
<pre><code>Data must refer to same ISBN
Try Again? Enter y or n</code></pre><h2 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h2><p>C++标准库定义了一-组类，用于报告标准库函数遇到的问题。这些异常类也可以在用户编写的程序中使用，它们分别定义在4个头文件中:</p>
<ul>
<li>exception头文件定义了最通用的异常类exception。它只报告异常的发生，不提供任何额外信息。</li>
<li>stdexcept头文件定义了几种常用的异常类，详细信息在表5.1中列出。</li>
<li>new头文件定义了bad_alloc异常类型，这种类型将在12.1.2节(第407页)详细介绍。</li>
<li>type_info头文件定义了bad_cast异常类型，这种类型将在19.2节(第731页)详细介绍。</li>
</ul>
<h4 id="定义的异常类"><a href="#定义的异常类" class="headerlink" title="定义的异常类"></a><stdexcept>定义的异常类</h4><p>类</p>
<p>解释</p>
<p>exception</p>
<p>最常见的问题</p>
<p>runtime_error</p>
<p>只有在运行时才能检测出的问题</p>
<p>range_error</p>
<p>运行时错误:生成的结果超出了有意义的值域范围</p>
<p>overflow error</p>
<p>运行时错误:计算上溢</p>
<p>underflow_error</p>
<p>运行时错误:计算下溢</p>
<p>logic_error</p>
<p>程序逻辑错误</p>
<p>domain_error</p>
<p>逻辑错误:参数对应的结果值不存在</p>
<p>invalid_argument</p>
<p>逻辑错误:无效参数</p>
<p>length_error</p>
<p>逻辑错误:试图创建一个超出该类型最大长度的对象</p>
<p>out_of_range</p>
<p>逻辑错误:使用一个超出有效范围的值</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/17/e8-8c-83-e5-9b-b4for-e8-af-ad-e5-8f-a5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/17/e8-8c-83-e5-9b-b4for-e8-af-ad-e5-8f-a5/" class="post-title-link" itemprop="url">范围for语句</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-01-17 08:07:07" itemprop="dateCreated datePublished" datetime="2019-01-17T08:07:07+08:00">2019-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h1><p>这个东西也算有点熟悉了，但是还是不是完全会用，也不知道到底什么场合适合用这个东西。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><pre><code>for (declaration : expression)
    statement</code></pre><p>声明和表达式，expression必须是一个序列，比如<code>vector</code>和<code>string</code>等等。这些类型的共同特点是能返回迭代器的begin和end成员。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><pre><code>vector&lt;int&gt; v = {0,1,2,3,4,5,6, 7,8,9};
//范围变量必须是引用类型，这样才能对元素执行写操作
for (auto &amp;r : v)
//对于v中的每一个元素
r *=2; //将v中每个元素的值翻倍</code></pre><p>上面的代码等价于下面的代码</p>
<pre><code>for (auto beg = v.begin() ，end = v.end() ; beg != end; ++beg) {
auto &amp;r = *beg; // r必须是引用类型，这样才能对元素执行写操作
r *=2; //将v中每个元素的值翻倍
}</code></pre><p>所以可以看到这个签名的<code>declaration</code>就是一个迭代器指针一样的东西。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在使用vector的时候，不能通过范围for语句增加vector对象的元素，因为一旦在序列中添加或者删除元素，end函数的值就可能变得无效。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/29/e8-bf-ad-e4-bb-a3-e5-99-a8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="tanwenbo">
      <meta itemprop="description" content="enjoy share">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hhyvs111">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/29/e8-bf-ad-e4-bb-a3-e5-99-a8/" class="post-title-link" itemprop="url">迭代器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-12-29 07:23:14" itemprop="dateCreated datePublished" datetime="2018-12-29T07:23:14+08:00">2018-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-14 14:29:36" itemprop="dateModified" datetime="2020-04-14T14:29:36+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>简单来说一下迭代器和其它的有什么区别？ 一般都习惯用这个数组来操作，很少用这个迭代器，但是针对stl中一切特别的容器可能就不能直接通过下标来访问容器，需要使用迭代器。</p>
<h3 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h3><p>迭代器只有<code>begin</code>和<code>end</code>两个成员，其中begin是返回第一个元素，end自然是返回容器中最后一个元素。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>如果上了C++11还是要多用这个auto，不知道面试的时候可以使用这个auto么，应该可以吧。</p>
<pre><code>for( auto it = s.begin(); it != s.end() &amp;&amp; !isspace(*it); ++it)
    *it = toupper(*it);
    //将当前字符改成大写形式</code></pre><h3 id="const类型"><a href="#const类型" class="headerlink" title="const类型"></a>const类型</h3><p>迭代器也有类型，比如<code>const_iterator</code>，这种和常量指针差不多，能读取但不能修改它所指的元素值。</p>
<pre><code>vector&lt;int&gt;::iterator it;
//能读写
vector&lt;int&gt;::const_iterator it3;

//只能读</code></pre><h4 id="cbegin"><a href="#cbegin" class="headerlink" title="cbegin"></a>cbegin</h4><p>如果对象只需读而无需写的话最好使用常量类型。C++11中，提供了cbegin，这种无论vector是否是常量，返回值都是const。</p>
<h3 id="解引用"><a href="#解引用" class="headerlink" title="解引用"></a>解引用</h3><p>解引用迭代器可获得迭代器所指的对象。但是如果检查是否为空，那么要对it加空格，运算符优先级规则</p>
<pre><code>(*it).empty();</code></pre><blockquote>
<p>这个it就是个指针，可以用箭头运算符<code>-&gt;</code>。</p>
</blockquote>
<p>在访问迭代器的成员时（比如这个迭代器指向一个结构体），it-&gt;mem和(*it).mem的意思是相同的。</p>
<h3 id="vector对象操作"><a href="#vector对象操作" class="headerlink" title="vector对象操作"></a>vector对象操作</h3><p>如果对vector进行push_back等增删操作会使当前vector对象的迭代器失效。</p>
<h3 id="迭代器移动"><a href="#迭代器移动" class="headerlink" title="迭代器移动"></a>迭代器移动</h3><p>迭代器也能直接移动，加减整数表达式可以直接跳着走，这个和指针的操作是一样的。</p>
<h4 id="二分应用"><a href="#二分应用" class="headerlink" title="二分应用"></a>二分应用</h4><p>这个二分查找还是不要用递归了，效率实在是太低，这样栈空间消耗太大了。很多方法都是用的while循环直接查找。</p>
<h5 id="迭代器二分查找"><a href="#迭代器二分查找" class="headerlink" title="迭代器二分查找"></a>迭代器二分查找</h5><pre><code>auto beg = text.begin(), end = text.end();
auto mid = beg + (end - beg)/2;
while(beg &lt; end &amp;&amp; *mid!=target){
//目标值在mid的右边
if(*mid &lt; target)
//加1的原因：如果mid比tar小，则要找的元素必定出现在mid所指元素的后面，此时将beg
    beg = mid + 1;
else
    end = mid;

mid = beg + (end - beg)/2;
}</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>向一个vector、string或deque插入元素会使所有指向容器的迭代器、引用和指针失效！那么删除操作呢？</p>
<h3 id="改变容器的循环程序"><a href="#改变容器的循环程序" class="headerlink" title="改变容器的循环程序"></a>改变容器的循环程序</h3><p>添加删除vector、string或deque元素的循环程序必须考虑迭代器、引用和指针可能失效的问题。程序必须保证每个循环步中都更新迭代器、引用或指针。如果循环中调用的是insert或erase,那么更新迭代器很容易。这些操作都返回迭代器，我们可以用来更新:</p>
<pre><code>//傻瓜循环,删除偶数元素，复制每个奇数元素
vector&lt;int&gt; vi = {0,1,2,3,4,5,6, 7,8,9};
auto iter = vi.begin(); //调用begin而不是cbegin, 因为我们要改变vi
while (iter != vi.end() ) {
    if (*iter 各2) {
    iter = vi. insert(iter, *iter); //复制当前元素
    iter += 2; //向前移动迭代器，跳过当前元素以及插入到它之前的元素
} else
    iter = vi.erase (iter) ;//删除偶数元素

 //不应向前移动迭代器，iter指向我们删除的元素之后的元素
}</code></pre><p>次程序删除vector中的偶数元素，并赋值每个奇数值元素。我们在调用insert和erase后都更新迭代器，因为两者都会使迭代器失效。</p>
<p><strong>在调用erase后，不必递增迭代器，因为erase返回的迭代器已经指向序列中的下一个元素。</strong></p>
<h3 id="容量增长"><a href="#容量增长" class="headerlink" title="容量增长"></a>容量增长</h3><p>vector等顺序容器是自增长的，并不是每次插入元素就会更新内存。而是选择增长一定长度的容量。</p>
<p>vector的实现采用的策略是在每次需要分配新内存空间时将当前容量翻倍。一般是存储满了才会进行容量的翻倍操作。 <img src="https://tanwenbo.top/wp-content/uploads/2019/01/90c0d4f4ccd58e56e659497b9fa71564.png" alt=""></p>
<p>也就是size会小于capacity！但是也不一定就是翻倍，要看具体实现。</p>
<p>虽然不同的实现可以采用不同的分配策略，但所有实现都应遵循-一个原则:确保用push_back向vector添加元素的操作有高效率。从技术角度说，就是通过在一个初始为空的vector上调用n次push_ back来创建一一个n个元素的vector,所花费的时间不能超过n的常数倍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tanwenbo</p>
  <div class="site-description" itemprop="description">enjoy share</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">111</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">70</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tanwenbo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
